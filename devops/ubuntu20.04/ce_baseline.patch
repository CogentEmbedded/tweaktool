diff --git a/.clang-format b/.clang-format
index ff7c2f0..015dab8 100644
--- a/.clang-format
+++ b/.clang-format
@@ -5,10 +5,12 @@ ColumnLimit: 79
 AlignConsecutiveAssignments: true
 AlignConsecutiveDeclarations: true
 AlignTrailingComments: true
-AlignEscapedNewlinesLeft: true
+AlignEscapedNewlines: Left
 PointerAlignment: Right
+DerivePointerAlignment: false
 ForEachMacros: ['NNI_LIST_FOREACH']
 AlwaysBreakAfterReturnType: TopLevelDefinitions
 SpaceAfterCStyleCast: true
 AllowShortFunctionsOnASingleLine: Inline
 BreakBeforeBinaryOperators: None
+TabWidth: 8
diff --git a/README.adoc b/README.adoc
index ceec426..5a64f45 100644
--- a/README.adoc
+++ b/README.adoc
@@ -12,6 +12,7 @@ endif::[]
 // Note: If you're updating this file, don't forget to re-run asciidoctor
 // to update the aforementioned HTML file!
 
+image:https://raw.githubusercontent.com/vshymanskyy/StandWithUkraine/main/badges/StandWithUkraine.svg[Stand With Ukraine,link="https://stand-with-ukraine.pp.ua"]
 image:https://img.shields.io/github/workflow/status/nanomsg/nng/linux/master?logoColor=grey&logo=ubuntu&label=[Linux Status,link="https://github.com/nanomsg/nng/actions"]
 image:https://img.shields.io/github/workflow/status/nanomsg/nng/windows/master?logoColor=grey&logo=windows&label=[Windows Status,link="https://github.com/nanomsg/nng/actions"]
 image:https://img.shields.io/github/workflow/status/nanomsg/nng/darwin/master?logoColor=grey&logo=apple&label=[macOS Status,link="https://github.com/nanomsg/nng/actions"]
@@ -22,6 +23,8 @@ image:https://img.shields.io/static/v1?label=&message=docs&logo=asciidoctor&logo
 image:https://img.shields.io/github/license/nanomsg/nng.svg?logoColor=silver&logo=open-source-initiative&label=&color=blue[MIT License,link="https://github.com/nanomsg/nng/blob/master/LICENSE.txt"]
 image:https://img.shields.io/github/v/tag/nanomsg/nng.svg?logo=github&label=[Latest version,link="https://github.com/nanomsg/nng/releases"]
 
+Please see <<UKRAINE#,here>> for an important message for the people of Russia.
+
 NOTE: If you are looking for the legacy version of nanomsg, please
 see the https://github.com/nanomsg/nanomsg[nanomsg] repository.
 
diff --git a/UKRAINE.adoc b/UKRAINE.adoc
new file mode 100644
index 0000000..d86d3e1
--- /dev/null
+++ b/UKRAINE.adoc
@@ -0,0 +1,77 @@
+# Ukraine, Russia, and a World Tragedy
+
+## A message to those inside Russia
+
+### Written March 4, 2022.
+
+It is with a very heavy heart that I write this.  I am normally opposed to the use of open source
+projects to communicate political positions or advocate for things outside the immediate relevancy
+to that project.
+
+However, the events occurring in Ukraine, and specifically the unprecedented invasion of Ukraine by
+Russian forces operating under orders from Russian President Vladimir Putin compel me to speak out.
+
+Those who know me, know that I have family, friends, and colleagues in Russia, and Ukraine both.  My closest friends
+have historically been Russian friends my wife's hometown of Chelyabinsk.  I myself have in the past
+frequently traveled to Russia, and indeed operated a software development firm with offices in St. Petersburg.
+I had a special kinship with Russia and its people.
+
+I say "had", because I fear that the actions of Putin, and the massive disinformation campaign that his regime
+has waged inside Russia, mean that it's likely that I won't see those friends again.  At present, I'm not sure
+my wife will see her own mother again.  We no longer feel it's safe for either of us to return Russia given
+actions taken by the regime to crack down on those who express disagreement.
+
+Russian citizens are being led to believe it is acting purely defensively, and that only legitimate military
+targets are being targeted, and that all the information we have received in the West are fakes.
+
+I am confident that nothing could be further from the truth.
+
+This has caused many in Russia, including people whom I respect and believe to be smarter than this, to
+stand by Putin, and endorse his actions. The claim is that the entirety of NATO is operating at the behest
+of the USA, and that the entirety of Europe was poised to attack Russia. While this is clearly absurd to those
+of us with any understanding of western politics, Russian citizens are being fed this lie, and believing it.
+
+If you're reading this from inside Russia -- YOU are the person that I hope this message reaches.  Your
+government is LYING to you.  Of course, all governments lie all the time.  But consider this.  Almost the
+entire world has condemned the invasion of Ukraine as criminal, and has applied sanctions.  Even countries
+which have poor relations with the US sanctioning Russia, as well as nations which historically have remained
+neutral.  (Famously neutral -- even during World War II, Switzerland has acted to apply sanctions in
+concert with the rest of the world.)
+
+Ask yourself, why does Putin fear a free press so much, if what he says is true?  Why the crack-downs on
+children expressing only a desire for peace with Ukraine?  Why would the entire world unified against him,
+if Putin was in the right?  Why would the only countries that stood with Russia against
+the UN resolution to condemn these acts as crimes be Belarus, North Korea, and Syria?  Even countries normally
+allied to Russia could not bring themselves to do more than abstain from the vote to condemn it.
+
+To be clear, I do not claim that the actions taken by the West or by the Ukrainian government were completely
+blameless.  On the contrary, I understand that Western media is biased, and the truth is rarely exactly
+as reported.  I believe that there is a kernel of truth in the claims of fascists and ultra-nationalist
+militias operating in Ukraine and specifically Donbas.  However, I am also equally certain that Putin's
+response is out of proportion, and that concerns about such militias are principally just a pretext to justify
+an invasion.
+
+Europe is at war, unlike we've seen in my lifetime.  The world is more divided, and closer to nuclear holocaust
+than it has been since the Cold War. And that is 100% the fault of Putin.
+
+While Putin remains in power, there cannot really be any way for Russian international relations to return
+to normal. Putin has set your country on a path to return to the Cold War, likely because he fancies himself
+to be a new Stalin.  However, unlike the Soviet Union, the Russian economy does not have the wherewithal to
+stand on its own, and the invasion of Ukraine has fully ensured that Russia will not find any friends anywhere
+else in Europe, and probably few places in Asia.
+
+The *only* paths forward for Russia are either a Russia without Putin (and those who would support his agenda),
+or a complete breakdown of Russian prosperity, likely followed by the increasing international conflict that will
+be the natural escalation from a country that is isolated and impoverished. Those of us observing from the West are
+gravely concerned, because we cannot see any end to this madness that does not result in nuclear conflict,
+unless from within.
+
+In the meantime, the worst prices will be paid for by innocents in Ukraine, and by young Russian mean
+forced to carry out the orders of Putin's corrupt regime.
+
+And *that* is why I write this -- to appeal to those within Russia to open your eyes, and think with
+your minds.  It is right and proper to be proud of your country and its rich heritage.  But it is also
+right and proper to look for ways to save it from the ruinous path that its current leadership has set it upon,
+and to recognize when that leadership is no longer acting in interest of the country or its people.
+
+  - Garrett D'Amore, March 4, 2022
\ No newline at end of file
diff --git a/demo/async/CMakeLists.txt b/demo/async/CMakeLists.txt
index 614bcfc..ef9311b 100644
--- a/demo/async/CMakeLists.txt
+++ b/demo/async/CMakeLists.txt
@@ -7,7 +7,7 @@
 # file was obtained (LICENSE.txt).  A copy of the license may also be
 # found online at https://opensource.org/licenses/MIT.
 
-cmake_minimum_required (VERSION 2.8.7)
+cmake_minimum_required (VERSION 2.8.12)
 
 project(nng-asyncdemo)
 
@@ -16,9 +16,12 @@ set(PARALLEL 128 CACHE STRING "Parallelism (min 4, max 1000)")
 # Call this from your own project's makefile.
 find_package(nng CONFIG REQUIRED)
 
+find_package(Threads)
+
 add_executable(server server.c)
 target_link_libraries(server nng::nng)
-target_compile_definitions(server PRIVATE -DPARALLEL=${PARALLEL})
+target_compile_definitions(server PRIVATE NNG_ELIDE_DEPRECATED PARALLEL=${PARALLEL})
 
 add_executable(client client.c)
 target_link_libraries(client nng::nng)
+target_compile_definitions(client PRIVATE NNG_ELIDE_DEPRECATED)
diff --git a/demo/async/run.sh b/demo/async/run.sh
index 856fea9..b5128eb 100755
--- a/demo/async/run.sh
+++ b/demo/async/run.sh
@@ -1,4 +1,4 @@
-#!/bin/bash
+#!/usr/bin/env bash
 
 ADDR=ipc:///tmp/async_demo
 COUNT=10
diff --git a/demo/http_client/CMakeLists.txt b/demo/http_client/CMakeLists.txt
index 3fe126f..8f4b62f 100644
--- a/demo/http_client/CMakeLists.txt
+++ b/demo/http_client/CMakeLists.txt
@@ -7,12 +7,15 @@
 # file was obtained (LICENSE.txt).  A copy of the license may also be
 # found online at https://opensource.org/licenses/MIT.
 
-cmake_minimum_required (VERSION 2.8.7)
+cmake_minimum_required (VERSION 2.8.12)
 
 project(http_client)
 
 # Call this from your own project's makefile.
 find_package(nng CONFIG REQUIRED)
 
+find_package(Threads)
+
 add_executable(http_client http_client.c)
 target_link_libraries(http_client nng::nng)
+target_compile_definitions(http_client PRIVATE NNG_ELIDE_DEPRECATED)
diff --git a/demo/raw/CMakeLists.txt b/demo/raw/CMakeLists.txt
index 15e481d..2df8d39 100644
--- a/demo/raw/CMakeLists.txt
+++ b/demo/raw/CMakeLists.txt
@@ -7,7 +7,7 @@
 # file was obtained (LICENSE.txt).  A copy of the license may also be
 # found online at https://opensource.org/licenses/MIT.
 
-cmake_minimum_required (VERSION 2.8.7)
+cmake_minimum_required (VERSION 2.8.12)
 
 project(raw)
 
@@ -15,6 +15,8 @@ set(PARALLEL 128 CACHE STRING "Parallelism (min 4, max 1000)")
 
 find_package(nng CONFIG REQUIRED)
 
+find_package(Threads)
+
 add_executable(raw raw.c)
 target_link_libraries(raw nng::nng)
-target_compile_definitions(raw PRIVATE -DPARALLEL=${PARALLEL})
+target_compile_definitions(raw PRIVATE NNG_ELIDE_DEPRECATED PARALLEL=${PARALLEL})
diff --git a/demo/reqrep/CMakeLists.txt b/demo/reqrep/CMakeLists.txt
index c7a258b..0923464 100644
--- a/demo/reqrep/CMakeLists.txt
+++ b/demo/reqrep/CMakeLists.txt
@@ -7,7 +7,7 @@
 # file was obtained (LICENSE.txt).  A copy of the license may also be
 # found online at https://opensource.org/licenses/MIT.
 
-cmake_minimum_required (VERSION 2.8.7)
+cmake_minimum_required (VERSION 2.8.12)
 
 project(reqrep)
 
@@ -20,3 +20,4 @@ find_package(Threads)
 
 add_executable(reqrep reqrep.c)
 target_link_libraries(reqrep nng::nng)
+target_compile_definitions(reqrep PRIVATE NNG_ELIDE_DEPRECATED)
diff --git a/demo/reqrep/reqrep.c b/demo/reqrep/reqrep.c
index 3fccf68..62ff29a 100644
--- a/demo/reqrep/reqrep.c
+++ b/demo/reqrep/reqrep.c
@@ -88,15 +88,15 @@ server(const char *url)
 	if (strncmp(url, "zt://", 5) == 0) {
 		printf("ZeroTier transport will store its keys in current working directory.\n");
 		printf("The server and client instances must run in separate directories.\n");
-		nng_listener_setopt_string(listener, NNG_OPT_ZT_HOME, ".");
-		nng_listener_setopt_ms(listener, NNG_OPT_RECONNMINT, 1);
-		nng_listener_setopt_ms(listener, NNG_OPT_RECONNMAXT, 1000);
-		nng_setopt_ms(sock, NNG_OPT_REQ_RESENDTIME, 2000);
-		nng_setopt_ms(sock, NNG_OPT_RECVMAXSZ, 0);
-		nng_listener_setopt_ms(listener, NNG_OPT_ZT_PING_TIME, 10000);
-		nng_listener_setopt_ms(listener, NNG_OPT_ZT_CONN_TIME, 1000);
+		nng_listener_set_string(listener, NNG_OPT_ZT_HOME, ".");
+		nng_listener_set_ms(listener, NNG_OPT_RECONNMINT, 1);
+		nng_listener_set_ms(listener, NNG_OPT_RECONNMAXT, 1000);
+		nng_socket_set_ms(sock, NNG_OPT_REQ_RESENDTIME, 2000);
+		nng_socket_set_ms(sock, NNG_OPT_RECVMAXSZ, 0);
+		nng_listener_set_ms(listener, NNG_OPT_ZT_PING_TIME, 10000);
+		nng_listener_set_ms(listener, NNG_OPT_ZT_CONN_TIME, 1000);
 	} else {
-		nng_setopt_ms(sock, NNG_OPT_REQ_RESENDTIME, 2000);
+		nng_socket_set_ms(sock, NNG_OPT_REQ_RESENDTIME, 2000);
 	}
 	nng_listener_start(listener, 0);
 
@@ -158,15 +158,15 @@ client(const char *url)
 	if (strncmp(url, "zt://", 5) == 0) {
 		printf("ZeroTier transport will store its keys in current working directory\n");
 		printf("The server and client instances must run in separate directories.\n");
-		nng_dialer_setopt_string(dialer, NNG_OPT_ZT_HOME, ".");
-		nng_dialer_setopt_ms(dialer, NNG_OPT_RECONNMINT, 1);
-		nng_dialer_setopt_ms(dialer, NNG_OPT_RECONNMAXT, 1000);
-		nng_setopt_ms(sock, NNG_OPT_REQ_RESENDTIME, 2000);
-		nng_setopt_ms(sock, NNG_OPT_RECVMAXSZ, 0);
-		nng_dialer_setopt_ms(dialer, NNG_OPT_ZT_PING_TIME, 10000);
-		nng_dialer_setopt_ms(dialer, NNG_OPT_ZT_CONN_TIME, 1000);
+		nng_dialer_set_string(dialer, NNG_OPT_ZT_HOME, ".");
+		nng_dialer_set_ms(dialer, NNG_OPT_RECONNMINT, 1);
+		nng_dialer_set_ms(dialer, NNG_OPT_RECONNMAXT, 1000);
+		nng_socket_set_ms(sock, NNG_OPT_REQ_RESENDTIME, 2000);
+		nng_socket_set_ms(sock, NNG_OPT_RECVMAXSZ, 0);
+		nng_dialer_set_ms(dialer, NNG_OPT_ZT_PING_TIME, 10000);
+		nng_dialer_set_ms(dialer, NNG_OPT_ZT_CONN_TIME, 1000);
 	} else {
-		nng_setopt_ms(sock, NNG_OPT_REQ_RESENDTIME, 2000);
+		nng_socket_set_ms(sock, NNG_OPT_REQ_RESENDTIME, 2000);
 	}
 
 	nng_dialer_start(dialer, NNG_FLAG_NONBLOCK);
diff --git a/demo/rest/CMakeLists.txt b/demo/rest/CMakeLists.txt
index 5466e3c..d5dd4fe 100644
--- a/demo/rest/CMakeLists.txt
+++ b/demo/rest/CMakeLists.txt
@@ -7,11 +7,14 @@
 # file was obtained (LICENSE.txt).  A copy of the license may also be
 # found online at https://opensource.org/licenses/MIT.
 
-cmake_minimum_required (VERSION 2.8.7)
+cmake_minimum_required (VERSION 2.8.12)
 
 project(rest)
 
 find_package(nng CONFIG REQUIRED)
 
+find_package(Threads)
+
 add_executable(rest-server server.c)
 target_link_libraries(rest-server nng::nng)
+target_compile_definitions(rest-server PRIVATE NNG_ELIDE_DEPRECATED)
diff --git a/demo/rest/README.adoc b/demo/rest/README.adoc
index df3e30b..39f626f 100644
--- a/demo/rest/README.adoc
+++ b/demo/rest/README.adoc
@@ -20,7 +20,7 @@ There is a single "server" (rest-server) program, that does these:
 % ./rest-server &
 % curl -d ABC http://127.0.0.1:8888/api/rest/rot13; echo
 NOP
-% curl -d ABC http://127.0.0.1:8888/api/rest/rot13; echo
+% curl -d NOP http://127.0.0.1:8888/api/rest/rot13; echo
 ABC
 ----
 
diff --git a/docs/man/libnng.3.adoc b/docs/man/libnng.3.adoc
index 712bf0f..eaeae24 100644
--- a/docs/man/libnng.3.adoc
+++ b/docs/man/libnng.3.adoc
@@ -1,6 +1,6 @@
 = libnng(3)
 //
-// Copyright 2020 Staysail Systems, Inc. <info@staysail.tech>
+// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
 // Copyright 2018 Capitar IT Group BV <info@capitar.com>
 // Copyright 2019 Devolutions <info@devolutions.net>
 // Copyright 2020 Dirac Research <robert.bielik@dirac.com>
@@ -164,6 +164,7 @@ The following functions are used in the asynchronous model:
 |xref:nng_aio_abort.3.adoc[nng_aio_abort()]|abort asynchronous I/O operation
 |xref:nng_aio_alloc.3.adoc[nng_aio_alloc()]|allocate asynchronous I/O handle
 |xref:nng_aio_begin.3.adoc[nng_aio_begin()]|begin asynchronous I/O operation
+|xref:nng_aio_busy.3.adoc[nng_aio_busy()]|test if asynchronous I/O is busy
 |xref:nng_aio_cancel.3.adoc[nng_aio_cancel()]|cancel asynchronous I/O operation
 |xref:nng_aio_count.3.adoc[nng_aio_count()]|return number of bytes transferred
 |xref:nng_aio_defer.3.adoc[nng_aio_defer()]|defer asynchronous I/O operation
@@ -231,7 +232,10 @@ concurrent applications.
 |xref:nng_ctx_id.3.adoc[nng_ctx_id()]|get numeric context identifier
 |xref:nng_ctx_open.3.adoc[nng_ctx_open()]|create context
 |xref:nng_ctx_recv.3.adoc[nng_ctx_recv()]|receive message using context asynchronously
+|xref:nng_ctx_recvmsg.3.adoc[nng_ctx_recvmsg()]|receive a message using context
 |xref:nng_ctx_send.3.adoc[nng_ctx_send()]|send message using context asynchronously
+|xref:nng_ctx_sendmsg.3.adoc[nng_ctx_sendmsg()]|send a message using context
+
 |xref:nng_ctx_set.3.adoc[nng_ctx_set()]|set context option
 |xref:nng_ctx_setopt.3.adoc[nng_ctx_setopt()]|set context option
 |===
diff --git a/docs/man/nng_aio_alloc.3.adoc b/docs/man/nng_aio_alloc.3.adoc
index 3a4a95e..6a424e3 100644
--- a/docs/man/nng_aio_alloc.3.adoc
+++ b/docs/man/nng_aio_alloc.3.adoc
@@ -1,6 +1,6 @@
 = nng_aio_alloc(3)
 //
-// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
+// Copyright 2022 Staysail Systems, Inc. <info@staysail.tech>
 // Copyright 2018 Capitar IT Group BV <info@capitar.com>
 //
 // This document is supplied under the terms of the MIT License, a
@@ -37,7 +37,7 @@ This also means you should avoid operations such as allocating new objects,
 which also means opening or closing sockets, dialers, and so forth.
 
 TIP: If more complex or blocking work needs to be performed by _callb_, a separate
-thread can be used, along with a xref:nng_cv_alloc.3.adoc[condition variable]
+thread can be used, along with a xref:nng_cv_alloc.3supp.adoc[condition variable]
 which can be signaled by the callback.
 
 Asynchronous I/O operations all take an xref:nng_aio.5.adoc[`nng_aio`]
diff --git a/docs/man/nng_aio_busy.3.adoc b/docs/man/nng_aio_busy.3.adoc
new file mode 100644
index 0000000..4aaf09b
--- /dev/null
+++ b/docs/man/nng_aio_busy.3.adoc
@@ -0,0 +1,56 @@
+= nng_aio_busy(3)
+//
+// Copyright 2022 Staysail Systems, Inc. <info@staysail.tech>
+//
+// This document is supplied under the terms of the MIT License, a
+// copy of which should be located in the distribution where this
+// file was obtained (LICENSE.txt).  A copy of the license may also be
+// found online at https://opensource.org/licenses/MIT.
+//
+
+== NAME
+
+nng_aio_busy - test if asynchronous I/O is busy
+
+== SYNOPSIS
+
+[source, c]
+----
+#include <nng/nng.h>
+
+bool nng_aio_busy(nng_aio *aio);
+----
+
+== DESCRIPTION
+
+The `nng_aio_busy()` function returns true if the
+_aio_ is currently busy performing an asynchronous I/O
+operation or is executing a completion callback.
+
+If no operation has been started, or the operation has
+been completed or canceled, and any callback has been
+executed, then it returns false.
+
+This is the same test used internally by
+xref:nng_aio_wait.3.adoc[`nng_aio_wait()`]
+
+NOTE: Care should be taken to ensure that the _aio_ object is not
+freed when using this function.  The caller is responsible for
+coordinating any use of this with any reuse of the _aio_.
+
+== RETURN VALUES
+
+True if the _aio_ is busy, false otherwise.
+
+== ERRORS
+
+None.
+
+== SEE ALSO
+
+[.text-left]
+xref:nng_aio_abort.3.adoc[nng_aio_abort(3)],
+xref:nng_aio_alloc.3.adoc[nng_aio_alloc(3)],
+xref:nng_aio_wait.3.adoc[nng_aio_wait(3)],
+xref:nng_aio.5.adoc[nng_aio(5)],
+xref:nng.7.adoc[nng(7)]
diff --git a/docs/man/nng_aio_wait.3.adoc b/docs/man/nng_aio_wait.3.adoc
index 5b65c79..18b735d 100644
--- a/docs/man/nng_aio_wait.3.adoc
+++ b/docs/man/nng_aio_wait.3.adoc
@@ -1,6 +1,6 @@
 = nng_aio_wait(3)
 //
-// Copyright 2018 Staysail Systems, Inc. <info@staysail.tech>
+// Copyright 2022 Staysail Systems, Inc. <info@staysail.tech>
 // Copyright 2018 Capitar IT Group BV <info@capitar.com>
 //
 // This document is supplied under the terms of the MIT License, a
@@ -29,7 +29,7 @@ to complete.
 If the operation has not been started, or has already
 completed, then it returns immediately.
 
-If the a callback was set with _aio_ when it was allocated, then this
+If a callback was set with _aio_ when it was allocated, then this
 function will not be called until the callback has completed.
 
 == RETURN VALUES
@@ -45,5 +45,6 @@ None.
 [.text-left]
 xref:nng_aio_abort.3.adoc[nng_aio_abort(3)],
 xref:nng_aio_alloc.3.adoc[nng_aio_alloc(3)],
+xref:nng_aio_busy.3.adoc[nng_aio_busy(3)],
 xref:nng_aio.5.adoc[nng_aio(5)],
 xref:nng.7.adoc[nng(7)]
diff --git a/docs/man/nng_ctx.5.adoc b/docs/man/nng_ctx.5.adoc
index cc859c4..c8ab62c 100644
--- a/docs/man/nng_ctx.5.adoc
+++ b/docs/man/nng_ctx.5.adoc
@@ -165,7 +165,9 @@ xref:nng_ctx_open.3.adoc[nng_ctx_open(3)],
 xref:nng_ctx_get.3.adoc[nng_ctx_get(3)],
 xref:nng_ctx_id.3.adoc[nng_ctx_id(3)],
 xref:nng_ctx_recv.3.adoc[nng_ctx_recv(3)],
+xref:nng_ctx_recvmsg.3.adoc[nng_ctx_recvmsg(3)],
 xref:nng_ctx_send.3.adoc[nng_ctx_send(3)],
+xref:nng_ctx_sendmsg.3.adoc[nng_ctx_sendmsg(3)],
 xref:nng_ctx_set.3.adoc[nng_ctx_set(3)],
 xref:nng_dialer.5.adoc[nng_dialer(5)],
 xref:nng_listener.5.adoc[nng_listener(5)],
diff --git a/docs/man/nng_ctx_recvmsg.3.adoc b/docs/man/nng_ctx_recvmsg.3.adoc
new file mode 100644
index 0000000..9651c34
--- /dev/null
+++ b/docs/man/nng_ctx_recvmsg.3.adoc
@@ -0,0 +1,63 @@
+= nng_ctx_recvmsg(3)
+//
+// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
+//
+// This document is supplied under the terms of the MIT License, a
+// copy of which should be located in the distribution where this
+// file was obtained (LICENSE.txt).  A copy of the license may also be
+// found online at https://opensource.org/licenses/MIT.
+//
+
+== NAME
+
+nng_ctx_recvmsg - receive message using socket
+
+== SYNOPSIS
+
+[source, c]
+----
+#include <nng/nng.h>
+
+int nng_ctx_recvmsg(nng_ctx ctx, nng_msg **msgp, int flags);
+----
+
+== DESCRIPTION
+
+The `nng_ctx_recvmsg()` receives a message on context _ctx_, storing the
+received message at the location pointed to by _msgp_.
+
+The _flags_ may contain the following value:
+
+`NNG_FLAG_NONBLOCK`::
+  The function returns immediately, even if no message is available.
+  Without this flag, the function will wait until a message is receivable
+  on the context _ctx_, or any configured timer expires.
+
+NOTE: The semantics of what receiving a message means vary from protocol to
+protocol, so examination of the protocol documentation is encouraged.
+
+== RETURN VALUES
+
+This function returns 0 on success, and non-zero otherwise.
+
+== ERRORS
+
+[horizontal]
+`NNG_EAGAIN`:: The operation would block, but `NNG_FLAG_NONBLOCK` was specified.
+`NNG_ECLOSED`:: The context or socket is not open.
+`NNG_EINVAL`:: An invalid set of _flags_ was specified.
+`NNG_ENOMEM`:: Insufficient memory is available.
+`NNG_ENOTSUP`:: The protocol does not support receiving.
+`NNG_ESTATE`:: The context cannot receive data in this state.
+`NNG_ETIMEDOUT`:: The operation timed out.
+
+== SEE ALSO
+
+[.text-left]
+xref:nng_msg_free.3.adoc[nng_msg_free(3)],
+xref:nng_ctx_open.3.adoc[nng_ctx_open(3)],
+xref:nng_ctx_recv.3.adoc[nng_ctx_recv(3)],
+xref:nng_ctx_sendmsg.3.adoc[nng_ctx_sendmsg(3)],
+xref:nng_strerror.3.adoc[nng_strerror(3)],
+xref:nng_ctx.5.adoc[nng_ctx(5)],
+xref:nng.7.adoc[nng(7)]
diff --git a/docs/man/nng_ctx_sendmsg.3.adoc b/docs/man/nng_ctx_sendmsg.3.adoc
new file mode 100644
index 0000000..8e2c97f
--- /dev/null
+++ b/docs/man/nng_ctx_sendmsg.3.adoc
@@ -0,0 +1,84 @@
+= nng_ctx_sendmsg(3)
+//
+// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
+//
+// This document is supplied under the terms of the MIT License, a
+// copy of which should be located in the distribution where this
+// file was obtained (LICENSE.txt).  A copy of the license may also be
+// found online at https://opensource.org/licenses/MIT.
+//
+
+== NAME
+
+nng_ctx_sendmsg - send message using context
+
+== SYNOPSIS
+
+[source, c]
+----
+#include <nng/nng.h>
+
+int nng_ctx_sendmsg(nng_ctx c, nng_msg *msg, int flags);
+----
+
+== DESCRIPTION
+
+The `nng_ctx_sendmsg()` sends message _msg_ using the context _ctx_.
+
+If the function returns zero, indicating it has accepted the message for
+delivery, then the _msg_ is owned by the socket _s_, and the caller
+must not make any further use of it.
+The socket will free the message when it is finished.
+
+If the function returns non-zero, then it is the caller's responsibility
+to dispose of the _msg_, which may include freeing it, sending it to
+another socket, or simply trying again later.
+
+NOTE: The semantics of what sending a message means vary from protocol to
+protocol, so examination of the protocol documentation is encouraged.
+
+The _flags_ may contain the following value:
+
+`NNG_FLAG_NONBLOCK`::
+    The function returns immediately, regardless of whether
+    the context is able to accept the data or not.
+    If the context is unable to accept the data (such as if backpressure exists
+    because the peers are consuming messages too slowly, or no peer is present),
+    then the function will return with `NNG_EAGAIN`.
+    If this flag is not specified, then the function will block if such a
+    condition exists.
+
+
+NOTE: Regardless of the presence or absence of `NNG_FLAG_NONBLOCK`, there may
+be queues between the sender and the receiver.
+Furthermore, there is no guarantee that the message has actually been delivered.
+Finally, with some protocols, the semantic is implicitly `NNG_FLAG_NONBLOCK`.
+
+== RETURN VALUES
+
+This function returns 0 on success, and non-zero otherwise.
+
+== ERRORS
+
+[horizontal]
+`NNG_EAGAIN`:: The operation would block, but `NNG_FLAG_NONBLOCK` was specified.
+`NNG_ECLOSED`:: The context or socket is not open.
+`NNG_EINVAL`:: An invalid set of _flags_ was specified.
+`NNG_EMSGSIZE`:: The value of _size_ is too large.
+`NNG_ENOMEM`:: Insufficient memory is available.
+`NNG_ENOTSUP`:: The protocol does not support sending.
+`NNG_ESTATE`:: The context cannot send data in this state.
+`NNG_ETIMEDOUT`:: The operation timed out.
+
+== SEE ALSO
+
+[.text-left]
+xref:nng_msg_alloc.3.adoc[nng_msg_alloc(3)],
+xref:nng_ctx_open.3.adoc[nng_ctx_open(3)],
+xref:nng_ctx_recvmsg.3.adoc[nng_ctx_recvmsg(3)],
+xref:nng_ctx_send.3.adoc[nng_ctx_send(3)],
+xref:nng_sendmsg.3.adoc[nng_sendmsg(3)],
+xref:nng_strerror.3.adoc[nng_strerror(3)],
+xref:nng_msg.5.adoc[nng_msg(5)],
+xref:nng_ctx.5.adoc[nng_ctx(5)],
+xref:nng.7.adoc[nng(7)]
diff --git a/docs/man/nng_device.3.adoc b/docs/man/nng_device.3.adoc
index b36d2e8..7151239 100644
--- a/docs/man/nng_device.3.adoc
+++ b/docs/man/nng_device.3.adoc
@@ -1,6 +1,6 @@
 = nng_device(3)
 //
-// Copyright 2018 Staysail Systems, Inc. <info@staysail.tech>
+// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
 // Copyright 2018 Capitar IT Group BV <info@capitar.com>
 //
 // This document is supplied under the terms of the MIT License, a
@@ -20,14 +20,16 @@ nng_device - message forwarding device
 #include <nng/nng.h>
 
 int nng_device(nng_socket s1, nng_socket s2);
+
+void nng_device_aio(nng_aio *aio, nng_socket s1, nng_socket s2);
 ----
 
 == DESCRIPTION
 
-The `nng_device()` function forwards messages received from one
+The `nng_device()` and `nng_device_aio()` functions forward messages received from one
 xref:nng_socket.5.adoc[socket] _s1_ to another socket _s2_, and vice versa.
 
-This function is used to create forwarders, which can be used to create
+These functions are used to create forwarders, which can be used to create
 complex network topologies to provide for improved ((horizontal scalability)),
 reliability, and isolation.
 
@@ -38,6 +40,8 @@ such as xref:nng_req_open.3.adoc[`nng_req0_open_raw()`].
 
 The `nng_device()` function does not return until one of the sockets
 is closed.
+The `nng_device_aio()` function returns immediately, and operates completely in
+the background.
 
 === Reflectors
 
@@ -49,7 +53,7 @@ xref:nng_pair.7.adoc[_pair_] or
 xref:nng_bus.7.adoc[_bus_].)
 In this case the device acts as a ((reflector)) or loop-back device,
 where messages received from the valid socket are merely returned
-back to the sender.
+to the sender.
 
 === Forwarders
 
@@ -75,6 +79,9 @@ adjustments to add or remove routing headers as needed.
 This allows replies to be
 returned to requesters, and responses to be routed back to surveyors.
 
+The caller of these functions is required to close the sockets when the
+device is stopped.
+
 Additionally, some protocols have a maximum ((time-to-live)) to protect
 against forwarding loops and especially amplification loops.
 In these cases, the default limit (usually 8), ensures that messages will
@@ -88,7 +95,7 @@ IMPORTANT: Not all protocols have support for guarding against forwarding loops,
 and even for those that do, forwarding loops can be extremely detrimental
 to network performance.
 
-NOTE: Devices (forwarders and reflectors) act in best effort delivery mode only.
+NOTE: Devices (forwarders and reflectors) act in best-effort delivery mode only.
 If a message is received from one socket that cannot be accepted by the
 other (due to backpressure or other issues), then the message is discarded.
 
diff --git a/docs/man/nng_options.5.adoc b/docs/man/nng_options.5.adoc
index 1ad61c4..e4e5124 100644
--- a/docs/man/nng_options.5.adoc
+++ b/docs/man/nng_options.5.adoc
@@ -282,7 +282,7 @@ return value of `NNG_ETIMEDOUT`.
 (((name, socket)))
 (string)
 This the socket name.
-By default this is a string corresponding to the value of the socket.
+By default, this is a string corresponding to the value of the socket.
 The string must fit within 64-bytes, including the terminating
 `NUL` byte.
 The value is intended for application use, and is not used for anything
diff --git a/docs/man/nng_recvmsg.3.adoc b/docs/man/nng_recvmsg.3.adoc
index 6f1fcea..c502d65 100644
--- a/docs/man/nng_recvmsg.3.adoc
+++ b/docs/man/nng_recvmsg.3.adoc
@@ -1,6 +1,6 @@
 = nng_recvmsg(3)
 //
-// Copyright 2018 Staysail Systems, Inc. <info@staysail.tech>
+// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
 // Copyright 2018 Capitar IT Group BV <info@capitar.com>
 //
 // This document is supplied under the terms of the MIT License, a
@@ -11,7 +11,7 @@
 
 == NAME
 
-nng_recvmsg - recv message
+nng_recvmsg - receive a message
 
 == SYNOPSIS
 
@@ -67,4 +67,5 @@ xref:nng_msg_free.3.adoc[nng_msg_free(3)],
 xref:nng_recv.3.adoc[nng_recv(3)],
 xref:nng_sendmsg.3.adoc[nng_sendmsg(3)],
 xref:nng_strerror.3.adoc[nng_strerror(3)],
+xref:nng_socket.5.adoc[nng_socket(5)],
 xref:nng.7.adoc[nng(7)]
diff --git a/etc/codecov.sh b/etc/codecov.sh
index 5ecdc55..7bddcd5 100755
--- a/etc/codecov.sh
+++ b/etc/codecov.sh
@@ -1,4 +1,4 @@
-#!/bin/bash
+#!/usr/bin/env bash
 
 # Copyright 2017 Garrett D'Amore <garrett@damore.org>
 # Copyright 2017 Capitar IT Group BV <info@capitar.com>
diff --git a/etc/coverage.sh b/etc/coverage.sh
index 6f7355d..73e7109 100755
--- a/etc/coverage.sh
+++ b/etc/coverage.sh
@@ -1,4 +1,4 @@
-#!/bin/bash
+#!/usr/bin/env bash
 
 # Copyright 2017 Garrett D'Amore <garrett@damore.org>
 # Copyright 2017 Capitar IT Group BV <info@capitar.com>
diff --git a/etc/format-check.sh b/etc/format-check.sh
index 68b3d8e..aca847c 100755
--- a/etc/format-check.sh
+++ b/etc/format-check.sh
@@ -1,4 +1,4 @@
-#!/bin/sh
+#!/usr/bin/env bash
 #
 # Copyright 2016 Garrett D'Amore <garrett@damore.org>
 #
diff --git a/include/nng/nng.h b/include/nng/nng.h
index cd75495..811cb45 100644
--- a/include/nng/nng.h
+++ b/include/nng/nng.h
@@ -45,13 +45,21 @@ extern "C" {
 #endif // _WIN32 && !NNG_STATIC_LIB
 #endif // NNG_DECL
 
+#ifndef NNG_DEPRECATED
+#if defined(__GNUC__) || defined(__clang__)
+#define NNG_DEPRECATED __attribute__ ((deprecated))
+#else
+#define NNG_DEPRECATED
+#endif
+#endif
+
 // NNG Library & API version.
 // We use SemVer, and these versions are about the API, and
 // may not necessarily match the ABI versions.
 #define NNG_MAJOR_VERSION 1
-#define NNG_MINOR_VERSION 5
-#define NNG_PATCH_VERSION 2
-#define NNG_RELEASE_SUFFIX "" // if non-empty, this is a pre-release
+#define NNG_MINOR_VERSION 6
+#define NNG_PATCH_VERSION 0
+#define NNG_RELEASE_SUFFIX "pre" // if non-empty, this is a pre-release
 
 // Maximum length of a socket address. This includes the terminating NUL.
 // This limit is built into other implementations, so do not change it.
@@ -421,10 +429,20 @@ NNG_DECL int nng_ctx_id(nng_ctx);
 // uses a local context instead of the socket global context.
 NNG_DECL void nng_ctx_recv(nng_ctx, nng_aio *);
 
+// nng_ctx_recvmsg is allows for receiving a message synchronously using
+// a context.  It has the same semantics as nng_recvmsg, but operates
+// on a context instead of a socket.
+NNG_DECL int nng_ctx_recvmsg(nng_ctx, nng_msg **, int);
+
 // nng_ctx_send sends asynchronously. It works like nng_send_aio, but
 // uses a local context instead of the socket global context.
 NNG_DECL void nng_ctx_send(nng_ctx, nng_aio *);
 
+// nng_ctx_sendmsg is allows for sending a message synchronously using
+// a context.  It has the same semantics as nng_sendmsg, but operates
+// on a context instead of a socket.
+NNG_DECL int nng_ctx_sendmsg(nng_ctx, nng_msg *, int);
+
 NNG_DECL int nng_ctx_get(nng_ctx, const char *, void *, size_t *);
 NNG_DECL int nng_ctx_get_bool(nng_ctx, const char *, bool *);
 NNG_DECL int nng_ctx_get_int(nng_ctx, const char *, int *);
@@ -526,6 +544,12 @@ NNG_DECL void nng_aio_abort(nng_aio *, int);
 // callback or deadlock may occur.
 NNG_DECL void nng_aio_wait(nng_aio *);
 
+// nng_aio_busy returns true if the aio is still busy processing the
+// operation, or executing associated completion functions.  Note that
+// if the completion function schedules a new operation using the aio,
+// then this function will continue to return true.
+NNG_DECL bool nng_aio_busy(nng_aio *);
+
 // nng_aio_set_msg sets the message structure to use for asynchronous
 // message send operations.
 NNG_DECL void nng_aio_set_msg(nng_aio *, nng_msg *);
@@ -963,8 +987,18 @@ NNG_DECL uint64_t nng_stat_timestamp(nng_stat *);
 
 // Device functionality.  This connects two sockets together in a device,
 // which means that messages from one side are forwarded to the other.
+// This version is synchronous, which means the caller will block until
+// one of the sockets is closed. Note that caller is responsible for
+// finally closing both sockets when this function returns.
 NNG_DECL int nng_device(nng_socket, nng_socket);
 
+// Asynchronous form of nng_device.  When this succeeds, the device is
+// left intact and functioning in the background, until one of the sockets
+// is closed or the application exits.  The sockets may be shut down if
+// the device fails, but the caller is responsible for ultimately closing
+// the sockets properly after the device is torn down.
+NNG_DECL void nng_device_aio(nng_aio *, nng_socket, nng_socket);
+
 // Symbol name and visibility.  TBD.  The only symbols that really should
 // be directly exported to runtimes IMO are the option symbols.  And frankly
 // they have enough special logic around them that it might be best not to
@@ -1186,96 +1220,96 @@ NNG_DECL int nng_stream_listener_set_addr(
 
 // nng_msg_getopt is defunct, and should not be used by programs. It
 // always returns NNG_ENOTSUP.
-NNG_DECL int nng_msg_getopt(nng_msg *, int, void *, size_t *);
-
-// Socket options.  Use nng_socket_get and nng_socket_set isnetadl
-NNG_DECL int nng_getopt(nng_socket, const char *, void *, size_t *);
-NNG_DECL int nng_getopt_bool(nng_socket, const char *, bool *);
-NNG_DECL int nng_getopt_int(nng_socket, const char *, int *);
-NNG_DECL int nng_getopt_ms(nng_socket, const char *, nng_duration *);
-NNG_DECL int nng_getopt_size(nng_socket, const char *, size_t *);
-NNG_DECL int nng_getopt_uint64(nng_socket, const char *, uint64_t *);
-NNG_DECL int nng_getopt_ptr(nng_socket, const char *, void **);
-NNG_DECL int nng_getopt_string(nng_socket, const char *, char **);
-NNG_DECL int nng_setopt(nng_socket, const char *, const void *, size_t);
-NNG_DECL int nng_setopt_bool(nng_socket, const char *, bool);
-NNG_DECL int nng_setopt_int(nng_socket, const char *, int);
-NNG_DECL int nng_setopt_ms(nng_socket, const char *, nng_duration);
-NNG_DECL int nng_setopt_size(nng_socket, const char *, size_t);
-NNG_DECL int nng_setopt_uint64(nng_socket, const char *, uint64_t);
-NNG_DECL int nng_setopt_string(nng_socket, const char *, const char *);
-NNG_DECL int nng_setopt_ptr(nng_socket, const char *, void *);
+NNG_DECL int nng_msg_getopt(nng_msg *, int, void *, size_t *) NNG_DEPRECATED;
+
+// Socket options.  Use nng_socket_get and nng_socket_set instead.
+NNG_DECL int nng_getopt(nng_socket, const char *, void *, size_t *) NNG_DEPRECATED;
+NNG_DECL int nng_getopt_bool(nng_socket, const char *, bool *) NNG_DEPRECATED;
+NNG_DECL int nng_getopt_int(nng_socket, const char *, int *) NNG_DEPRECATED;
+NNG_DECL int nng_getopt_ms(nng_socket, const char *, nng_duration *) NNG_DEPRECATED;
+NNG_DECL int nng_getopt_size(nng_socket, const char *, size_t *) NNG_DEPRECATED;
+NNG_DECL int nng_getopt_uint64(nng_socket, const char *, uint64_t *) NNG_DEPRECATED;
+NNG_DECL int nng_getopt_ptr(nng_socket, const char *, void **) NNG_DEPRECATED;
+NNG_DECL int nng_getopt_string(nng_socket, const char *, char **) NNG_DEPRECATED;
+NNG_DECL int nng_setopt(nng_socket, const char *, const void *, size_t) NNG_DEPRECATED;
+NNG_DECL int nng_setopt_bool(nng_socket, const char *, bool) NNG_DEPRECATED;
+NNG_DECL int nng_setopt_int(nng_socket, const char *, int) NNG_DEPRECATED;
+NNG_DECL int nng_setopt_ms(nng_socket, const char *, nng_duration) NNG_DEPRECATED;
+NNG_DECL int nng_setopt_size(nng_socket, const char *, size_t) NNG_DEPRECATED;
+NNG_DECL int nng_setopt_uint64(nng_socket, const char *, uint64_t) NNG_DEPRECATED;
+NNG_DECL int nng_setopt_string(nng_socket, const char *, const char *) NNG_DEPRECATED;
+NNG_DECL int nng_setopt_ptr(nng_socket, const char *, void *) NNG_DEPRECATED;
 
 // Context options.  Use nng_ctx_get and nng_ctx_set instead.
-NNG_DECL int nng_ctx_getopt(nng_ctx, const char *, void *, size_t *);
-NNG_DECL int nng_ctx_getopt_bool(nng_ctx, const char *, bool *);
-NNG_DECL int nng_ctx_getopt_int(nng_ctx, const char *, int *);
-NNG_DECL int nng_ctx_getopt_ms(nng_ctx, const char *, nng_duration *);
-NNG_DECL int nng_ctx_getopt_size(nng_ctx, const char *, size_t *);
-NNG_DECL int nng_ctx_setopt(nng_ctx, const char *, const void *, size_t);
-NNG_DECL int nng_ctx_setopt_bool(nng_ctx, const char *, bool);
-NNG_DECL int nng_ctx_setopt_int(nng_ctx, const char *, int);
-NNG_DECL int nng_ctx_setopt_ms(nng_ctx, const char *, nng_duration);
-NNG_DECL int nng_ctx_setopt_size(nng_ctx, const char *, size_t);
+NNG_DECL int nng_ctx_getopt(nng_ctx, const char *, void *, size_t *) NNG_DEPRECATED;
+NNG_DECL int nng_ctx_getopt_bool(nng_ctx, const char *, bool *) NNG_DEPRECATED;
+NNG_DECL int nng_ctx_getopt_int(nng_ctx, const char *, int *) NNG_DEPRECATED;
+NNG_DECL int nng_ctx_getopt_ms(nng_ctx, const char *, nng_duration *) NNG_DEPRECATED;
+NNG_DECL int nng_ctx_getopt_size(nng_ctx, const char *, size_t *) NNG_DEPRECATED;
+NNG_DECL int nng_ctx_setopt(nng_ctx, const char *, const void *, size_t) NNG_DEPRECATED;
+NNG_DECL int nng_ctx_setopt_bool(nng_ctx, const char *, bool) NNG_DEPRECATED;
+NNG_DECL int nng_ctx_setopt_int(nng_ctx, const char *, int) NNG_DEPRECATED;
+NNG_DECL int nng_ctx_setopt_ms(nng_ctx, const char *, nng_duration) NNG_DEPRECATED;
+NNG_DECL int nng_ctx_setopt_size(nng_ctx, const char *, size_t) NNG_DEPRECATED;
 
 // Dialer options.  Use nng_dialer_get and nng_dialer_set instead.
-NNG_DECL int nng_dialer_getopt(nng_dialer, const char *, void *, size_t *);
-NNG_DECL int nng_dialer_getopt_bool(nng_dialer, const char *, bool *);
-NNG_DECL int nng_dialer_getopt_int(nng_dialer, const char *, int *);
-NNG_DECL int nng_dialer_getopt_ms(nng_dialer, const char *, nng_duration *);
-NNG_DECL int nng_dialer_getopt_size(nng_dialer, const char *, size_t *);
+NNG_DECL int nng_dialer_getopt(nng_dialer, const char *, void *, size_t *) NNG_DEPRECATED;
+NNG_DECL int nng_dialer_getopt_bool(nng_dialer, const char *, bool *) NNG_DEPRECATED;
+NNG_DECL int nng_dialer_getopt_int(nng_dialer, const char *, int *) NNG_DEPRECATED;
+NNG_DECL int nng_dialer_getopt_ms(nng_dialer, const char *, nng_duration *) NNG_DEPRECATED;
+NNG_DECL int nng_dialer_getopt_size(nng_dialer, const char *, size_t *) NNG_DEPRECATED;
 NNG_DECL int nng_dialer_getopt_sockaddr(
-    nng_dialer, const char *, nng_sockaddr *);
-NNG_DECL int nng_dialer_getopt_uint64(nng_dialer, const char *, uint64_t *);
-NNG_DECL int nng_dialer_getopt_ptr(nng_dialer, const char *, void **);
-NNG_DECL int nng_dialer_getopt_string(nng_dialer, const char *, char **);
-NNG_DECL int nng_dialer_setopt(nng_dialer, const char *, const void *, size_t);
-NNG_DECL int nng_dialer_setopt_bool(nng_dialer, const char *, bool);
-NNG_DECL int nng_dialer_setopt_int(nng_dialer, const char *, int);
-NNG_DECL int nng_dialer_setopt_ms(nng_dialer, const char *, nng_duration);
-NNG_DECL int nng_dialer_setopt_size(nng_dialer, const char *, size_t);
-NNG_DECL int nng_dialer_setopt_uint64(nng_dialer, const char *, uint64_t);
-NNG_DECL int nng_dialer_setopt_ptr(nng_dialer, const char *, void *);
-NNG_DECL int nng_dialer_setopt_string(nng_dialer, const char *, const char *);
+    nng_dialer, const char *, nng_sockaddr *) NNG_DEPRECATED;
+NNG_DECL int nng_dialer_getopt_uint64(nng_dialer, const char *, uint64_t *) NNG_DEPRECATED;
+NNG_DECL int nng_dialer_getopt_ptr(nng_dialer, const char *, void **) NNG_DEPRECATED;
+NNG_DECL int nng_dialer_getopt_string(nng_dialer, const char *, char **) NNG_DEPRECATED;
+NNG_DECL int nng_dialer_setopt(nng_dialer, const char *, const void *, size_t) NNG_DEPRECATED;
+NNG_DECL int nng_dialer_setopt_bool(nng_dialer, const char *, bool) NNG_DEPRECATED;
+NNG_DECL int nng_dialer_setopt_int(nng_dialer, const char *, int) NNG_DEPRECATED;
+NNG_DECL int nng_dialer_setopt_ms(nng_dialer, const char *, nng_duration) NNG_DEPRECATED;
+NNG_DECL int nng_dialer_setopt_size(nng_dialer, const char *, size_t) NNG_DEPRECATED;
+NNG_DECL int nng_dialer_setopt_uint64(nng_dialer, const char *, uint64_t) NNG_DEPRECATED;
+NNG_DECL int nng_dialer_setopt_ptr(nng_dialer, const char *, void *) NNG_DEPRECATED;
+NNG_DECL int nng_dialer_setopt_string(nng_dialer, const char *, const char *) NNG_DEPRECATED;
 
 // Listener options.  Use nng_listener_get and nng_listener_set instead.
-NNG_DECL int nng_listener_getopt(nng_listener, const char *, void *, size_t *);
-NNG_DECL int nng_listener_getopt_bool(nng_listener, const char *, bool *);
-NNG_DECL int nng_listener_getopt_int(nng_listener, const char *, int *);
+NNG_DECL int nng_listener_getopt(nng_listener, const char *, void *, size_t *) NNG_DEPRECATED;
+NNG_DECL int nng_listener_getopt_bool(nng_listener, const char *, bool *) NNG_DEPRECATED;
+NNG_DECL int nng_listener_getopt_int(nng_listener, const char *, int *) NNG_DEPRECATED;
 NNG_DECL int nng_listener_getopt_ms(
-    nng_listener, const char *, nng_duration *);
-NNG_DECL int nng_listener_getopt_size(nng_listener, const char *, size_t *);
+    nng_listener, const char *, nng_duration *) NNG_DEPRECATED;
+NNG_DECL int nng_listener_getopt_size(nng_listener, const char *, size_t *) NNG_DEPRECATED;
 NNG_DECL int nng_listener_getopt_sockaddr(
-    nng_listener, const char *, nng_sockaddr *);
+    nng_listener, const char *, nng_sockaddr *) NNG_DEPRECATED;
 NNG_DECL int nng_listener_getopt_uint64(
-    nng_listener, const char *, uint64_t *);
-NNG_DECL int nng_listener_getopt_ptr(nng_listener, const char *, void **);
-NNG_DECL int nng_listener_getopt_string(nng_listener, const char *, char **);
+    nng_listener, const char *, uint64_t *) NNG_DEPRECATED;
+NNG_DECL int nng_listener_getopt_ptr(nng_listener, const char *, void **) NNG_DEPRECATED;
+NNG_DECL int nng_listener_getopt_string(nng_listener, const char *, char **) NNG_DEPRECATED;
 NNG_DECL int nng_listener_setopt(
-    nng_listener, const char *, const void *, size_t);
-NNG_DECL int nng_listener_setopt_bool(nng_listener, const char *, bool);
-NNG_DECL int nng_listener_setopt_int(nng_listener, const char *, int);
-NNG_DECL int nng_listener_setopt_ms(nng_listener, const char *, nng_duration);
-NNG_DECL int nng_listener_setopt_size(nng_listener, const char *, size_t);
-NNG_DECL int nng_listener_setopt_uint64(nng_listener, const char *, uint64_t);
-NNG_DECL int nng_listener_setopt_ptr(nng_listener, const char *, void *);
+    nng_listener, const char *, const void *, size_t) NNG_DEPRECATED;
+NNG_DECL int nng_listener_setopt_bool(nng_listener, const char *, bool) NNG_DEPRECATED;
+NNG_DECL int nng_listener_setopt_int(nng_listener, const char *, int) NNG_DEPRECATED;
+NNG_DECL int nng_listener_setopt_ms(nng_listener, const char *, nng_duration) NNG_DEPRECATED;
+NNG_DECL int nng_listener_setopt_size(nng_listener, const char *, size_t) NNG_DEPRECATED;
+NNG_DECL int nng_listener_setopt_uint64(nng_listener, const char *, uint64_t) NNG_DEPRECATED;
+NNG_DECL int nng_listener_setopt_ptr(nng_listener, const char *, void *) NNG_DEPRECATED;
 NNG_DECL int nng_listener_setopt_string(
-    nng_listener, const char *, const char *);
+    nng_listener, const char *, const char *) NNG_DEPRECATED;
 
 // Pipe options.  Use nng_pipe_get instead.
-NNG_DECL int nng_pipe_getopt(nng_pipe, const char *, void *, size_t *);
-NNG_DECL int nng_pipe_getopt_bool(nng_pipe, const char *, bool *);
-NNG_DECL int nng_pipe_getopt_int(nng_pipe, const char *, int *);
-NNG_DECL int nng_pipe_getopt_ms(nng_pipe, const char *, nng_duration *);
-NNG_DECL int nng_pipe_getopt_size(nng_pipe, const char *, size_t *);
-NNG_DECL int nng_pipe_getopt_sockaddr(nng_pipe, const char *, nng_sockaddr *);
-NNG_DECL int nng_pipe_getopt_uint64(nng_pipe, const char *, uint64_t *);
-NNG_DECL int nng_pipe_getopt_ptr(nng_pipe, const char *, void **);
-NNG_DECL int nng_pipe_getopt_string(nng_pipe, const char *, char **);
+NNG_DECL int nng_pipe_getopt(nng_pipe, const char *, void *, size_t *) NNG_DEPRECATED;
+NNG_DECL int nng_pipe_getopt_bool(nng_pipe, const char *, bool *) NNG_DEPRECATED;
+NNG_DECL int nng_pipe_getopt_int(nng_pipe, const char *, int *) NNG_DEPRECATED;
+NNG_DECL int nng_pipe_getopt_ms(nng_pipe, const char *, nng_duration *) NNG_DEPRECATED;
+NNG_DECL int nng_pipe_getopt_size(nng_pipe, const char *, size_t *) NNG_DEPRECATED;
+NNG_DECL int nng_pipe_getopt_sockaddr(nng_pipe, const char *, nng_sockaddr *) NNG_DEPRECATED;
+NNG_DECL int nng_pipe_getopt_uint64(nng_pipe, const char *, uint64_t *) NNG_DEPRECATED;
+NNG_DECL int nng_pipe_getopt_ptr(nng_pipe, const char *, void **) NNG_DEPRECATED;
+NNG_DECL int nng_pipe_getopt_string(nng_pipe, const char *, char **) NNG_DEPRECATED;
 
 // nng_closeall closes all open sockets. Do not call this from
 // a library; it will affect all sockets.
-NNG_DECL void nng_closeall(void);
+NNG_DECL void nng_closeall(void) NNG_DEPRECATED;
 
 #endif
 
diff --git a/include/nng/protocol/bus0/bus.h b/include/nng/protocol/bus0/bus.h
index c8c23d8..31167d7 100644
--- a/include/nng/protocol/bus0/bus.h
+++ b/include/nng/protocol/bus0/bus.h
@@ -1,5 +1,5 @@
 //
-// Copyright 2018 Staysail Systems, Inc. <info@staysail.tech>
+// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
 // Copyright 2018 Capitar IT Group BV <info@capitar.com>
 //
 // This software is supplied under the terms of the MIT License, a
@@ -27,6 +27,11 @@ NNG_DECL int nng_bus0_open_raw(nng_socket *);
 #define nng_bus_open_raw nng_bus0_open_raw
 #endif
 
+#define NNG_BUS0_SELF 0x70
+#define NNG_BUS0_PEER 0x70
+#define NNG_BUS0_SELF_NAME "bus"
+#define NNG_BUS0_PEER_NAME "bus"
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/src/core/CMakeLists.txt b/src/core/CMakeLists.txt
index b55bd70..eb511a8 100644
--- a/src/core/CMakeLists.txt
+++ b/src/core/CMakeLists.txt
@@ -50,7 +50,6 @@ nng_sources(
         pipe.c
         pipe.h
         platform.h
-        protocol.c
         protocol.h
         reap.c
         reap.h
@@ -83,4 +82,5 @@ nng_test(list_test)
 nng_test(message_test)
 nng_test(reconnect_test)
 nng_test(sock_test)
+nng_test(stats_test)
 nng_test(url_test)
diff --git a/src/core/aio.c b/src/core/aio.c
index dfab8f6..771cbc9 100644
--- a/src/core/aio.c
+++ b/src/core/aio.c
@@ -1,5 +1,5 @@
 //
-// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
+// Copyright 2022 Staysail Systems, Inc. <info@staysail.tech>
 // Copyright 2018 Capitar IT Group BV <info@capitar.com>
 //
 // This software is supplied under the terms of the MIT License, a
@@ -15,7 +15,6 @@ struct nni_aio_expire_q {
 	nni_mtx  eq_mtx;
 	nni_cv   eq_cv;
 	nni_list eq_list;
-	uint32_t eq_len;
 	nni_thr  eq_thr;
 	nni_time eq_next; // next expiration
 	bool     eq_exit;
@@ -38,8 +37,8 @@ static int                nni_aio_expire_q_cnt;
 // free to examine the aio for list membership, etc.  The provider must
 // not call finish more than once though.
 //
-// We use an array of expiration queues, each with it's own lock and
-// condition variable, and expiration thread.  By default this is one
+// We use an array of expiration queues, each with its own lock and
+// condition variable, and expiration thread.  By default, this is one
 // per CPU core present -- the goal being to reduce overall pressure
 // caused by a single lock.  The number of queues (and threads) can
 // be tuned using the NNG_EXPIRE_THREADS tunable.
@@ -89,8 +88,8 @@ static int                nni_aio_expire_q_cnt;
 #define aio_safe_lock(l) nni_mtx_lock(l)
 #define aio_safe_unlock(l) nni_mtx_unlock(l)
 #else
-#define aio_safe_lock(l)
-#define aio_safe_unlock(l)
+#define aio_safe_lock(l) ((void) 1)
+#define aio_safe_unlock(l) ((void) 1)
 #endif
 
 static nni_reap_list aio_reap_list = {
@@ -315,6 +314,12 @@ nni_aio_wait(nni_aio *aio)
 	nni_task_wait(&aio->a_task);
 }
 
+bool
+nni_aio_busy(nni_aio *aio)
+{
+	return (nni_task_busy(&aio->a_task));
+}
+
 int
 nni_aio_begin(nni_aio *aio)
 {
@@ -331,7 +336,7 @@ nni_aio_begin(nni_aio *aio)
 	NNI_ASSERT(aio->a_cancel_fn == NULL);
 	NNI_ASSERT(!nni_list_node_active(&aio->a_expire_node));
 
-	// Some initialization can be done outside of the lock, because
+	// Some initialization can be done outside the lock, because
 	// we must have exclusive access to the aio.
 	for (unsigned i = 0; i < NNI_NUM_ELEMENTS(aio->a_outputs); i++) {
 		aio->a_outputs[i] = NULL;
@@ -546,8 +551,8 @@ nni_aio_expire_loop(void *arg)
 		int      rv;
 		nni_time next;
 
-		next       = q->eq_next;
-		now        = nni_clock();
+		next = q->eq_next;
+		now  = nni_clock();
 
 		// Each time we wake up, we scan the entire list of elements.
 		// We scan forward, moving up to NNI_EXPIRE_Q_SIZE elements
@@ -566,7 +571,7 @@ nni_aio_expire_loop(void *arg)
 			continue;
 		}
 		q->eq_next = NNI_TIME_NEVER;
-		exp_idx = 0;
+		exp_idx    = 0;
 		while (aio != NULL) {
 			if ((aio->a_expire < now) &&
 			    (exp_idx < NNI_EXPIRE_BATCH)) {
@@ -591,7 +596,7 @@ nni_aio_expire_loop(void *arg)
 
 		for (uint32_t i = 0; i < exp_idx; i++) {
 			aio = expires[i];
-			rv = aio->a_expire_ok ? 0 : NNG_ETIMEDOUT;
+			rv  = aio->a_expire_ok ? 0 : NNG_ETIMEDOUT;
 
 			nni_aio_cancel_fn cancel_fn  = aio->a_cancel_fn;
 			void             *cancel_arg = aio->a_cancel_arg;
@@ -619,15 +624,15 @@ nni_aio_expire_loop(void *arg)
 }
 
 void *
-nni_aio_get_prov_extra(nni_aio *aio, unsigned index)
+nni_aio_get_prov_data(nni_aio *aio)
 {
-	return (aio->a_prov_extra[index]);
+	return (aio->a_prov_data);
 }
 
 void
-nni_aio_set_prov_extra(nni_aio *aio, unsigned index, void *data)
+nni_aio_set_prov_data(nni_aio *aio, void *data)
 {
-	aio->a_prov_extra[index] = data;
+	aio->a_prov_data = data;
 }
 
 void
diff --git a/src/core/aio.h b/src/core/aio.h
index 9ef5f63..6315e90 100644
--- a/src/core/aio.h
+++ b/src/core/aio.h
@@ -1,5 +1,5 @@
 //
-// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
+// Copyright 2022 Staysail Systems, Inc. <info@staysail.tech>
 // Copyright 2018 Capitar IT Group BV <info@capitar.com>
 //
 // This software is supplied under the terms of the MIT License, a
@@ -93,6 +93,10 @@ extern int nni_aio_result(nni_aio *);
 // completed.
 extern size_t nni_aio_count(nni_aio *);
 
+// nni_aio_busy returns true if the aio is still busy processing work.
+// This is a non-blocking form of the check used by nni_aio_wait().
+extern bool nni_aio_busy(nni_aio *);
+
 // nni_aio_wait blocks the caller until the operation is complete.
 // The operation must have already been started.  This routine will
 // block until the AIO, as well as any callback, has completed execution.
@@ -133,8 +137,8 @@ extern void nni_aio_abort(nni_aio *, int rv);
 // nng_aio_finish family of functions.)
 extern int nni_aio_begin(nni_aio *);
 
-extern void *nni_aio_get_prov_extra(nni_aio *, unsigned);
-extern void  nni_aio_set_prov_extra(nni_aio *, unsigned, void *);
+extern void *nni_aio_get_prov_data(nni_aio *);
+extern void  nni_aio_set_prov_data(nni_aio *, void *);
 // nni_aio_advance_iov moves up the iov, reflecting that some I/O as
 // been performed.  It returns the amount of data remaining in the argument;
 // i.e. if the count refers to more data than the iov can support, then
@@ -200,9 +204,8 @@ struct nng_aio {
 	// Provider-use fields.
 	nni_aio_cancel_fn a_cancel_fn;
 	void	     *a_cancel_arg;
-	nni_list_node     a_prov_node;     // Linkage on provider list.
-	void	     *a_prov_extra[2]; // Extra data used by provider
-
+	void	     *a_prov_data;
+	nni_list_node     a_prov_node; // Linkage on provider list.
 	nni_aio_expire_q *a_expire_q;
 	nni_list_node     a_expire_node; // Expiration node
 	nni_reap_node     a_reap_node;
diff --git a/src/core/aio_test.c b/src/core/aio_test.c
index a94978b..bbc997b 100644
--- a/src/core/aio_test.c
+++ b/src/core/aio_test.c
@@ -1,5 +1,5 @@
 //
-// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
+// Copyright 2022 Staysail Systems, Inc. <info@staysail.tech>
 // Copyright 2018 Capitar IT Group BV <info@capitar.com>
 //
 // This software is supplied under the terms of the MIT License, a
@@ -364,6 +364,18 @@ test_sleep_cancel(void)
 	nng_mtx_free(sl.mx);
 }
 
+void
+    test_aio_busy(void)
+{
+	nng_aio *aio;
+	NUTS_PASS(nng_aio_alloc(&aio, NULL, NULL));
+	nng_sleep_aio(100, aio);
+	NUTS_ASSERT(nng_aio_busy(aio));
+	nng_aio_wait(aio);
+	NUTS_ASSERT(!nng_aio_busy(aio));
+	nng_aio_free(aio);
+}
+
 NUTS_TESTS = {
 	{ "sleep", test_sleep },
 	{ "sleep timeout", test_sleep_timeout },
@@ -377,5 +389,6 @@ NUTS_TESTS = {
 	{ "aio reap", test_aio_reap },
 	{ "sleep loop", test_sleep_loop },
 	{ "sleep cancel", test_sleep_cancel },
+	{ "aio busy", test_aio_busy },
 	{ NULL, NULL },
 };
\ No newline at end of file
diff --git a/src/core/defs.h b/src/core/defs.h
index fb9c744..f1947fe 100644
--- a/src/core/defs.h
+++ b/src/core/defs.h
@@ -23,7 +23,7 @@
 	if (!(x))     \
 	nni_panic("%s: %d: assert err: %s", __FILE__, __LINE__, #x)
 #else
-#define NNI_ASSERT(x) (0)
+#define NNI_ASSERT(x) ((void)(0))
 #endif
 
 // Returns the size of an array in elements. (Convenience.)
@@ -31,11 +31,11 @@
 
 // These types are common but have names shared with user space.
 // Internal code should use these names when possible.
-typedef nng_msg           nni_msg;
-typedef nng_sockaddr      nni_sockaddr;
-typedef nng_url           nni_url;
-typedef nng_iov           nni_iov;
-typedef nng_aio           nni_aio;
+typedef nng_msg      nni_msg;
+typedef nng_sockaddr nni_sockaddr;
+typedef nng_url      nni_url;
+typedef nng_iov      nni_iov;
+typedef nng_aio      nni_aio;
 
 // These are our own names.
 typedef struct nni_socket   nni_sock;
@@ -44,10 +44,10 @@ typedef struct nni_dialer   nni_dialer;
 typedef struct nni_listener nni_listener;
 typedef struct nni_pipe     nni_pipe;
 
-typedef struct nni_sp_tran           nni_sp_tran;
-typedef struct nni_sp_dialer_ops     nni_sp_dialer_ops;
-typedef struct nni_sp_listener_ops   nni_sp_listener_ops;
-typedef struct nni_sp_pipe_ops       nni_sp_pipe_ops;
+typedef struct nni_sp_tran         nni_sp_tran;
+typedef struct nni_sp_dialer_ops   nni_sp_dialer_ops;
+typedef struct nni_sp_listener_ops nni_sp_listener_ops;
+typedef struct nni_sp_pipe_ops     nni_sp_pipe_ops;
 
 typedef struct nni_proto_ctx_ops  nni_proto_ctx_ops;
 typedef struct nni_proto_sock_ops nni_proto_sock_ops;
@@ -75,51 +75,51 @@ typedef void (*nni_cb)(void *);
 #define NNI_ALLOC_STRUCTS(s, n) nni_zalloc(sizeof(*s) * n)
 #define NNI_FREE_STRUCTS(s, n) nni_free(s, sizeof(*s) * n)
 
-#define NNI_PUT16(ptr, u)                                    \
-	do {                                                 \
-		(ptr)[0] = (uint8_t)(((uint16_t)(u)) >> 8u); \
-		(ptr)[1] = (uint8_t)((uint16_t)(u));         \
+#define NNI_PUT16(ptr, u)                                      \
+	do {                                                   \
+		(ptr)[0] = (uint8_t) (((uint16_t) (u)) >> 8u); \
+		(ptr)[1] = (uint8_t) ((uint16_t) (u));         \
 	} while (0)
 
-#define NNI_PUT32(ptr, u)                                     \
-	do {                                                  \
-		(ptr)[0] = (uint8_t)(((uint32_t)(u)) >> 24u); \
-		(ptr)[1] = (uint8_t)(((uint32_t)(u)) >> 16u); \
-		(ptr)[2] = (uint8_t)(((uint32_t)(u)) >> 8u);  \
-		(ptr)[3] = (uint8_t)((uint32_t)(u));          \
+#define NNI_PUT32(ptr, u)                                       \
+	do {                                                    \
+		(ptr)[0] = (uint8_t) (((uint32_t) (u)) >> 24u); \
+		(ptr)[1] = (uint8_t) (((uint32_t) (u)) >> 16u); \
+		(ptr)[2] = (uint8_t) (((uint32_t) (u)) >> 8u);  \
+		(ptr)[3] = (uint8_t) ((uint32_t) (u));          \
 	} while (0)
 
-#define NNI_PUT64(ptr, u)                                     \
-	do {                                                  \
-		(ptr)[0] = (uint8_t)(((uint64_t)(u)) >> 56u); \
-		(ptr)[1] = (uint8_t)(((uint64_t)(u)) >> 48u); \
-		(ptr)[2] = (uint8_t)(((uint64_t)(u)) >> 40u); \
-		(ptr)[3] = (uint8_t)(((uint64_t)(u)) >> 32u); \
-		(ptr)[4] = (uint8_t)(((uint64_t)(u)) >> 24u); \
-		(ptr)[5] = (uint8_t)(((uint64_t)(u)) >> 16u); \
-		(ptr)[6] = (uint8_t)(((uint64_t)(u)) >> 8u);  \
-		(ptr)[7] = (uint8_t)((uint64_t)(u));          \
+#define NNI_PUT64(ptr, u)                                       \
+	do {                                                    \
+		(ptr)[0] = (uint8_t) (((uint64_t) (u)) >> 56u); \
+		(ptr)[1] = (uint8_t) (((uint64_t) (u)) >> 48u); \
+		(ptr)[2] = (uint8_t) (((uint64_t) (u)) >> 40u); \
+		(ptr)[3] = (uint8_t) (((uint64_t) (u)) >> 32u); \
+		(ptr)[4] = (uint8_t) (((uint64_t) (u)) >> 24u); \
+		(ptr)[5] = (uint8_t) (((uint64_t) (u)) >> 16u); \
+		(ptr)[6] = (uint8_t) (((uint64_t) (u)) >> 8u);  \
+		(ptr)[7] = (uint8_t) ((uint64_t) (u));          \
 	} while (0)
 
-#define NNI_GET16(ptr, v)                             \
-	v = (((uint16_t)((uint8_t)(ptr)[0])) << 8u) + \
-	    (((uint16_t)(uint8_t)(ptr)[1]))
-
-#define NNI_GET32(ptr, v)                              \
-	v = (((uint32_t)((uint8_t)(ptr)[0])) << 24u) + \
-	    (((uint32_t)((uint8_t)(ptr)[1])) << 16u) + \
-	    (((uint32_t)((uint8_t)(ptr)[2])) << 8u) +  \
-	    (((uint32_t)(uint8_t)(ptr)[3]))
-
-#define NNI_GET64(ptr, v)                              \
-	v = (((uint64_t)((uint8_t)(ptr)[0])) << 56u) + \
-	    (((uint64_t)((uint8_t)(ptr)[1])) << 48u) + \
-	    (((uint64_t)((uint8_t)(ptr)[2])) << 40u) + \
-	    (((uint64_t)((uint8_t)(ptr)[3])) << 32u) + \
-	    (((uint64_t)((uint8_t)(ptr)[4])) << 24u) + \
-	    (((uint64_t)((uint8_t)(ptr)[5])) << 16u) + \
-	    (((uint64_t)((uint8_t)(ptr)[6])) << 8u) +  \
-	    (((uint64_t)(uint8_t)(ptr)[7]))
+#define NNI_GET16(ptr, v)                               \
+	v = (((uint16_t) ((uint8_t) (ptr)[0])) << 8u) + \
+	    (((uint16_t) (uint8_t) (ptr)[1]))
+
+#define NNI_GET32(ptr, v)                                \
+	v = (((uint32_t) ((uint8_t) (ptr)[0])) << 24u) + \
+	    (((uint32_t) ((uint8_t) (ptr)[1])) << 16u) + \
+	    (((uint32_t) ((uint8_t) (ptr)[2])) << 8u) +  \
+	    (((uint32_t) (uint8_t) (ptr)[3]))
+
+#define NNI_GET64(ptr, v)                                \
+	v = (((uint64_t) ((uint8_t) (ptr)[0])) << 56u) + \
+	    (((uint64_t) ((uint8_t) (ptr)[1])) << 48u) + \
+	    (((uint64_t) ((uint8_t) (ptr)[2])) << 40u) + \
+	    (((uint64_t) ((uint8_t) (ptr)[3])) << 32u) + \
+	    (((uint64_t) ((uint8_t) (ptr)[4])) << 24u) + \
+	    (((uint64_t) ((uint8_t) (ptr)[5])) << 16u) + \
+	    (((uint64_t) ((uint8_t) (ptr)[6])) << 8u) +  \
+	    (((uint64_t) (uint8_t) (ptr)[7]))
 
 // This increments a pointer a fixed number of byte cells.
 #define NNI_INCPTR(ptr, n) ((ptr) = (void *) ((char *) (ptr) + (n)))
@@ -171,4 +171,11 @@ typedef nni_type nni_opt_type;
 #define NNI_EXPIRE_BATCH 100
 #endif
 
+#if __GNUC__ > 3
+// NNI_GCC_VERSION is used to indicate a GNU version.  It is used
+// to trigger certain cases like atomics that might be compiler specific.
+#define NNI_GCC_VERSION \
+	(__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__)
+#endif
+
 #endif // CORE_DEFS_H
diff --git a/src/core/device.c b/src/core/device.c
index 71480bb..08c7bab 100644
--- a/src/core/device.c
+++ b/src/core/device.c
@@ -1,5 +1,5 @@
 //
-// Copyright 2018 Staysail Systems, Inc. <info@staysail.com>
+// Copyright 2021 Staysail Systems, Inc. <info@staysail.com>
 // Copyright 2018 Capitar IT Group BV <info@capitar.com>
 //
 // This software is supplied under the terms of the MIT License, a
@@ -10,107 +10,130 @@
 
 #include "core/nng_impl.h"
 
-#include <string.h>
+typedef struct device_data_s device_data;
+typedef struct device_path_s device_path;
 
-typedef struct nni_device_path {
-	nni_aio * user; // user aio
-	nni_aio * aio;
-	nni_sock *src;
-	nni_sock *dst;
-	int       state;
-} nni_device_path;
+struct device_path_s {
+	int          state;
+	device_data *d;
+	nni_sock    *src;
+	nni_sock    *dst;
+	nni_aio      aio;
+};
 
 #define NNI_DEVICE_STATE_INIT 0
 #define NNI_DEVICE_STATE_RECV 1
 #define NNI_DEVICE_STATE_SEND 2
 #define NNI_DEVICE_STATE_FINI 3
 
-typedef struct nni_device_data {
-	nni_aio *       user;
-	int             npath;
-	nni_device_path paths[2];
-	nni_mtx         mtx;
-	bool            running;
-} nni_device_data;
+struct device_data_s {
+	nni_aio      *user;
+	int           num_paths;
+	int           running;
+	int           rv;
+	device_path   paths[2];
+	nni_reap_node reap;
+};
 
-typedef struct nni_device_pair nni_device_pair;
+static void device_fini(void *);
+
+static nni_mtx       device_mtx  = NNI_MTX_INITIALIZER;
+static nni_reap_list device_reap = {
+	.rl_offset = offsetof(device_data, reap),
+	.rl_func   = device_fini,
+};
 
 static void
-nni_device_cancel(nni_aio *aio, void *arg, int rv)
+device_fini(void *arg)
 {
-	nni_device_data *dd = arg;
-	// cancellation is the only path to shutting it down.
+	device_data *d = arg;
 
-	nni_mtx_lock(&dd->mtx);
-	if ((!dd->running) || (dd->user != aio)) {
-		nni_mtx_unlock(&dd->mtx);
-		return;
+	for (int i = 0; i < d->num_paths; i++) {
+		nni_aio_stop(&d->paths[i].aio);
 	}
-	dd->running = false;
-	dd->user    = NULL;
-	nni_mtx_unlock(&dd->mtx);
-
-	nni_sock_shutdown(dd->paths[0].src);
-	nni_sock_shutdown(dd->paths[0].dst);
-	nni_aio_finish_error(aio, rv);
+	NNI_FREE_STRUCT(d);
 }
 
 static void
-nni_device_cb(void *arg)
+device_cancel(nni_aio *aio, void *arg, int rv)
 {
-	nni_device_path *p   = arg;
-	nni_aio *        aio = p->aio;
-	int              rv;
+	device_data *d = arg;
+	// cancellation is the only path to shutting it down.
 
-	if ((rv = nni_aio_result(aio)) != 0) {
+	nni_mtx_lock(&device_mtx);
+	if (d->user == aio) {
+		for (int i = 0; i < d->num_paths; i++) {
+			nni_aio_abort(&d->paths[i].aio, rv);
+		}
+	}
+	nni_mtx_unlock(&device_mtx);
+}
+
+static void
+device_cb(void *arg)
+{
+	device_path *p = arg;
+	device_data *d = p->d;
+	int          rv;
+
+	if ((rv = nni_aio_result(&p->aio)) != 0) {
+		nni_mtx_lock(&device_mtx);
+		if (p->state == NNI_DEVICE_STATE_SEND) {
+			nni_msg_free(nni_aio_get_msg(&p->aio));
+			nni_aio_set_msg(&p->aio, NULL);
+		}
 		p->state = NNI_DEVICE_STATE_FINI;
-		nni_aio_abort(p->user, rv);
+		d->running--;
+		if (d->rv == 0) {
+			d->rv = rv;
+		}
+		for (int i = 0; i < d->num_paths; i++) {
+			if (p != &d->paths[i]) {
+				nni_aio_abort(&d->paths[i].aio, rv);
+			}
+		}
+		if (d->running == 0) {
+			if (d->user != NULL) {
+				nni_aio_finish_error(d->user, d->rv);
+				d->user = NULL;
+			}
+			nni_sock_rele(d->paths[0].src);
+			nni_sock_rele(d->paths[0].dst);
+
+			nni_reap(&device_reap, d);
+		}
+		nni_mtx_unlock(&device_mtx);
 		return;
 	}
 
 	switch (p->state) {
 	case NNI_DEVICE_STATE_INIT:
+		break;
 	case NNI_DEVICE_STATE_SEND:
 		p->state = NNI_DEVICE_STATE_RECV;
-		nni_sock_recv(p->src, aio);
+		nni_sock_recv(p->src, &p->aio);
 		break;
 	case NNI_DEVICE_STATE_RECV:
 		// Leave the message where it is.
 		p->state = NNI_DEVICE_STATE_SEND;
-		nni_sock_send(p->dst, aio);
+		nni_sock_send(p->dst, &p->aio);
 		break;
 	case NNI_DEVICE_STATE_FINI:
 		break;
 	}
 }
 
-void
-nni_device_fini(nni_device_data *dd)
+static int
+device_init(device_data **dp, nni_sock *s1, nni_sock *s2)
 {
-	int i;
-	for (i = 0; i < dd->npath; i++) {
-		nni_device_path *p = &dd->paths[i];
-		nni_aio_stop(p->aio);
-	}
-	for (i = 0; i < dd->npath; i++) {
-		nni_device_path *p = &dd->paths[i];
-		nni_aio_free(p->aio);
-	}
-	nni_mtx_fini(&dd->mtx);
-	NNI_FREE_STRUCT(dd);
-}
-
-int
-nni_device_init(nni_device_data **dp, nni_sock *s1, nni_sock *s2)
-{
-	nni_device_data *dd;
-	int              npath = 2;
-	int              i;
-	bool             raw;
-	size_t           rsz;
+	int          num_paths = 2;
+	int          i;
+	bool         raw;
+	size_t       rsz;
+	device_data *d;
 
 	// Specifying either of these as null turns the device into
-	// a loopback reflector.
+	// a reflector.
 	if (s1 == NULL) {
 		s1 = s2;
 	}
@@ -141,8 +164,8 @@ nni_device_init(nni_device_data **dp, nni_sock *s1, nni_sock *s2)
 		return (NNG_EINVAL);
 	}
 
-	// Note we assume that since they peers, we only need to look
-	// at the receive flags -- the other side is assumed to be able
+	// Note we assume that since they are peers, we only need to look
+	// at the recv flags -- the other side is assumed to be able
 	// to send.
 	if ((nni_sock_flags(s1) & NNI_PROTO_FLAG_RCV) == 0) {
 		nni_sock *temp = s1;
@@ -157,82 +180,65 @@ nni_device_init(nni_device_data **dp, nni_sock *s1, nni_sock *s2)
 	// not strictly necessary, but it saves resources and minimizes any
 	// extra reordering.)
 	if (((nni_sock_flags(s2) & NNI_PROTO_FLAG_RCV) == 0) || (s1 == s2)) {
-		npath = 1;
+		num_paths = 1;
 	}
 
-	if ((dd = NNI_ALLOC_STRUCT(dd)) == NULL) {
+	if ((d = NNI_ALLOC_STRUCT(d)) == NULL) {
 		return (NNG_ENOMEM);
 	}
-	nni_mtx_init(&dd->mtx);
 
-	for (i = 0; i < npath; i++) {
-		int              rv;
-		nni_device_path *p = &dd->paths[i];
-		p->src             = i == 0 ? s1 : s2;
-		p->dst             = i == 0 ? s2 : s1;
-		p->state           = NNI_DEVICE_STATE_INIT;
+	d->num_paths = 0;
+	for (i = 0; i < num_paths; i++) {
+		device_path *p = &d->paths[i];
+		p->src         = i == 0 ? s1 : s2;
+		p->dst         = i == 0 ? s2 : s1;
+		p->d           = d;
+		p->state       = NNI_DEVICE_STATE_INIT;
 
-		if ((rv = nni_aio_alloc(&p->aio, nni_device_cb, p)) != 0) {
-			nni_device_fini(dd);
-			return (rv);
-		}
+		nni_aio_init(&p->aio, device_cb, p);
 
-		nni_aio_set_timeout(p->aio, NNG_DURATION_INFINITE);
+		nni_aio_set_timeout(&p->aio, NNG_DURATION_INFINITE);
 	}
-	dd->npath = npath;
-	*dp       = dd;
+	nni_sock_hold(d->paths[0].src);
+	nni_sock_hold(d->paths[0].dst);
+
+	d->num_paths = num_paths;
+	*dp          = d;
 	return (0);
 }
 
-void
-nni_device_start(nni_device_data *dd, nni_aio *user)
+static void
+device_start(device_data *d, nni_aio *user)
 {
-	int i;
-	int rv;
-
-	if (nni_aio_begin(user) != 0) {
-		return;
+	d->user = user;
+	for (int i = 0; i < d->num_paths; i++) {
+		device_path *p = &d->paths[i];
+		p->state       = NNI_DEVICE_STATE_RECV;
+		nni_sock_recv(p->src, &p->aio);
+		d->running++;
 	}
-	nni_mtx_lock(&dd->mtx);
-	if ((rv = nni_aio_schedule(user, nni_device_cancel, dd)) != 0) {
-		nni_mtx_unlock(&dd->mtx);
-		nni_aio_finish_error(user, rv);
-		return;
-	}
-	dd->user = user;
-	for (i = 0; i < dd->npath; i++) {
-		nni_device_path *p = &dd->paths[i];
-		p->user            = user;
-		p->state           = NNI_DEVICE_STATE_INIT;
-	}
-	for (i = 0; i < dd->npath; i++) {
-		nni_device_path *p = &dd->paths[i];
-		p->state           = NNI_DEVICE_STATE_RECV;
-		nni_sock_recv(p->src, p->aio);
-	}
-	dd->running = true;
-	nni_mtx_unlock(&dd->mtx);
 }
 
-int
-nni_device(nni_sock *s1, nni_sock *s2)
+void
+nni_device(nni_aio *aio, nni_sock *s1, nni_sock *s2)
 {
-	nni_device_data *dd;
-	nni_aio *        aio;
-	int              rv;
+	device_data *d;
+	int          rv;
 
-	if ((rv = nni_aio_alloc(&aio, NULL, NULL)) != 0) {
-		return (rv);
+	if (nni_aio_begin(aio) != 0) {
+		return;
+	}
+	nni_mtx_lock(&device_mtx);
+	if ((rv = device_init(&d, s1, s2)) != 0) {
+		nni_mtx_unlock(&device_mtx);
+		nni_aio_finish_error(aio, rv);
+		return;
 	}
-	if ((rv = nni_device_init(&dd, s1, s2)) != 0) {
-		nni_aio_free(aio);
-		return (rv);
+	if ((rv = nni_aio_schedule(aio, device_cancel, d)) != 0) {
+		nni_mtx_unlock(&device_mtx);
+		nni_aio_finish_error(aio, rv);
+		nni_reap(&device_reap, d);
 	}
-	nni_device_start(dd, aio);
-	nni_aio_wait(aio);
-
-	rv = nni_aio_result(aio);
-	nni_device_fini(dd);
-	nni_aio_free(aio);
-	return (rv);
+	device_start(d, aio);
+	nni_mtx_unlock(&device_mtx);
 }
diff --git a/src/core/device.h b/src/core/device.h
index 973a4cb..8d11aeb 100644
--- a/src/core/device.h
+++ b/src/core/device.h
@@ -1,5 +1,5 @@
 //
-// Copyright 2017 Garrett D'Amore <garrett@damore.org>
+// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
 //
 // This software is supplied under the terms of the MIT License, a
 // copy of which should be located in the distribution where this
@@ -14,6 +14,6 @@
 // It works in both directions.  Arguably we should build versions of this
 // that are unidirectional, and we could extend this API with user-defined
 // filtering functions.
-extern int nni_device(nni_sock *, nni_sock *);
+extern void nni_device(nni_aio *aio, nni_sock *, nni_sock *);
 
 #endif // CORE_DEVICE_H
diff --git a/src/core/dialer.c b/src/core/dialer.c
index 4c3e563..c7bdfc3 100644
--- a/src/core/dialer.c
+++ b/src/core/dialer.c
@@ -15,30 +15,13 @@
 #include <stdio.h>
 #include <string.h>
 
-// Functionality related to dialers.
+// Functionality related to dialing.
 static void dialer_connect_start(nni_dialer *);
 static void dialer_connect_cb(void *);
 static void dialer_timer_cb(void *);
 
-static nni_id_map dialers;
-static nni_mtx    dialers_lk;
-
-int
-nni_dialer_sys_init(void)
-{
-	nni_id_map_init(&dialers, 1, 0x7fffffff, false);
-	nni_mtx_init(&dialers_lk);
-
-	return (0);
-}
-
-void
-nni_dialer_sys_fini(void)
-{
-	nni_reap_drain();
-	nni_mtx_fini(&dialers_lk);
-	nni_id_map_fini(&dialers);
-}
+static nni_id_map dialers    = NNI_ID_MAP_INITIALIZER(1, 0x7fffffff, 0);
+static nni_mtx    dialers_lk = NNI_MTX_INITIALIZER;
 
 uint32_t
 nni_dialer_id(nni_dialer *d)
diff --git a/src/core/dialer.h b/src/core/dialer.h
index df92320..7bc1547 100644
--- a/src/core/dialer.h
+++ b/src/core/dialer.h
@@ -1,5 +1,5 @@
 //
-// Copyright 2020 Staysail Systems, Inc. <info@staysail.tech>
+// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
 // Copyright 2018 Capitar IT Group BV <info@capitar.com>
 // Copyright 2018 Devolutions <info@devolutions.net>
 //
@@ -12,8 +12,6 @@
 #ifndef CORE_DIALER_H
 #define CORE_DIALER_H
 
-extern int       nni_dialer_sys_init(void);
-extern void      nni_dialer_sys_fini(void);
 extern int       nni_dialer_find(nni_dialer **, uint32_t);
 extern int       nni_dialer_hold(nni_dialer *);
 extern void      nni_dialer_rele(nni_dialer *);
diff --git a/src/core/id_test.c b/src/core/id_test.c
index 51872e6..b948cc1 100644
--- a/src/core/id_test.c
+++ b/src/core/id_test.c
@@ -1,5 +1,5 @@
 //
-// Copyright 2020 Staysail Systems, Inc. <info@staysail.tech>
+// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
 //
 // This software is supplied under the terms of the MIT License, a
 // copy of which should be located in the distribution where this
@@ -15,8 +15,8 @@ void
 test_basic(void)
 {
 	nni_id_map m;
-	char *     five = "five";
-	char *     four = "four";
+	char      *five = "five";
+	char      *four = "four";
 
 	nni_id_map_init(&m, 0, 0, false);
 
@@ -60,8 +60,8 @@ void
 test_collision(void)
 {
 	nni_id_map m;
-	char *     five = "five";
-	char *     four = "four";
+	char      *five = "five";
+	char      *four = "four";
 
 	nni_id_map_init(&m, 0, 0, false);
 
@@ -141,7 +141,7 @@ test_dynamic(void)
 
 	nni_id_map_init(&m, 10, 13, false);
 
-        // We can fill the table.
+	// We can fill the table.
 	NUTS_PASS(nni_id_alloc(&m, &id, &expect[0]));
 	NUTS_TRUE(id == 10);
 	NUTS_PASS(nni_id_alloc(&m, &id, &expect[1]));
@@ -186,11 +186,11 @@ test_set_out_of_range(void)
 void
 test_stress(void)
 {
-	void *     values[NUM_VALUES];
+	void      *values[NUM_VALUES];
 	nni_id_map m;
 	size_t     i;
 	int        rv;
-	void *     x;
+	void      *x;
 	int        v;
 
 	nni_id_map_init(&m, 0, 0, false);
@@ -240,15 +240,15 @@ out:
 
 	// Post stress check.
 	for (i = 0; i < NUM_VALUES; i++) {
-		x = nni_id_get(&m, i);
+		x = nni_id_get(&m, (uint32_t) i);
 		if (x != values[i]) {
 			NUTS_TRUE(x == values[i]);
 			break;
 		}
 
 		// We only use the test macros if we know they are going
-		// to fail.  Otherwise there will be too many errors reported.
-		rv = nni_id_remove(&m, i);
+		// to fail.  Otherwise, there will be too many errors reported.
+		rv = nni_id_remove(&m, (uint32_t) i);
 		if ((x == NULL) && (rv != NNG_ENOENT)) {
 			NUTS_FAIL(rv, NNG_ENOENT);
 		} else if ((x != NULL) && (rv != 0)) {
diff --git a/src/core/idhash.c b/src/core/idhash.c
index c61850d..9eb959d 100644
--- a/src/core/idhash.c
+++ b/src/core/idhash.c
@@ -1,5 +1,5 @@
 //
-// Copyright 2020 Staysail Systems, Inc. <info@staysail.tech>
+// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
 // Copyright 2018 Capitar IT Group BV <info@capitar.com>
 //
 // This software is supplied under the terms of the MIT License, a
@@ -15,9 +15,14 @@
 struct nni_id_entry {
 	uint32_t key;
 	uint32_t skips;
-	void *   val;
+	void    *val;
 };
 
+static int          id_reg_len = 0;
+static int          id_reg_num = 0;
+static nni_id_map **id_reg_map = NULL;
+static nni_mtx      id_reg_mtx = NNI_MTX_INITIALIZER;
+
 void
 nni_id_map_init(nni_id_map *m, uint32_t lo, uint32_t hi, bool randomize)
 {
@@ -33,15 +38,15 @@ nni_id_map_init(nni_id_map *m, uint32_t lo, uint32_t hi, bool randomize)
 	m->id_count    = 0;
 	m->id_load     = 0;
 	m->id_cap      = 0;
+	m->id_dyn_val  = 0;
 	m->id_max_load = 0;
 	m->id_min_load = 0; // never shrink below this
 	m->id_min_val  = lo;
 	m->id_max_val  = hi;
 	if (randomize) {
-		// NB: The range is inclusive.
-		m->id_dyn_val = nni_random() % ((hi - lo) + 1) + lo;
+		m->id_flags = NNI_ID_FLAG_RANDOM;
 	} else {
-		m->id_dyn_val = lo;
+		m->id_flags = 0;
 	}
 }
 
@@ -102,20 +107,74 @@ nni_id_get(nni_id_map *m, uint32_t id)
 	return (m->id_entries[index].val);
 }
 
+static int
+id_map_register(nni_id_map *m)
+{
+	if ((m->id_flags & (NNI_ID_FLAG_STATIC | NNI_ID_FLAG_REGISTER)) !=
+	    NNI_ID_FLAG_STATIC) {
+		return (0);
+	}
+	nni_mtx_lock(&id_reg_mtx);
+	if (id_reg_len <= id_reg_num) {
+		nni_id_map **mr;
+		int          len = id_reg_len;
+		if (len < 10) {
+			len = 10;
+		} else {
+			len *= 2;
+		}
+		mr = nni_zalloc(sizeof(nni_id_map *) * len);
+		if (mr == NULL) {
+			nni_mtx_unlock(&id_reg_mtx);
+			return (NNG_ENOMEM);
+		}
+		id_reg_len = len;
+		memcpy(mr, id_reg_map, id_reg_num * sizeof(nni_id_map *));
+		id_reg_map = mr;
+	}
+	id_reg_map[id_reg_num++] = m;
+	m->id_flags |= NNI_ID_FLAG_REGISTER;
+	nni_mtx_unlock(&id_reg_mtx);
+	return (0);
+}
+
+void
+nni_id_map_sys_fini(void)
+{
+	nni_mtx_lock(&id_reg_mtx);
+	for (int i = 0; i < id_reg_num; i++) {
+		if (id_reg_map[i] != NULL) {
+			nni_id_map_fini(id_reg_map[i]);
+		}
+	}
+	nni_free(id_reg_map, sizeof(nni_id_map *) * id_reg_len);
+	id_reg_map = NULL;
+	id_reg_len = 0;
+	id_reg_num = 0;
+	nni_mtx_unlock(&id_reg_mtx);
+}
+
 static int
 id_resize(nni_id_map *m)
 {
-	size_t        new_cap;
-	size_t        old_cap;
 	nni_id_entry *new_entries;
 	nni_id_entry *old_entries;
+	uint32_t      new_cap;
+	uint32_t      old_cap;
 	uint32_t      i;
+	int           rv;
 
 	if ((m->id_load < m->id_max_load) && (m->id_load >= m->id_min_load)) {
 		// No resize needed.
 		return (0);
 	}
 
+	// if it is a statically declared map, register it so that we
+	// will free it at finalization time
+	if ((rv = id_map_register(m)) != 0) {
+		return (rv);
+	}
+
 	old_cap = m->id_cap;
 	new_cap = 8;
 	while (new_cap < (m->id_count * 2)) {
@@ -266,6 +325,16 @@ nni_id_alloc(nni_id_map *m, uint32_t *idp, void *val)
 		// Really more like ENOSPC.. the table is filled to max.
 		return (NNG_ENOMEM);
 	}
+	if (m->id_dyn_val == 0) {
+		if (m->id_flags & NNI_ID_FLAG_RANDOM) {
+			// NB: The range is inclusive.
+			m->id_dyn_val = nni_random() %
+			        (m->id_max_val - m->id_min_val + 1) +
+			    m->id_min_val;
+		} else {
+			m->id_dyn_val = m->id_min_val;
+		}
+	}
 
 	for (;;) {
 		id = m->id_dyn_val;
diff --git a/src/core/idhash.h b/src/core/idhash.h
index 0c9043c..e8894df 100644
--- a/src/core/idhash.h
+++ b/src/core/idhash.h
@@ -1,5 +1,5 @@
 //
-// Copyright 2020 Staysail Systems, Inc. <info@staysail.tech>
+// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
 // Copyright 2018 Capitar IT Group BV <info@capitar.com>
 //
 // This software is supplied under the terms of the MIT License, a
@@ -23,28 +23,40 @@
 // use table sizes that are powers of two.  Note that hash items
 // must be non-NULL.  The table is protected by an internal lock.
 
-typedef struct nni_id_map       nni_id_map;
-typedef struct nni_id_entry     nni_id_entry;
+typedef struct nni_id_map   nni_id_map;
+typedef struct nni_id_entry nni_id_entry;
 
 // NB: These details are entirely private to the hash implementation.
 // They are provided here to facilitate inlining in structures.
 struct nni_id_map {
-	size_t        id_cap;
-	size_t        id_count;
-	size_t        id_load;
-	size_t        id_min_load; // considers placeholders
-	size_t        id_max_load;
+	uint32_t      id_cap;
+	uint32_t      id_count;
+	uint32_t      id_load;
+	uint32_t      id_min_load; // considers placeholders
+	uint32_t      id_max_load;
 	uint32_t      id_min_val;
 	uint32_t      id_max_val;
 	uint32_t      id_dyn_val;
+	uint32_t      id_flags;
 	nni_id_entry *id_entries;
 };
 
-extern void nni_id_map_init(nni_id_map *, uint32_t, uint32_t, bool);
-extern void nni_id_map_fini(nni_id_map *);
+#define NNI_ID_FLAG_STATIC 1   // allocated statically
+#define NNI_ID_FLAG_RANDOM 2   // start at a random value
+#define NNI_ID_FLAG_REGISTER 4 // map is registered for finalization
+
+extern void  nni_id_map_init(nni_id_map *, uint32_t, uint32_t, bool);
+extern void  nni_id_map_fini(nni_id_map *);
 extern void *nni_id_get(nni_id_map *, uint32_t);
-extern int nni_id_set(nni_id_map *, uint32_t, void *);
-extern int nni_id_alloc(nni_id_map *, uint32_t *, void *);
-extern int nni_id_remove(nni_id_map *, uint32_t);
+extern int   nni_id_set(nni_id_map *, uint32_t, void *);
+extern int   nni_id_alloc(nni_id_map *, uint32_t *, void *);
+extern int   nni_id_remove(nni_id_map *, uint32_t);
+extern void  nni_id_map_sys_fini(void);
+
+#define NNI_ID_MAP_INITIALIZER(min, max, flags)            \
+	{                                                  \
+		.id_min_val = (min), .id_max_val = (max),  \
+		.id_flags = ((flags) | NNI_ID_FLAG_STATIC) \
+	}
 
 #endif // CORE_IDHASH_H
diff --git a/src/core/init.c b/src/core/init.c
index 9f39490..f8ecb38 100644
--- a/src/core/init.c
+++ b/src/core/init.c
@@ -14,21 +14,16 @@
 #include <stdio.h>
 #include <stdlib.h>
 
-static nni_mtx  nni_init_mtx;
-static nni_list nni_init_list;
-static bool     nni_inited = false;
-
-extern int nni_tls_sys_init(void);
+extern int  nni_tls_sys_init(void);
 extern void nni_tls_sys_fini(void);
 
+static bool nni_inited = false;
+
 static int
 nni_init_helper(void)
 {
 	int rv;
 
-	nni_mtx_init(&nni_init_mtx);
-	NNI_LIST_INIT(&nni_init_list, nni_initializer, i_node);
-	nni_inited = true;
 #ifdef NNG_TEST_LIB
 	static bool cleanup = false;
 	if (!cleanup) {
@@ -37,21 +32,21 @@ nni_init_helper(void)
 	}
 #endif
 
-	if (((rv = nni_stat_sys_init()) != 0) ||
-	    ((rv = nni_taskq_sys_init()) != 0) ||
+	if (((rv = nni_taskq_sys_init()) != 0) ||
 	    ((rv = nni_reap_sys_init()) != 0) ||
 	    ((rv = nni_timer_sys_init()) != 0) ||
 	    ((rv = nni_aio_sys_init()) != 0) ||
-	    ((rv = nni_sock_sys_init()) != 0) ||
-	    ((rv = nni_listener_sys_init()) != 0) ||
-	    ((rv = nni_dialer_sys_init()) != 0) ||
-	    ((rv = nni_pipe_sys_init()) != 0) ||
-	    ((rv = nni_tls_sys_init()) != 0) ||
-	    ((rv = nni_sp_tran_sys_init()) != 0)) {
+	    ((rv = nni_tls_sys_init()) != 0)) {
 		nni_fini();
+		return (rv);
 	}
 
-	return (rv);
+	// following never fail
+	nni_sp_tran_sys_init();
+
+	nni_inited = true;
+
+	return (0);
 }
 
 int
@@ -66,53 +61,15 @@ nni_fini(void)
 	if (!nni_inited) {
 		return;
 	}
-	if (!nni_list_empty(&nni_init_list)) {
-		nni_initializer *init;
-
-		nni_mtx_lock(&nni_init_mtx);
-		while ((init = nni_list_first(&nni_init_list)) != NULL) {
-			if (init->i_fini != NULL) {
-				init->i_fini();
-			}
-			init->i_once = 0;
-			nni_list_remove(&nni_init_list, init);
-		}
-		nni_mtx_unlock(&nni_init_mtx);
-	}
 	nni_sp_tran_sys_fini();
 	nni_tls_sys_fini();
-	nni_pipe_sys_fini();
-	nni_dialer_sys_fini();
-	nni_listener_sys_fini();
-	nni_sock_sys_fini();
 	nni_reap_drain();
 	nni_aio_sys_fini();
 	nni_timer_sys_fini();
 	nni_taskq_sys_fini();
 	nni_reap_sys_fini(); // must be before timer and aio (expire)
-	nni_stat_sys_fini();
+	nni_id_map_sys_fini();
 
-	nni_mtx_fini(&nni_init_mtx);
 	nni_plat_fini();
 	nni_inited = false;
 }
-
-int
-nni_initialize(nni_initializer *init)
-{
-	int rv;
-	if (init->i_once) {
-		return (0);
-	}
-	nni_mtx_lock(&nni_init_mtx);
-	if (init->i_once) {
-		nni_mtx_unlock(&nni_init_mtx);
-		return (0);
-	}
-	if ((rv = init->i_init()) == 0) {
-		init->i_once = 1;
-		nni_list_append(&nni_init_list, init);
-	}
-	nni_mtx_unlock(&nni_init_mtx);
-	return (rv);
-}
diff --git a/src/core/init.h b/src/core/init.h
index d21bb4c..7875ba4 100644
--- a/src/core/init.h
+++ b/src/core/init.h
@@ -23,23 +23,4 @@ int nni_init(void);
 // that all resources used by the library are released back to the system.
 void nni_fini(void);
 
-typedef struct nni_initializer {
-	int (*i_init)(void);  // i_init is called exactly once
-	void (*i_fini)(void); // i_fini is called on shutdown
-	int           i_once; // private -- initialize to zero
-	nni_list_node i_node; // private -- initialize to zero
-} nni_initializer;
-
-// nni_initialize will call the initialization routine exactly once.  This is
-// done efficiently, so that if the caller has initialized already, then
-// subsequent calls are "cheap" (no synchronization cost).  The initialization
-// function must not itself cause any further calls to nni_initialize; the
-// function should limit itself to initialization of locks and static data
-// structures.  When shutting down, the finalizer will be called.  The
-// order in which finalizers are called is unspecified.
-//
-// An initializer may fail (due to resource exhaustion), in which case the
-// return value of nni_initialize will be non-zero.
-int nni_initialize(nni_initializer *);
-
 #endif // CORE_INIT_H
diff --git a/src/core/list.h b/src/core/list.h
index 204057a..d3c703b 100644
--- a/src/core/list.h
+++ b/src/core/list.h
@@ -29,6 +29,16 @@ extern void nni_list_init_offset(nni_list *list, size_t offset);
 #define NNI_LIST_INIT(list, type, field) \
 	nni_list_init_offset(list, offsetof(type, field))
 
+// NNI_LIST_INITIALIZER is used to initialize structures at declaration time.
+// The list argument is the structure being initialized and the type and
+// offset determine where the node lives within each item.
+#define NNI_LIST_INITIALIZER(list, type, field)          \
+	{                                                \
+		.ll_head.ln_next = &(list).ll_head,      \
+		.ll_head.ln_prev = &(list).ll_head,      \
+		.ll_offset       = offsetof(type, field) \
+	}
+
 #define NNI_LIST_NODE_INIT(node)                       \
 	do {                                           \
 		(node)->ln_prev = (node)->ln_next = 0; \
diff --git a/src/core/listener.c b/src/core/listener.c
index 410988f..09fddf0 100644
--- a/src/core/listener.c
+++ b/src/core/listener.c
@@ -21,25 +21,8 @@ static void listener_accept_start(nni_listener *);
 static void listener_accept_cb(void *);
 static void listener_timer_cb(void *);
 
-static nni_id_map listeners;
-static nni_mtx    listeners_lk;
-
-int
-nni_listener_sys_init(void)
-{
-	nni_id_map_init(&listeners, 1, 0x7fffffff, false);
-	nni_mtx_init(&listeners_lk);
-
-	return (0);
-}
-
-void
-nni_listener_sys_fini(void)
-{
-	nni_reap_drain();
-	nni_mtx_fini(&listeners_lk);
-	nni_id_map_fini(&listeners);
-}
+static nni_id_map listeners = NNI_ID_MAP_INITIALIZER(1, 0x7fffffff, 0);
+static nni_mtx    listeners_lk = NNI_MTX_INITIALIZER;
 
 uint32_t
 nni_listener_id(nni_listener *l)
diff --git a/src/core/listener.h b/src/core/listener.h
index ef87a93..c6c0b5d 100644
--- a/src/core/listener.h
+++ b/src/core/listener.h
@@ -1,5 +1,5 @@
 //
-// Copyright 2018 Staysail Systems, Inc. <info@staysail.tech>
+// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
 // Copyright 2018 Capitar IT Group BV <info@capitar.com>
 // Copyright 2018 Devolutions <info@devolutions.net>
 //
@@ -12,8 +12,6 @@
 #ifndef CORE_LISTENER_H
 #define CORE_LISTENER_H
 
-extern int      nni_listener_sys_init(void);
-extern void     nni_listener_sys_fini(void);
 extern int      nni_listener_find(nni_listener **, uint32_t);
 extern int      nni_listener_hold(nni_listener *);
 extern void     nni_listener_rele(nni_listener *);
diff --git a/src/core/lmq.c b/src/core/lmq.c
index 47058fc..d01afe5 100644
--- a/src/core/lmq.c
+++ b/src/core/lmq.c
@@ -1,5 +1,5 @@
 //
-// Copyright 2020 Staysail Systems, Inc. <info@staysail.tech>
+// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
 //
 // This software is supplied under the terms of the MIT License, a
 // copy of which should be located in the distribution where this
@@ -10,34 +10,30 @@
 #include "nng_impl.h"
 
 // Light-weight message queue. These are derived from our heavy-weight
-// message queues, but are less "featureful", but more useful for
+// message queues, but are less "featured", but more useful for
 // performance sensitive contexts.  Locking must be done by the caller.
 
-int
+
+// Note that initialization of a queue is guaranteed to succeed.
+// However, if the requested capacity is larger than 2, and memory
+// cannot be allocated, then the capacity will only be 2.
+void
 nni_lmq_init(nni_lmq *lmq, size_t cap)
 {
-	size_t alloc;
-
-	// We prefer alloc to a power of 2, this allows us to do modulo
-	// operations as a power of two, for efficiency.  It does possibly
-	// waste some space, but never more than 2x.  Consumers should try
-	// for powers of two if they are concerned about efficiency.
-	alloc = 2;
-	while (alloc < cap) {
-		alloc *= 2;
-	}
-	if ((lmq->lmq_msgs = nni_zalloc(sizeof(nng_msg *) * alloc)) == NULL) {
-		NNI_FREE_STRUCT(lmq);
-		return (NNG_ENOMEM);
+	lmq->lmq_len = 0;
+	lmq->lmq_get = 0;
+	lmq->lmq_put = 0;
+	lmq->lmq_alloc = 0;
+	lmq->lmq_mask = 0;
+	lmq->lmq_msgs = NULL;
+	lmq->lmq_msgs = lmq->lmq_buf;
+	lmq->lmq_cap = 2;
+	lmq->lmq_mask = 0x1; // only index 0 and 1
+	if (cap > 2) {
+		(void) nni_lmq_resize(lmq, cap);
+	} else {
+		lmq->lmq_cap = cap;
 	}
-	lmq->lmq_cap   = cap;
-	lmq->lmq_alloc = alloc;
-	lmq->lmq_mask  = (alloc - 1);
-	lmq->lmq_len   = 0;
-	lmq->lmq_get   = 0;
-	lmq->lmq_put   = 0;
-
-	return (0);
 }
 
 void
@@ -54,8 +50,9 @@ nni_lmq_fini(nni_lmq *lmq)
 		lmq->lmq_len--;
 		nni_msg_free(msg);
 	}
-
-	nni_free(lmq->lmq_msgs, lmq->lmq_alloc * sizeof(nng_msg *));
+	if (lmq->lmq_alloc > 0) {
+		nni_free(lmq->lmq_msgs, lmq->lmq_alloc * sizeof(nng_msg *));
+	}
 }
 
 void
@@ -94,7 +91,7 @@ nni_lmq_empty(nni_lmq *lmq)
 }
 
 int
-nni_lmq_putq(nni_lmq *lmq, nng_msg *msg)
+nni_lmq_put(nni_lmq *lmq, nng_msg *msg)
 {
 	if (lmq->lmq_len >= lmq->lmq_cap) {
 		return (NNG_EAGAIN);
@@ -106,7 +103,7 @@ nni_lmq_putq(nni_lmq *lmq, nng_msg *msg)
 }
 
 int
-nni_lmq_getq(nni_lmq *lmq, nng_msg **msgp)
+nni_lmq_get(nni_lmq *lmq, nng_msg **mp)
 {
 	nng_msg *msg;
 	if (lmq->lmq_len == 0) {
@@ -115,15 +112,15 @@ nni_lmq_getq(nni_lmq *lmq, nng_msg **msgp)
 	msg = lmq->lmq_msgs[lmq->lmq_get++];
 	lmq->lmq_get &= lmq->lmq_mask;
 	lmq->lmq_len--;
-	*msgp = msg;
+	*mp = msg;
 	return (0);
 }
 
 int
 nni_lmq_resize(nni_lmq *lmq, size_t cap)
 {
-	nng_msg * msg;
-	nng_msg **newq;
+	nng_msg  *msg;
+	nng_msg **new_q;
 	size_t    alloc;
 	size_t    len;
 
@@ -132,21 +129,22 @@ nni_lmq_resize(nni_lmq *lmq, size_t cap)
 		alloc *= 2;
 	}
 
-	newq = nni_alloc(sizeof(nng_msg *) * alloc);
-	if (newq == NULL) {
+	if ((new_q = nni_alloc(sizeof(nng_msg *) * alloc)) == NULL) {
 		return (NNG_ENOMEM);
 	}
 
 	len = 0;
-	while ((len < cap) && (nni_lmq_getq(lmq, &msg) == 0)) {
-		newq[len++] = msg;
+	while ((len < cap) && (nni_lmq_get(lmq, &msg) == 0)) {
+		new_q[len++] = msg;
 	}
 
 	// Flush anything left over.
 	nni_lmq_flush(lmq);
 
-	nni_free(lmq->lmq_msgs, lmq->lmq_alloc * sizeof(nng_msg *));
-	lmq->lmq_msgs  = newq;
+	if (lmq->lmq_alloc > 0) {
+		nni_free(lmq->lmq_msgs, lmq->lmq_alloc * sizeof(nng_msg *));
+	}
+	lmq->lmq_msgs  = new_q;
 	lmq->lmq_cap   = cap;
 	lmq->lmq_alloc = alloc;
 	lmq->lmq_mask  = alloc - 1;
diff --git a/src/core/lmq.h b/src/core/lmq.h
index 0a64c98..e38a744 100644
--- a/src/core/lmq.h
+++ b/src/core/lmq.h
@@ -1,5 +1,5 @@
 //
-// Copyright 2019 Staysail Systems, Inc. <info@staysail.tech>
+// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
 //
 // This software is supplied under the terms of the MIT License, a
 // copy of which should be located in the distribution where this
@@ -23,15 +23,16 @@ typedef struct nni_lmq {
 	size_t    lmq_get;
 	size_t    lmq_put;
 	nng_msg **lmq_msgs;
+	nng_msg  *lmq_buf[2]; // default minimal buffer
 } nni_lmq;
 
-extern int    nni_lmq_init(nni_lmq *, size_t);
+extern void   nni_lmq_init(nni_lmq *, size_t);
 extern void   nni_lmq_fini(nni_lmq *);
 extern void   nni_lmq_flush(nni_lmq *);
 extern size_t nni_lmq_len(nni_lmq *);
 extern size_t nni_lmq_cap(nni_lmq *);
-extern int    nni_lmq_putq(nni_lmq *, nng_msg *);
-extern int    nni_lmq_getq(nni_lmq *, nng_msg **);
+extern int    nni_lmq_put(nni_lmq *lmq, nng_msg *msg);
+extern int    nni_lmq_get(nni_lmq *lmq, nng_msg **mp);
 extern int    nni_lmq_resize(nni_lmq *, size_t);
 extern bool   nni_lmq_full(nni_lmq *);
 extern bool   nni_lmq_empty(nni_lmq *);
diff --git a/src/core/message.c b/src/core/message.c
index 2ff2d6d..b819daf 100644
--- a/src/core/message.c
+++ b/src/core/message.c
@@ -273,7 +273,7 @@ nni_chunk_insert(nni_chunk *ch, const void *data, size_t len)
 		ch->ch_ptr -= len;
 	} else if ((ch->ch_len + len) <= ch->ch_cap) {
 		// We had enough capacity, just shuffle data down.
-		memmove(ch->ch_ptr + len, ch->ch_ptr, ch->ch_len);
+		memmove(ch->ch_buf + len, ch->ch_ptr, ch->ch_len);
 	} else if ((rv = nni_chunk_grow(ch, 0, len)) == 0) {
 		// We grew the chunk, so adjust.
 		ch->ch_ptr -= len;
diff --git a/src/core/message_test.c b/src/core/message_test.c
index 0f92049..20813c6 100644
--- a/src/core/message_test.c
+++ b/src/core/message_test.c
@@ -19,7 +19,6 @@ test_msg_option(void)
 {
 	nng_msg *msg;
 	NUTS_PASS(nng_msg_alloc(&msg, 0));
-	NUTS_FAIL(nng_msg_getopt(msg, 0, NULL, NULL), NNG_ENOTSUP);
 	nng_msg_free(msg);
 }
 
@@ -62,8 +61,9 @@ test_msg_insert_body(void)
 	NUTS_PASS(nng_msg_alloc(&msg, 0));
 	NUTS_PASS(nng_msg_append(msg, "xyz", 4));
 	NUTS_PASS(nng_msg_insert(msg, "uvw", 3));
-	NUTS_ASSERT(nng_msg_len(msg) == 7);
-	NUTS_ASSERT(strcmp(nng_msg_body(msg), "uvwxyz") == 0);
+	NUTS_PASS(nng_msg_insert(msg, "st", 2));
+	NUTS_ASSERT(nng_msg_len(msg) == 9);
+	NUTS_ASSERT(strcmp(nng_msg_body(msg), "stuvwxyz") == 0);
 	nng_msg_free(msg);
 }
 
diff --git a/src/core/msgqueue.c b/src/core/msgqueue.c
index 2d767d4..116f090 100644
--- a/src/core/msgqueue.c
+++ b/src/core/msgqueue.c
@@ -1,5 +1,5 @@
 //
-// Copyright 2020 Staysail Systems, Inc. <info@staysail.tech>
+// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
 // Copyright 2018 Capitar IT Group BV <info@capitar.com>
 //
 // This software is supplied under the terms of the MIT License, a
@@ -17,11 +17,11 @@
 
 struct nni_msgq {
 	nni_mtx   mq_lock;
-	int       mq_cap;
-	int       mq_alloc; // alloc is cap + 2...
-	int       mq_len;
-	int       mq_get;
-	int       mq_put;
+	unsigned  mq_cap;
+	unsigned  mq_alloc; // alloc is cap + 2...
+	unsigned  mq_len;
+	unsigned  mq_get;
+	unsigned  mq_put;
 	bool      mq_closed;
 	nni_msg **mq_msgs;
 
@@ -29,8 +29,8 @@ struct nni_msgq {
 	nni_list mq_aio_getq;
 
 	// Pollable status.
-	nni_pollable *mq_sendable;
-	nni_pollable *mq_recvable;
+	nni_pollable mq_sendable;
+	nni_pollable mq_recvable;
 };
 
 static void nni_msgq_run_notify(nni_msgq *);
@@ -39,7 +39,7 @@ int
 nni_msgq_init(nni_msgq **mqp, unsigned cap)
 {
 	struct nni_msgq *mq;
-	int              alloc;
+	unsigned         alloc;
 
 	// We allocate 2 extra cells in the fifo.  One to accommodate a
 	// waiting writer when cap == 0. (We can "briefly" move the message
@@ -58,15 +58,16 @@ nni_msgq_init(nni_msgq **mqp, unsigned cap)
 	nni_aio_list_init(&mq->mq_aio_putq);
 	nni_aio_list_init(&mq->mq_aio_getq);
 	nni_mtx_init(&mq->mq_lock);
-	mq->mq_cap      = cap;
-	mq->mq_alloc    = alloc;
-	mq->mq_recvable = NULL;
-	mq->mq_sendable = NULL;
-	mq->mq_len      = 0;
-	mq->mq_get      = 0;
-	mq->mq_put      = 0;
-	mq->mq_closed   = 0;
-	*mqp            = mq;
+	nni_pollable_init(&mq->mq_recvable);
+	nni_pollable_init(&mq->mq_sendable);
+
+	mq->mq_cap    = cap;
+	mq->mq_alloc  = alloc;
+	mq->mq_len    = 0;
+	mq->mq_get    = 0;
+	mq->mq_put    = 0;
+	mq->mq_closed = 0;
+	*mqp          = mq;
 
 	return (0);
 }
@@ -89,12 +90,8 @@ nni_msgq_fini(nni_msgq *mq)
 		nni_msg_free(msg);
 	}
 
-	if (mq->mq_sendable) {
-		nni_pollable_free(mq->mq_sendable);
-	}
-	if (mq->mq_recvable) {
-		nni_pollable_free(mq->mq_recvable);
-	}
+	nni_pollable_fini(&mq->mq_sendable);
+	nni_pollable_fini(&mq->mq_recvable);
 
 	nni_free(mq->mq_msgs, mq->mq_alloc * sizeof(nng_msg *));
 	NNI_FREE_STRUCT(mq);
@@ -188,14 +185,14 @@ static void
 nni_msgq_run_notify(nni_msgq *mq)
 {
 	if (mq->mq_len < mq->mq_cap || !nni_list_empty(&mq->mq_aio_getq)) {
-		nni_pollable_raise(mq->mq_sendable);
+		nni_pollable_raise(&mq->mq_sendable);
 	} else {
-		nni_pollable_clear(mq->mq_sendable);
+		nni_pollable_clear(&mq->mq_sendable);
 	}
 	if ((mq->mq_len != 0) || !nni_list_empty(&mq->mq_aio_putq)) {
-		nni_pollable_raise(mq->mq_recvable);
+		nni_pollable_raise(&mq->mq_recvable);
 	} else {
-		nni_pollable_clear(mq->mq_recvable);
+		nni_pollable_clear(&mq->mq_recvable);
 	}
 }
 
@@ -335,7 +332,7 @@ nni_msgq_cap(nni_msgq *mq)
 	int rv;
 
 	nni_mtx_lock(&mq->mq_lock);
-	rv = mq->mq_cap;
+	rv = (int) mq->mq_cap;
 	nni_mtx_unlock(&mq->mq_lock);
 	return (rv);
 }
@@ -343,12 +340,12 @@ nni_msgq_cap(nni_msgq *mq)
 int
 nni_msgq_resize(nni_msgq *mq, int cap)
 {
-	int       alloc;
-	nni_msg * msg;
+	unsigned  alloc;
+	nni_msg  *msg;
 	nni_msg **newq, **oldq;
-	int       oldget;
-	int       oldlen;
-	int       oldalloc;
+	unsigned  oldget;
+	unsigned  oldlen;
+	unsigned  oldalloc;
 
 	alloc = cap + 2;
 
@@ -362,7 +359,7 @@ nni_msgq_resize(nni_msgq *mq, int cap)
 	}
 
 	nni_mtx_lock(&mq->mq_lock);
-	while (mq->mq_len > (cap + 1)) {
+	while (mq->mq_len > ((unsigned)cap + 1)) {
 		// too many messages -- we allow that one for
 		// the case of pushback or cap == 0.
 		// we delete the oldest messages first
@@ -412,17 +409,10 @@ int
 nni_msgq_get_recvable(nni_msgq *mq, nni_pollable **sp)
 {
 	nni_mtx_lock(&mq->mq_lock);
-	if (mq->mq_recvable == NULL) {
-		int rv;
-		if ((rv = nni_pollable_alloc(&mq->mq_recvable)) != 0) {
-			nni_mtx_unlock(&mq->mq_lock);
-			return (rv);
-		}
-		nni_msgq_run_notify(mq);
-	}
+	nni_msgq_run_notify(mq);
 	nni_mtx_unlock(&mq->mq_lock);
 
-	*sp = mq->mq_recvable;
+	*sp = &mq->mq_recvable;
 	return (0);
 }
 
@@ -430,16 +420,9 @@ int
 nni_msgq_get_sendable(nni_msgq *mq, nni_pollable **sp)
 {
 	nni_mtx_lock(&mq->mq_lock);
-	if (mq->mq_sendable == NULL) {
-		int rv;
-		if ((rv = nni_pollable_alloc(&mq->mq_sendable)) != 0) {
-			nni_mtx_unlock(&mq->mq_lock);
-			return (rv);
-		}
-		nni_msgq_run_notify(mq);
-	}
+	nni_msgq_run_notify(mq);
 	nni_mtx_unlock(&mq->mq_lock);
 
-	*sp = mq->mq_sendable;
+	*sp = &mq->mq_sendable;
 	return (0);
 }
diff --git a/src/core/pipe.c b/src/core/pipe.c
index a2b6411..36b77d9 100644
--- a/src/core/pipe.c
+++ b/src/core/pipe.c
@@ -1,5 +1,5 @@
 //
-// Copyright 2020 Staysail Systems, Inc. <info@staysail.tech>
+// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
 // Copyright 2018 Capitar IT Group BV <info@capitar.com>
 // Copyright 2018 Devolutions <info@devolutions.net>
 //
@@ -14,13 +14,14 @@
 
 #include <stdio.h>
 
-// This file contains functions relating to pipes.
+// This file contains functions related to pipe objects.
 //
 // Operations on pipes (to the transport) are generally blocking operations,
 // performed in the context of the protocol.
 
-static nni_id_map pipes;
-static nni_mtx    pipes_lk;
+static nni_id_map pipes =
+    NNI_ID_MAP_INITIALIZER(1, 0x7fffffff, NNI_ID_FLAG_RANDOM);
+static nni_mtx pipes_lk = NNI_MTX_INITIALIZER;
 
 static void pipe_destroy(void *);
 
@@ -29,26 +30,6 @@ static nni_reap_list pipe_reap_list = {
 	.rl_func   = pipe_destroy,
 };
 
-int
-nni_pipe_sys_init(void)
-{
-	nni_mtx_init(&pipes_lk);
-
-	// Pipe IDs needs to have high order bit clear, and we want
-	// them to start at a random value.
-	nni_id_map_init(&pipes, 1, 0x7fffffff, true);
-
-	return (0);
-}
-
-void
-nni_pipe_sys_fini(void)
-{
-	nni_reap_drain();
-	nni_mtx_fini(&pipes_lk);
-	nni_id_map_fini(&pipes);
-}
-
 static void
 pipe_destroy(void *arg)
 {
@@ -90,7 +71,6 @@ pipe_destroy(void *arg)
 		p->p_tran_ops.p_fini(p->p_tran_data);
 	}
 	nni_cv_fini(&p->p_cv);
-	nni_mtx_fini(&p->p_mtx);
 	nni_free(p, p->p_size);
 }
 
@@ -148,14 +128,9 @@ nni_pipe_send(nni_pipe *p, nni_aio *aio)
 void
 nni_pipe_close(nni_pipe *p)
 {
-	nni_mtx_lock(&p->p_mtx);
-	if (p->p_closed) {
-		// We already did a close.
-		nni_mtx_unlock(&p->p_mtx);
-		return;
+	if (nni_atomic_swap_bool(&p->p_closed, true)) {
+		return; // We already did a close.
 	}
-	p->p_closed = true;
-	nni_mtx_unlock(&p->p_mtx);
 
 	if (p->p_proto_data != NULL) {
 		p->p_proto_ops.pipe_close(p->p_proto_data);
@@ -169,6 +144,12 @@ nni_pipe_close(nni_pipe *p)
 	nni_reap(&pipe_reap_list, p);
 }
 
+bool
+nni_pipe_is_closed(nni_pipe *p)
+{
+	return (nni_atomic_get_bool(&p->p_closed));
+}
+
 uint16_t
 nni_pipe_peer(nni_pipe *p)
 {
@@ -245,37 +226,36 @@ pipe_stats_init(nni_pipe *p)
 #endif // NNG_ENABLE_STATS
 
 static int
-pipe_create(nni_pipe **pp, nni_sock *sock, nni_sp_tran *tran, void *tdata)
+pipe_create(nni_pipe **pp, nni_sock *sock, nni_sp_tran *tran, void *tran_data)
 {
-	nni_pipe *          p;
+	nni_pipe           *p;
 	int                 rv;
-	void *              sdata = nni_sock_proto_data(sock);
-	nni_proto_pipe_ops *pops  = nni_sock_proto_pipe_ops(sock);
+	void               *sock_data = nni_sock_proto_data(sock);
+	nni_proto_pipe_ops *pops      = nni_sock_proto_pipe_ops(sock);
 	size_t              sz;
 
 	sz = NNI_ALIGN_UP(sizeof(*p)) + pops->pipe_size;
 
 	if ((p = nni_zalloc(sz)) == NULL) {
 		// In this case we just toss the pipe...
-		tran->tran_pipe->p_fini(tdata);
+		tran->tran_pipe->p_fini(tran_data);
 		return (NNG_ENOMEM);
 	}
 
 	p->p_size       = sz;
 	p->p_proto_data = p + 1;
 	p->p_tran_ops   = *tran->tran_pipe;
-	p->p_tran_data  = tdata;
+	p->p_tran_data  = tran_data;
 	p->p_proto_ops  = *pops;
 	p->p_sock       = sock;
-	p->p_closed     = false;
 	p->p_cbs        = false;
 	p->p_ref        = 0;
 
+	nni_atomic_init_bool(&p->p_closed);
 	nni_atomic_flag_reset(&p->p_stop);
 	NNI_LIST_NODE_INIT(&p->p_sock_node);
 	NNI_LIST_NODE_INIT(&p->p_ep_node);
 
-	nni_mtx_init(&p->p_mtx);
 	nni_cv_init(&p->p_cv, &pipes_lk);
 
 	nni_mtx_lock(&pipes_lk);
@@ -288,8 +268,8 @@ pipe_create(nni_pipe **pp, nni_sock *sock, nni_sp_tran *tran, void *tdata)
 	pipe_stats_init(p);
 #endif
 
-	if ((rv != 0) || ((rv = p->p_tran_ops.p_init(tdata, p)) != 0) ||
-	    ((rv = pops->pipe_init(p->p_proto_data, p, sdata)) != 0)) {
+	if ((rv != 0) || ((rv = p->p_tran_ops.p_init(tran_data, p)) != 0) ||
+	    ((rv = pops->pipe_init(p->p_proto_data, p, sock_data)) != 0)) {
 		nni_pipe_close(p);
 		nni_pipe_rele(p);
 		return (rv);
@@ -300,13 +280,13 @@ pipe_create(nni_pipe **pp, nni_sock *sock, nni_sp_tran *tran, void *tdata)
 }
 
 int
-nni_pipe_create_dialer(nni_pipe **pp, nni_dialer *d, void *tdata)
+nni_pipe_create_dialer(nni_pipe **pp, nni_dialer *d, void *tran_data)
 {
 	int          rv;
 	nni_sp_tran *tran = d->d_tran;
-	nni_pipe *   p;
+	nni_pipe    *p;
 
-	if ((rv = pipe_create(&p, d->d_sock, tran, tdata)) != 0) {
+	if ((rv = pipe_create(&p, d->d_sock, tran, tran_data)) != 0) {
 		return (rv);
 	}
 	p->p_dialer = d;
@@ -324,13 +304,13 @@ nni_pipe_create_dialer(nni_pipe **pp, nni_dialer *d, void *tdata)
 }
 
 int
-nni_pipe_create_listener(nni_pipe **pp, nni_listener *l, void *tdata)
+nni_pipe_create_listener(nni_pipe **pp, nni_listener *l, void *tran_data)
 {
 	int          rv;
 	nni_sp_tran *tran = l->l_tran;
-	nni_pipe *   p;
+	nni_pipe    *p;
 
-	if ((rv = pipe_create(&p, l->l_sock, tran, tdata)) != 0) {
+	if ((rv = pipe_create(&p, l->l_sock, tran, tran_data)) != 0) {
 		return (rv);
 	}
 	p->p_listener = l;
@@ -399,26 +379,26 @@ nni_pipe_add_stat(nni_pipe *p, nni_stat_item *item)
 }
 
 void
-nni_pipe_bump_rx(nni_pipe *p, size_t nbytes)
+nni_pipe_bump_rx(nni_pipe *p, size_t bytes)
 {
 #ifdef NNG_ENABLE_STATS
-	nni_stat_inc(&p->st_rx_bytes, nbytes);
+	nni_stat_inc(&p->st_rx_bytes, bytes);
 	nni_stat_inc(&p->st_rx_msgs, 1);
 #else
 	NNI_ARG_UNUSED(p);
-	NNI_ARG_UNUSED(nbytes);
+	NNI_ARG_UNUSED(bytes);
 #endif
 }
 
 void
-nni_pipe_bump_tx(nni_pipe *p, size_t nbytes)
+nni_pipe_bump_tx(nni_pipe *p, size_t bytes)
 {
 #ifdef NNG_ENABLE_STATS
-	nni_stat_inc(&p->st_tx_bytes, nbytes);
+	nni_stat_inc(&p->st_tx_bytes, bytes);
 	nni_stat_inc(&p->st_tx_msgs, 1);
 #else
 	NNI_ARG_UNUSED(p);
-	NNI_ARG_UNUSED(nbytes);
+	NNI_ARG_UNUSED(bytes);
 #endif
 }
 
diff --git a/src/core/pipe.h b/src/core/pipe.h
index fe90893..458a42d 100644
--- a/src/core/pipe.h
+++ b/src/core/pipe.h
@@ -1,5 +1,5 @@
 //
-// Copyright 2019 Staysail Systems, Inc. <info@staysail.tech>
+// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
 // Copyright 2018 Capitar IT Group BV <info@capitar.com>
 //
 // This software is supplied under the terms of the MIT License, a
@@ -12,16 +12,13 @@
 #define CORE_PIPE_H
 
 // NB: This structure is supplied here for use by the CORE. Use of this
-// OUSIDE of the core is STRICTLY VERBOTEN.  NO DIRECT ACCESS BY PROTOCOLS OR
+// OUTSIDE of the core is STRICTLY VERBOTEN.  NO DIRECT ACCESS BY PROTOCOLS OR
 // TRANSPORTS.
 
 #include "core/defs.h"
 #include "core/thread.h"
 #include "sp/transport.h"
 
-extern int  nni_pipe_sys_init(void);
-extern void nni_pipe_sys_fini(void);
-
 // AIO
 extern void nni_pipe_recv(nni_pipe *, nni_aio *);
 extern void nni_pipe_send(nni_pipe *, nni_aio *);
@@ -34,7 +31,6 @@ extern uint32_t nni_pipe_id(nni_pipe *);
 // actual pipe will be reaped asynchronously.
 extern void nni_pipe_close(nni_pipe *);
 
-extern uint16_t nni_pipe_proto(nni_pipe *);
 extern uint16_t nni_pipe_peer(nni_pipe *);
 
 // nni_pipe_getopt looks up the option.  The last argument is the type,
diff --git a/src/core/platform.h b/src/core/platform.h
index f1127c5..8975992 100644
--- a/src/core/platform.h
+++ b/src/core/platform.h
@@ -232,6 +232,11 @@ extern void nni_atomic_inc(nni_atomic_int *);
 // true if the value was set.
 extern bool nni_atomic_cas(nni_atomic_int *, int, int);
 
+// atomic pointers.  We only support a few operations.
+typedef struct nni_atomic_ptr nni_atomic_ptr;
+extern void nni_atomic_set_ptr(nni_atomic_ptr *, void *);
+extern void *nni_atomic_get_ptr(nni_atomic_ptr *);
+
 //
 // Clock Support
 //
diff --git a/src/core/pollable.c b/src/core/pollable.c
index fb6af0f..8e5ad7c 100644
--- a/src/core/pollable.c
+++ b/src/core/pollable.c
@@ -1,5 +1,5 @@
 //
-// Copyright 2020 Staysail Systems, Inc. <info@staysail.tech>
+// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
 // Copyright 2018 Capitar IT Group BV <info@capitar.com>
 //
 // This software is supplied under the terms of the MIT License, a
@@ -38,34 +38,9 @@ nni_pollable_fini(nni_pollable *p)
 	}
 }
 
-int
-nni_pollable_alloc(nni_pollable **pp)
-{
-	nni_pollable *p;
-	if ((p = NNI_ALLOC_STRUCT(p)) == NULL) {
-		return (NNG_ENOMEM);
-	}
-	nni_pollable_init(p);
-	*pp = p;
-	return (0);
-}
-
-void
-nni_pollable_free(nni_pollable *p)
-{
-	if (p == NULL) {
-		return;
-	}
-	nni_pollable_fini(p);
-	NNI_FREE_STRUCT(p);
-}
-
 void
 nni_pollable_raise(nni_pollable *p)
 {
-	if (p == NULL) {
-		return;
-	}
 	if (!nni_atomic_swap_bool(&p->p_raised, true)) {
 		uint64_t fds;
 		if ((fds = nni_atomic_get64(&p->p_fds)) != (uint64_t) -1) {
@@ -77,9 +52,6 @@ nni_pollable_raise(nni_pollable *p)
 void
 nni_pollable_clear(nni_pollable *p)
 {
-	if (p == NULL) {
-		return;
-	}
 	if (nni_atomic_swap_bool(&p->p_raised, false)) {
 		uint64_t fds;
 		if ((fds = nni_atomic_get64(&p->p_fds)) != (uint64_t) -1) {
diff --git a/src/core/pollable.h b/src/core/pollable.h
index a71a969..2dcce0a 100644
--- a/src/core/pollable.h
+++ b/src/core/pollable.h
@@ -1,5 +1,5 @@
 //
-// Copyright 2020 Staysail Systems, Inc. <info@staysail.tech>
+// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
 //
 // This software is supplied under the terms of the MIT License, a
 // copy of which should be located in the distribution where this
@@ -15,15 +15,13 @@
 
 typedef struct nni_pollable nni_pollable;
 
-extern int  nni_pollable_alloc(nni_pollable **);
-extern void nni_pollable_free(nni_pollable *);
 extern void nni_pollable_raise(nni_pollable *);
 extern void nni_pollable_clear(nni_pollable *);
 extern int  nni_pollable_getfd(nni_pollable *, int *);
 
 // nni_pollable implementation details are private.  Only here for inlining.
-// We have joined to the write and read file descriptors into a a single
-// atomic 64 so we can update them together (and we can use cas to be sure
+// We have joined the write and read file descriptors into a single
+// atomic 64, so we can update them together (and we can use cas to be sure
 // that such updates are always safe.)
 struct nni_pollable {
 	nni_atomic_u64  p_fds;
diff --git a/src/core/protocol.h b/src/core/protocol.h
index a864576..6118a2a 100644
--- a/src/core/protocol.h
+++ b/src/core/protocol.h
@@ -63,7 +63,7 @@ struct nni_proto_ctx_ops {
 
 	// ctx_init initializes a new context. The second argument is the
 	// protocol specific socket structure.
-	int (*ctx_init)(void *, void *);
+	void (*ctx_init)(void *, void *);
 
 	// ctx_fini destroys a context.
 	void (*ctx_fini)(void *);
@@ -85,7 +85,7 @@ struct nni_proto_sock_ops {
 
 	// sock_init initializes the protocol instance, which will be stored
 	// on the socket. This is run without the sock lock held.
-	int (*sock_init)(void *, nni_sock *);
+	void (*sock_init)(void *, nni_sock *);
 
 	// sock_fini destroys the protocol instance.  This is run without the
 	// socket lock held, and is intended to release resources.  It may
diff --git a/src/core/reap.c b/src/core/reap.c
index 8be5ee1..3f18220 100644
--- a/src/core/reap.c
+++ b/src/core/reap.c
@@ -1,5 +1,5 @@
 //
-// Copyright 2020 Staysail Systems, Inc. <info@staysail.tech>
+// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
 // Copyright 2017 Capitar IT Group BV <info@capitar.com>
 //
 // This software is supplied under the terms of the MIT License, a
@@ -17,11 +17,11 @@
 // New stuff.
 static nni_reap_list *reap_list = NULL;
 static nni_thr        reap_thr;
-static bool           reap_exit;
-static nni_mtx        reap_mtx;
+static bool           reap_exit = false;
+static nni_mtx        reap_mtx = NNI_MTX_INITIALIZER;
 static bool           reap_empty;
-static nni_cv         reap_work_cv;
-static nni_cv         reap_empty_cv;
+static nni_cv         reap_work_cv = NNI_CV_INITIALIZER(&reap_mtx);
+static nni_cv         reap_empty_cv = NNI_CV_INITIALIZER(&reap_mtx);
 
 static void
 reap_worker(void *unused)
@@ -105,17 +105,9 @@ nni_reap_sys_init(void)
 {
 	int rv;
 
-	reap_exit = false;
-	nni_mtx_init(&reap_mtx);
-	nni_cv_init(&reap_work_cv, &reap_mtx);
-	nni_cv_init(&reap_empty_cv, &reap_mtx);
-
 	// If this fails, we don't fail init, instead we will try to
 	// start up at reap time.
 	if ((rv = nni_thr_init(&reap_thr, reap_worker, NULL)) != 0) {
-		nni_cv_fini(&reap_work_cv);
-		nni_cv_fini(&reap_empty_cv);
-		nni_mtx_fini(&reap_mtx);
 		return (rv);
 	}
 	nni_thr_run(&reap_thr);
diff --git a/src/core/sock_test.c b/src/core/sock_test.c
index 9edfbf5..fbf7053 100644
--- a/src/core/sock_test.c
+++ b/src/core/sock_test.c
@@ -161,7 +161,7 @@ test_socket_name_oversize(void)
 	NUTS_PASS(nng_socket_set(s1, NNG_OPT_SOCKNAME, name, sz));
 	sz = sizeof(name);
 	memset(name, 'B', sz);
-	NUTS_PASS(nng_getopt(s1, NNG_OPT_SOCKNAME, name, &sz));
+	NUTS_PASS(nng_socket_get(s1, NNG_OPT_SOCKNAME, name, &sz));
 	NUTS_TRUE(sz == 6);
 	NUTS_MATCH(name, "hello");
 	NUTS_CLOSE(s1);
@@ -222,7 +222,7 @@ test_send_recv_zero_length(void)
 	NUTS_OPEN(s2);
 
 	NUTS_PASS(nng_socket_set_int(s1, NNG_OPT_RECVBUF, 1));
-	NUTS_PASS(nng_getopt_int(s1, NNG_OPT_RECVBUF, &len));
+	NUTS_PASS(nng_socket_get_int(s1, NNG_OPT_RECVBUF, &len));
 	NUTS_TRUE(len == 1);
 
 	NUTS_PASS(nng_socket_set_int(s1, NNG_OPT_SENDBUF, 1));
diff --git a/src/core/socket.c b/src/core/socket.c
index e8b1211..ed22391 100644
--- a/src/core/socket.c
+++ b/src/core/socket.c
@@ -1,5 +1,5 @@
 //
-// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
+// Copyright 2022 Staysail Systems, Inc. <info@staysail.tech>
 // Copyright 2018 Capitar IT Group BV <info@capitar.com>
 //
 // This software is supplied under the terms of the MIT License, a
@@ -16,17 +16,11 @@
 
 // Socket implementation.
 
-static nni_list   sock_list;
-static nni_id_map sock_ids;
-static nni_mtx    sock_lk;
-static nni_id_map ctx_ids;
-static bool       inited;
-
 struct nni_ctx {
 	nni_list_node     c_node;
-	nni_sock *        c_sock;
+	nni_sock         *c_sock;
 	nni_proto_ctx_ops c_ops;
-	void *            c_data;
+	void	     *c_data;
 	size_t            c_size;
 	bool              c_closed;
 	unsigned          c_ref; // protected by global lock
@@ -37,15 +31,15 @@ struct nni_ctx {
 
 typedef struct nni_sockopt {
 	nni_list_node node;
-	char *        name;
+	char         *name;
 	nni_type      typ;
 	size_t        sz;
-	void *        data;
+	void         *data;
 } nni_sockopt;
 
 typedef struct nni_sock_pipe_cb {
 	nng_pipe_cb cb_fn;
-	void *      cb_arg;
+	void       *cb_arg;
 } nni_sock_pipe_cb;
 
 struct nni_socket {
@@ -57,7 +51,7 @@ struct nni_socket {
 	uint32_t s_id;
 	uint32_t s_flags;
 	unsigned s_ref;  // protected by global lock
-	void *   s_data; // Protocol private
+	void    *s_data; // Protocol private
 	size_t   s_size;
 
 	nni_msgq *s_uwq; // Upper write queue
@@ -107,6 +101,11 @@ struct nni_socket {
 #endif
 };
 
+static nni_list sock_list  = NNI_LIST_INITIALIZER(sock_list, nni_sock, s_node);
+static nni_mtx  sock_lk    = NNI_MTX_INITIALIZER;
+static nni_id_map sock_ids = NNI_ID_MAP_INITIALIZER(1, 0x7fffffff, 0);
+static nni_id_map ctx_ids  = NNI_ID_MAP_INITIALIZER(1, 0x7fffffff, 0);
+
 static void nni_ctx_destroy(nni_ctx *);
 
 #define SOCK(s) ((nni_sock *) (s))
@@ -238,8 +237,15 @@ sock_get_sockname(void *s, void *buf, size_t *szp, nni_type t)
 static int
 sock_set_sockname(void *s, const void *buf, size_t sz, nni_type t)
 {
-	return (nni_copyin_str(
+	int rv;
+	rv = (nni_copyin_str(
 	    SOCK(s)->s_name, buf, sizeof(SOCK(s)->s_name), sz, t));
+#ifdef NNG_ENABLE_STATS
+	if (rv == 0) {
+		nni_stat_set_string(&SOCK(s)->st_name, SOCK(s)->s_name);
+	}
+#endif
+	return (rv);
 }
 
 static int
@@ -379,6 +385,14 @@ nni_sock_find(nni_sock **sockp, uint32_t id)
 	return (rv);
 }
 
+void
+nni_sock_hold(nni_sock *s)
+{
+	nni_mtx_lock(&sock_lk);
+	s->s_ref++;
+	nni_mtx_unlock(&sock_lk);
+}
+
 void
 nni_sock_rele(nni_sock *s)
 {
@@ -578,25 +592,26 @@ nni_sock_create(nni_sock **sp, const nni_proto *proto)
 #endif
 
 	if (((rv = nni_msgq_init(&s->s_uwq, 0)) != 0) ||
-	    ((rv = nni_msgq_init(&s->s_urq, 1)) != 0) ||
-	    ((rv = s->s_sock_ops.sock_init(s->s_data, s)) != 0) ||
-	    ((rv = nni_sock_setopt(s, NNG_OPT_SENDTIMEO, &s->s_sndtimeo,
-	          sizeof(nni_duration), NNI_TYPE_DURATION)) != 0) ||
-	    ((rv = nni_sock_setopt(s, NNG_OPT_RECVTIMEO, &s->s_rcvtimeo,
-	          sizeof(nni_duration), NNI_TYPE_DURATION)) != 0) ||
-	    ((rv = nni_sock_setopt(s, NNG_OPT_RECONNMINT, &s->s_reconn,
-	          sizeof(nni_duration), NNI_TYPE_DURATION)) != 0) ||
-	    ((rv = nni_sock_setopt(s, NNG_OPT_RECONNMAXT, &s->s_reconnmax,
-	          sizeof(nni_duration), NNI_TYPE_DURATION)) != 0) ||
-	    ((rv = nni_sock_setopt(s, NNG_OPT_RECVMAXSZ, &s->s_rcvmaxsz,
-	          sizeof(size_t), NNI_TYPE_SIZE)) != 0)) {
+	    ((rv = nni_msgq_init(&s->s_urq, 1)) != 0)) {
 		sock_destroy(s);
 		return (rv);
 	}
+	s->s_sock_ops.sock_init(s->s_data, s);
 
-	// These we *attempt* to call so that we are likely to have initial
+	// These we *attempt* to set so that we are likely to have initial
 	// values loaded.  They should not fail, but if they do we don't
 	// worry about it.
+	(void) nni_sock_setopt(s, NNG_OPT_SENDTIMEO, &s->s_sndtimeo,
+	    sizeof(nni_duration), NNI_TYPE_DURATION);
+	(void) nni_sock_setopt(s, NNG_OPT_RECVTIMEO, &s->s_rcvtimeo,
+	    sizeof(nni_duration), NNI_TYPE_DURATION);
+	(void) nni_sock_setopt(s, NNG_OPT_RECONNMINT, &s->s_reconn,
+	    sizeof(nni_duration), NNI_TYPE_DURATION);
+	(void) nni_sock_setopt(s, NNG_OPT_RECONNMAXT, &s->s_reconnmax,
+	    sizeof(nni_duration), NNI_TYPE_DURATION);
+	(void) nni_sock_setopt(s, NNG_OPT_RECVMAXSZ, &s->s_rcvmaxsz,
+	    sizeof(size_t), NNI_TYPE_SIZE);
+
 	on = true;
 	(void) nni_sock_setopt(
 	    s, NNG_OPT_TCP_NODELAY, &on, sizeof(on), NNI_TYPE_BOOL);
@@ -608,27 +623,6 @@ nni_sock_create(nni_sock **sp, const nni_proto *proto)
 	return (rv);
 }
 
-int
-nni_sock_sys_init(void)
-{
-	NNI_LIST_INIT(&sock_list, nni_sock, s_node);
-	nni_mtx_init(&sock_lk);
-
-	nni_id_map_init(&sock_ids, 1, 0x7fffffff, false);
-	nni_id_map_init(&ctx_ids, 1, 0x7fffffff, false);
-	inited = true;
-	return (0);
-}
-
-void
-nni_sock_sys_fini(void)
-{
-	nni_id_map_fini(&sock_ids);
-	nni_id_map_fini(&ctx_ids);
-	nni_mtx_fini(&sock_lk);
-	inited = false;
-}
-
 int
 nni_sock_open(nni_sock **sockp, const nni_proto *proto)
 {
@@ -659,8 +653,11 @@ nni_sock_open(nni_sock **sockp, const nni_proto *proto)
 	(void) snprintf(s->s_name, sizeof(s->s_name), "%u", s->s_id);
 
 #ifdef NNG_ENABLE_STATS
-	// Set up basic stat values.
+	// Set up basic stat values.  The socket id wasn't
+	// known at stat creation time, so we set it now.
 	nni_stat_set_id(&s->st_id, (int) s->s_id);
+	nni_stat_set_id(&s->st_root, (int) s->s_id);
+	nni_stat_set_string(&s->st_name, s->s_name);
 
 	// Add our stats chain.
 	nni_stat_register(&s->st_root);
@@ -676,11 +673,11 @@ nni_sock_open(nni_sock **sockp, const nni_proto *proto)
 int
 nni_sock_shutdown(nni_sock *sock)
 {
-	nni_pipe *    pipe;
-	nni_dialer *  d;
+	nni_pipe     *pipe;
+	nni_dialer   *d;
 	nni_listener *l;
-	nni_ctx *     ctx;
-	nni_ctx *     nctx;
+	nni_ctx      *ctx;
+	nni_ctx      *nctx;
 
 	nni_mtx_lock(&sock->s_mx);
 	if (sock->s_closing) {
@@ -823,9 +820,6 @@ nni_sock_closeall(void)
 {
 	nni_sock *s;
 
-	if (!inited) {
-		return;
-	}
 	for (;;) {
 		nni_mtx_lock(&sock_lk);
 		if ((s = nni_list_first(&sock_list)) == NULL) {
@@ -1033,7 +1027,7 @@ nni_sock_setopt(
 		}
 #endif
 
-#if defined(NNG_PLATFORM_POSIX) && !defined(NNG_SUPPRESS_DEPRECATED)
+#if defined(NNG_PLATFORM_POSIX) && !defined(NNG_ELIDE_DEPRECATED)
 	} else if (strcmp(name, NNG_OPT_IPC_PERMISSIONS) == 0) {
 		// UNIX mode bits are 0777, but allow set id and sticky bits
 		if ((rv = nni_copyin_int(NULL, v, sz, 0, 07777, t)) != 0) {
@@ -1041,7 +1035,7 @@ nni_sock_setopt(
 		}
 #endif
 
-#if defined(NNG_PLATFORM_WINDOWS) && !defined(NNG_SUPPRESS_DEPRECATED)
+#if defined(NNG_PLATFORM_WINDOWS) && !defined(NNG_ELIDE_DEPRECATED)
 	} else if (strcmp(name, NNG_OPT_IPC_SECURITY_DESCRIPTOR) == 0) {
 		if ((rv = nni_copyin_ptr(NULL, v, sz, t)) == 0) {
 			return (rv);
@@ -1082,8 +1076,8 @@ nni_sock_setopt(
 		}
 	}
 
-#ifndef NNG_ELIDE_DEPRCATED
-	nni_dialer *  d;
+#ifndef NNG_ELIDE_DEPRECATED
+	nni_dialer   *d;
 	nni_listener *l;
 
 	// Apply the options.  Failure to set any option on any
@@ -1317,12 +1311,7 @@ nni_ctx_open(nni_ctx **ctxp, nni_sock *sock)
 		return (rv);
 	}
 
-	if ((rv = sock->s_ctx_ops.ctx_init(ctx->c_data, sock->s_data)) != 0) {
-		nni_id_remove(&ctx_ids, ctx->c_id);
-		nni_mtx_unlock(&sock_lk);
-		nni_free(ctx, ctx->c_size);
-		return (rv);
-	}
+	sock->s_ctx_ops.ctx_init(ctx->c_data, sock->s_data);
 
 	nni_list_append(&sock->s_ctxs, ctx);
 	nni_mtx_unlock(&sock_lk);
@@ -1375,7 +1364,7 @@ nni_ctx_recv(nni_ctx *ctx, nni_aio *aio)
 int
 nni_ctx_getopt(nni_ctx *ctx, const char *opt, void *v, size_t *szp, nni_type t)
 {
-	nni_sock *  sock = ctx->c_sock;
+	nni_sock   *sock = ctx->c_sock;
 	nni_option *o;
 	int         rv = NNG_ENOTSUP;
 
@@ -1405,7 +1394,7 @@ int
 nni_ctx_setopt(
     nni_ctx *ctx, const char *opt, const void *v, size_t sz, nni_type t)
 {
-	nni_sock *  sock = ctx->c_sock;
+	nni_sock   *sock = ctx->c_sock;
 	nni_option *o;
 	int         rv = NNG_ENOTSUP;
 
@@ -1490,9 +1479,7 @@ nni_dialer_add_pipe(nni_dialer *d, void *tpipe)
 
 	nni_pipe_run_cb(p, NNG_PIPE_EV_ADD_PRE);
 
-	nni_mtx_lock(&s->s_mx);
-	if (p->p_closed) {
-		nni_mtx_unlock(&s->s_mx);
+	if (nni_pipe_is_closed(p)) {
 #ifdef NNG_ENABLE_STATS
 		nni_stat_inc(&d->st_reject, 1);
 		nni_stat_inc(&s->st_rejects, 1);
@@ -1500,8 +1487,8 @@ nni_dialer_add_pipe(nni_dialer *d, void *tpipe)
 		nni_pipe_rele(p);
 		return;
 	}
+
 	if (p->p_proto_ops.pipe_start(p->p_proto_data) != 0) {
-		nni_mtx_unlock(&s->s_mx);
 #ifdef NNG_ENABLE_STATS
 		nni_stat_inc(&d->st_reject, 1);
 		nni_stat_inc(&s->st_rejects, 1);
@@ -1510,8 +1497,9 @@ nni_dialer_add_pipe(nni_dialer *d, void *tpipe)
 		nni_pipe_rele(p);
 		return;
 	}
-	nni_mtx_unlock(&s->s_mx);
 #ifdef NNG_ENABLE_STATS
+	nni_stat_set_id(&p->st_root, (int) p->p_id);
+	nni_stat_set_id(&p->st_id, (int) p->p_id);
 	nni_stat_register(&p->st_root);
 #endif
 	nni_pipe_run_cb(p, NNG_PIPE_EV_ADD_POST);
@@ -1549,7 +1537,7 @@ static void
 dialer_reap(void *arg)
 {
 	nni_dialer *d = arg;
-	nni_sock *  s = d->d_sock;
+	nni_sock   *s = d->d_sock;
 
 #ifdef NNG_ENABLE_STATS
 	nni_stat_unregister(&d->st_root);
@@ -1605,9 +1593,7 @@ nni_listener_add_pipe(nni_listener *l, void *tpipe)
 
 	nni_pipe_run_cb(p, NNG_PIPE_EV_ADD_PRE);
 
-	nni_mtx_lock(&s->s_mx);
-	if (p->p_closed) {
-		nni_mtx_unlock(&s->s_mx);
+	if (nni_pipe_is_closed(p)) {
 #ifdef NNG_ENABLE_STATS
 		nni_stat_inc(&l->st_reject, 1);
 		nni_stat_inc(&s->st_rejects, 1);
@@ -1616,7 +1602,6 @@ nni_listener_add_pipe(nni_listener *l, void *tpipe)
 		return;
 	}
 	if (p->p_proto_ops.pipe_start(p->p_proto_data) != 0) {
-		nni_mtx_unlock(&s->s_mx);
 #ifdef NNG_ENABLE_STATS
 		nni_stat_inc(&l->st_reject, 1);
 		nni_stat_inc(&s->st_rejects, 1);
@@ -1625,8 +1610,9 @@ nni_listener_add_pipe(nni_listener *l, void *tpipe)
 		nni_pipe_rele(p);
 		return;
 	}
-	nni_mtx_unlock(&s->s_mx);
 #ifdef NNG_ENABLE_STATS
+	nni_stat_set_id(&p->st_root, (int) p->p_id);
+	nni_stat_set_id(&p->st_id, (int) p->p_id);
 	nni_stat_register(&p->st_root);
 #endif
 	nni_pipe_run_cb(p, NNG_PIPE_EV_ADD_POST);
@@ -1663,7 +1649,7 @@ static void
 listener_reap(void *arg)
 {
 	nni_listener *l = arg;
-	nni_sock *    s = l->l_sock;
+	nni_sock     *s = l->l_sock;
 
 #ifdef NNG_ENABLE_STATS
 	nni_stat_unregister(&l->st_root);
@@ -1699,9 +1685,9 @@ nni_listener_reap(nni_listener *l)
 void
 nni_pipe_run_cb(nni_pipe *p, nng_pipe_ev ev)
 {
-	nni_sock *  s = p->p_sock;
+	nni_sock   *s = p->p_sock;
 	nng_pipe_cb cb;
-	void *      arg;
+	void       *arg;
 
 	nni_mtx_lock(&s->s_pipe_cbs_mtx);
 	if (!p->p_cbs) {
@@ -1727,7 +1713,7 @@ nni_pipe_run_cb(nni_pipe *p, nng_pipe_ev ev)
 void
 nni_pipe_remove(nni_pipe *p)
 {
-	nni_sock *  s = p->p_sock;
+	nni_sock   *s = p->p_sock;
 	nni_dialer *d = p->p_dialer;
 
 	nni_mtx_lock(&s->s_mx);
diff --git a/src/core/socket.h b/src/core/socket.h
index c57df99..c4037e9 100644
--- a/src/core/socket.h
+++ b/src/core/socket.h
@@ -1,5 +1,5 @@
 //
-// Copyright 2018 Staysail Systems, Inc. <info@staysail.tech>
+// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
 // Copyright 2018 Capitar IT Group BV <info@capitar.com>
 //
 // This software is supplied under the terms of the MIT License, a
@@ -11,10 +11,8 @@
 #ifndef CORE_SOCKET_H
 #define CORE_SOCKET_H
 
-extern int  nni_sock_sys_init(void);
-extern void nni_sock_sys_fini(void);
-
 extern int         nni_sock_find(nni_sock **, uint32_t);
+extern void        nni_sock_hold(nni_sock *);
 extern void        nni_sock_rele(nni_sock *);
 extern int         nni_sock_open(nni_sock **, const nni_proto *);
 extern void        nni_sock_close(nni_sock *);
@@ -24,7 +22,7 @@ extern uint16_t    nni_sock_proto_id(nni_sock *);
 extern uint16_t    nni_sock_peer_id(nni_sock *);
 extern const char *nni_sock_proto_name(nni_sock *);
 extern const char *nni_sock_peer_name(nni_sock *);
-extern void *      nni_sock_proto_data(nni_sock *);
+extern void       *nni_sock_proto_data(nni_sock *);
 extern void        nni_sock_add_stat(nni_sock *, nni_stat_item *);
 
 extern struct nni_proto_pipe_ops *nni_sock_proto_pipe_ops(nni_sock *);
@@ -33,8 +31,6 @@ extern int nni_sock_setopt(
     nni_sock *, const char *, const void *, size_t, nni_opt_type);
 extern int nni_sock_getopt(
     nni_sock *, const char *, void *, size_t *, nni_opt_type);
-extern int      nni_sock_recvmsg(nni_sock *, nni_msg **, int);
-extern int      nni_sock_sendmsg(nni_sock *, nni_msg *, int);
 extern void     nni_sock_send(nni_sock *, nni_aio *);
 extern void     nni_sock_recv(nni_sock *, nni_aio *);
 extern uint32_t nni_sock_id(nni_sock *);
diff --git a/src/core/sockimpl.h b/src/core/sockimpl.h
index 850a4d8..83cbb87 100644
--- a/src/core/sockimpl.h
+++ b/src/core/sockimpl.h
@@ -104,11 +104,10 @@ struct nni_pipe {
 	nni_sock          *p_sock;
 	nni_dialer        *p_dialer;
 	nni_listener      *p_listener;
-	bool               p_closed;
+	nni_atomic_bool    p_closed;
 	nni_atomic_flag    p_stop;
 	bool               p_cbs;
 	int                p_ref;
-	nni_mtx            p_mtx;
 	nni_cv             p_cv;
 	nni_reap_node      p_reap;
 
@@ -141,6 +140,7 @@ extern void nni_listener_destroy(nni_listener *);
 extern void nni_listener_stop(nni_listener *);
 
 extern void nni_pipe_remove(nni_pipe *);
+extern bool nni_pipe_is_closed(nni_pipe *);
 extern void nni_pipe_run_cb(nni_pipe *, nng_pipe_ev);
 extern int  nni_pipe_create_dialer(nni_pipe **, nni_dialer *, void *);
 extern int  nni_pipe_create_listener(nni_pipe **, nni_listener *, void *);
diff --git a/src/core/stats.c b/src/core/stats.c
index e476507..50f24e2 100644
--- a/src/core/stats.c
+++ b/src/core/stats.c
@@ -1,5 +1,5 @@
 //
-// Copyright 2020 Staysail Systems, Inc. <info@staysail.tech>
+// Copyright 2022 Staysail Systems, Inc. <info@staysail.tech>
 // Copyright 2018 Capitar IT Group BV <info@capitar.com>
 //
 // This software is supplied under the terms of the MIT License, a
@@ -19,21 +19,31 @@ struct nng_stat {
 	const nni_stat_info *s_info;
 	const nni_stat_item *s_item; // Used during snapshot collection
 	nni_list             s_children;
-	nni_stat *           s_parent;
+	nni_stat            *s_parent;
 	nni_list_node        s_node;
 	nni_time             s_timestamp;
 	union {
 		int      sv_id;
 		bool     sv_bool;
 		uint64_t sv_value;
-		char *   sv_string;
+		char    *sv_string;
 	} s_val;
 };
 
 #ifdef NNG_ENABLE_STATS
-static nni_stat_item stats_root;
-static nni_mtx       stats_lock;
-static nni_mtx       stats_val_lock;
+static nni_stat_info stats_root_info = {
+	.si_name = "",
+	.si_desc = "all statistics",
+	.si_type = NNG_STAT_SCOPE,
+};
+
+static nni_stat_item stats_root = {
+	.si_children = NNI_LIST_INITIALIZER(
+	    stats_root.si_children, nni_stat_item, si_node),
+	.si_info = &stats_root_info,
+};
+static nni_mtx stats_lock     = NNI_MTX_INITIALIZER;
+static nni_mtx stats_val_lock = NNI_MTX_INITIALIZER;
 #endif
 
 void
@@ -171,7 +181,7 @@ nni_stat_set_string(nni_stat_item *item, const char *s)
 {
 #ifdef NNG_ENABLE_STATS
 	const nni_stat_info *info = item->si_info;
-	char *               old  = item->si_u.sv_string;
+	char                *old  = item->si_u.sv_string;
 
 	nni_mtx_lock(&stats_val_lock);
 	if ((s != NULL) && (old != NULL) && (strcmp(s, old) == 0)) {
@@ -235,7 +245,7 @@ nng_stats_free(nni_stat *st)
 static int
 stat_make_tree(nni_stat_item *item, nni_stat **sp)
 {
-	nni_stat *     stat;
+	nni_stat      *stat;
 	nni_stat_item *child;
 
 	if ((stat = NNI_ALLOC_STRUCT(stat)) == NULL) {
@@ -266,8 +276,8 @@ stat_update(nni_stat *stat)
 {
 	const nni_stat_item *item = stat->s_item;
 	const nni_stat_info *info = item->si_info;
-	char *               old;
-	char *               str;
+	char                *old;
+	char                *str;
 
 	switch (info->si_type) {
 	case NNG_STAT_SCOPE:
@@ -397,7 +407,6 @@ nng_stat_bool(nni_stat *stat)
 	return (stat->s_val.sv_bool);
 }
 
-
 const char *
 nng_stat_string(nng_stat *stat)
 {
@@ -454,7 +463,7 @@ nng_stat *
 nng_stat_find_scope(nng_stat *stat, const char *name, int id)
 {
 	nng_stat *child;
-	if (stat == NULL) {
+	if (stat == NULL || stat->s_info->si_type != NNG_STAT_SCOPE) {
 		return (NULL);
 	}
 	if ((stat->s_val.sv_id == id) &&
@@ -464,7 +473,7 @@ nng_stat_find_scope(nng_stat *stat, const char *name, int id)
 	}
 	NNI_LIST_FOREACH (&stat->s_children, child) {
 		nng_stat *result;
-		if ((result = nng_stat_find(child, name)) != NULL) {
+		if ((result = nng_stat_find_scope(child, name, id)) != NULL) {
 			return (result);
 		}
 	}
@@ -489,31 +498,6 @@ nng_stat_find_listener(nng_stat *stat, nng_listener l)
 	return (nng_stat_find_scope(stat, "listener", nng_listener_id(l)));
 }
 
-int
-nni_stat_sys_init(void)
-{
-#ifdef NNG_ENABLE_STATS
-	static const nni_stat_info root = {
-		.si_name = "",
-		.si_desc = "all statistics",
-		.si_type = NNG_STAT_SCOPE,
-	};
-	nni_mtx_init(&stats_lock);
-	nni_mtx_init(&stats_val_lock);
-	nni_stat_init(&stats_root, &root);
-#endif
-	return (0);
-}
-
-void
-nni_stat_sys_fini(void)
-{
-#ifdef NNG_ENABLE_STATS
-	nni_mtx_fini(&stats_lock);
-	nni_mtx_fini(&stats_val_lock);
-#endif
-}
-
 #ifdef NNG_ENABLE_STATS
 void
 stat_sprint_scope(nni_stat *stat, char **scope, int *lenp)
@@ -538,10 +522,10 @@ nng_stats_dump(nng_stat *stat)
 #ifdef NNG_ENABLE_STATS
 	static char        buf[128]; // to minimize recursion, not thread safe
 	int                len;
-	char *             scope;
-	char *             indent = "        ";
+	char              *scope;
+	char              *indent = "        ";
 	unsigned long long val;
-	nni_stat *         child;
+	nni_stat          *child;
 
 	switch (nng_stat_type(stat)) {
 	case NNG_STAT_SCOPE:
diff --git a/src/core/stats.h b/src/core/stats.h
index de1879c..e80f18d 100644
--- a/src/core/stats.h
+++ b/src/core/stats.h
@@ -76,7 +76,5 @@ void nni_stat_set_string(nni_stat_item *, const char *);
 void nni_stat_init(nni_stat_item *, const nni_stat_info *);
 void nni_stat_inc(nni_stat_item *, uint64_t);
 void nni_stat_dec(nni_stat_item *, uint64_t);
-int  nni_stat_sys_init(void);
-void nni_stat_sys_fini(void);
 
 #endif // CORE_STATS_H
diff --git a/src/core/stats_test.c b/src/core/stats_test.c
new file mode 100644
index 0000000..ba4198a
--- /dev/null
+++ b/src/core/stats_test.c
@@ -0,0 +1,96 @@
+//
+// Copyright 2022 Staysail Systems, Inc. <info@staysail.tech>
+// Copyright 2018 Capitar IT Group BV <info@capitar.com>
+//
+// This software is supplied under the terms of the MIT License, a
+// copy of which should be located in the distribution where this
+// file was obtained (LICENSE.txt).  A copy of the license may also be
+// found online at https://opensource.org/licenses/MIT.
+//
+
+#include <nuts.h>
+
+#define SECONDS(x) ((x) *1000)
+
+void
+test_stats_socket(void)
+{
+#ifdef NNG_ENABLE_STATS
+	nng_socket s1;
+	nng_socket s2;
+	nng_stat  *st1;
+	nng_stat  *st2;
+	nng_stat *item;
+	nng_stat  *stats;
+
+	NUTS_OPEN(s1);
+	NUTS_OPEN(s2);
+	nng_socket_set_string(s2, NNG_OPT_SOCKNAME, "second");
+	NUTS_MARRY(s1, s2);
+	NUTS_SEND(s1, "ping");
+	NUTS_RECV(s2, "ping");
+
+	nng_stats_get(&stats);
+	NUTS_ASSERT(stats != NULL);
+	st1 = nng_stat_find_socket(stats, s1);
+	st2 = nng_stat_find_socket(stats, s2);
+	NUTS_ASSERT(st1 != NULL);
+	NUTS_ASSERT(st2 != NULL);
+	NUTS_ASSERT(st1 != st2);
+	item = nng_stat_find(st1, "name");
+	NUTS_ASSERT(item != NULL);
+	NUTS_ASSERT(nng_stat_string(item) != NULL);
+	NUTS_MATCH(nng_stat_string(item), "1");
+	item = nng_stat_find(st2, "name");
+	NUTS_ASSERT(item != NULL);
+	NUTS_ASSERT(nng_stat_string(item) != NULL);
+	NUTS_MATCH(nng_stat_string(item), "second");
+	item = nng_stat_find(st1, "tx_msgs");
+	NUTS_ASSERT(item != NULL);
+	NUTS_ASSERT(nng_stat_value(item) == 1);
+	NUTS_ASSERT(nng_stat_unit(item) == NNG_UNIT_MESSAGES);
+	item = nng_stat_find(st2, "rx_msgs");
+	NUTS_ASSERT(item != NULL);
+	NUTS_ASSERT(nng_stat_value(item) == 1);
+	NUTS_ASSERT(nng_stat_unit(item) == NNG_UNIT_MESSAGES);
+	NUTS_CLOSE(s1);
+	NUTS_CLOSE(s2);
+	nng_stats_free(stats);
+#endif
+}
+
+void
+test_stats_dump(void)
+{
+#ifdef NNG_ENABLE_STATS
+	nng_socket s1;
+	nng_socket s2;
+	nng_stat  *st1;
+	nng_stat  *st2;
+	nng_stat  *stats;
+
+	NUTS_OPEN(s1);
+	NUTS_OPEN(s2);
+	nng_socket_set_string(s2, NNG_OPT_SOCKNAME, "second");
+	NUTS_MARRY(s1, s2);
+	NUTS_SEND(s1, "ping");
+	NUTS_RECV(s2, "ping");
+	nng_stats_get(&stats);
+	NUTS_ASSERT(stats != NULL);
+	st1 = nng_stat_find_socket(stats, s1);
+	st2 = nng_stat_find_socket(stats, s2);
+	NUTS_ASSERT(st1 != NULL);
+	NUTS_ASSERT(st2 != NULL);
+	NUTS_ASSERT(st1 != st2);
+	nng_stats_dump(stats);
+	nng_stats_free(stats);
+	NUTS_CLOSE(s1);
+	NUTS_CLOSE(s2);
+#endif
+}
+
+NUTS_TESTS = {
+	{ "socket stats", test_stats_socket },
+	{ "dump stats", test_stats_dump },
+	{ NULL, NULL },
+};
diff --git a/src/core/taskq.c b/src/core/taskq.c
index e06bc26..d914093 100644
--- a/src/core/taskq.c
+++ b/src/core/taskq.c
@@ -1,5 +1,5 @@
 //
-// Copyright 2020 Staysail Systems, Inc. <info@staysail.tech>
+// Copyright 2022 Staysail Systems, Inc. <info@staysail.tech>
 // Copyright 2018 Capitar IT Group BV <info@capitar.com>
 //
 // This software is supplied under the terms of the MIT License, a
@@ -31,12 +31,12 @@ static void
 nni_taskq_thread(void *self)
 {
 	nni_taskq_thr *thr = self;
-	nni_taskq *    tq  = thr->tqt_tq;
-	nni_task *     task;
+	nni_taskq     *tq  = thr->tqt_tq;
+	nni_task      *task;
 
-        nni_thr_set_name(NULL, "nng:task");
+	nni_thr_set_name(NULL, "nng:task");
 
-        nni_mtx_lock(&tq->tq_mtx);
+	nni_mtx_lock(&tq->tq_mtx);
 	for (;;) {
 		if ((task = nni_list_first(&tq->tq_tasks)) != NULL) {
 
@@ -207,6 +207,16 @@ nni_task_wait(nni_task *task)
 	nni_mtx_unlock(&task->task_mtx);
 }
 
+bool
+nni_task_busy(nni_task *task)
+{
+	bool busy;
+	nni_mtx_lock(&task->task_mtx);
+	busy = task->task_busy;
+	nni_mtx_unlock(&task->task_mtx);
+	return (busy);
+}
+
 void
 nni_task_init(nni_task *task, nni_taskq *tq, nni_cb cb, void *arg)
 {
diff --git a/src/core/taskq.h b/src/core/taskq.h
index 9cabfd9..2ff449c 100644
--- a/src/core/taskq.h
+++ b/src/core/taskq.h
@@ -1,5 +1,5 @@
 //
-// Copyright 2020 Staysail Systems, Inc. <info@staysail.tech>
+// Copyright 2022 Staysail Systems, Inc. <info@staysail.tech>
 // Copyright 2018 Capitar IT Group BV <info@capitar.com>
 //
 // This software is supplied under the terms of the MIT License, a
@@ -43,6 +43,13 @@ extern void nni_task_prep(nni_task *);
 // returns an error.
 extern void nni_task_abort(nni_task *);
 
+// nni_task_busy checks to see if a task is still busy.
+// This is uses the same check that nni_task_wait uses.
+extern bool nni_task_busy(nni_task *);
+
+// nni_task_wait waits for the task to complete.  If additional
+// work is scheduled on the task then it will not return until that
+// work (or any other work subsequently scheduled) is complete.
 extern void nni_task_wait(nni_task *);
 extern void  nni_task_init(nni_task *, nni_taskq *, nni_cb, void *);
 
diff --git a/src/nng.c b/src/nng.c
index b1ebbd1..7925956 100644
--- a/src/nng.c
+++ b/src/nng.c
@@ -1,5 +1,5 @@
 //
-// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
+// Copyright 2022 Staysail Systems, Inc. <info@staysail.tech>
 // Copyright 2018 Capitar IT Group BV <info@capitar.com>
 //
 // This software is supplied under the terms of the MIT License, a
@@ -120,29 +120,33 @@ nng_recv(nng_socket s, void *buf, size_t *szp, int flags)
 int
 nng_recvmsg(nng_socket s, nng_msg **msgp, int flags)
 {
-	int      rv;
-	nng_aio *ap;
+	int       rv;
+	nni_sock *sock;
+	nni_aio   aio;
 
-	if ((rv = nng_aio_alloc(&ap, NULL, NULL)) != 0) {
+	if ((rv = nni_sock_find(&sock, s.id)) != 0) {
 		return (rv);
 	}
+
+	nni_aio_init(&aio, NULL, NULL);
 	if (flags & NNG_FLAG_NONBLOCK) {
-		nng_aio_set_timeout(ap, NNG_DURATION_ZERO);
+		nng_aio_set_timeout(&aio, NNG_DURATION_ZERO);
 	} else {
-		nng_aio_set_timeout(ap, NNG_DURATION_DEFAULT);
+		nng_aio_set_timeout(&aio, NNG_DURATION_DEFAULT);
 	}
+	nni_sock_recv(sock, &aio);
+	nni_sock_rele(sock);
 
-	nng_recv_aio(s, ap);
-	nng_aio_wait(ap);
+	nni_aio_wait(&aio);
 
-	if ((rv = nng_aio_result(ap)) == 0) {
-		*msgp = nng_aio_get_msg(ap);
+	if ((rv = nni_aio_result(&aio)) == 0) {
+		*msgp = nng_aio_get_msg(&aio);
 
 	} else if ((rv == NNG_ETIMEDOUT) &&
 	    ((flags & NNG_FLAG_NONBLOCK) == NNG_FLAG_NONBLOCK)) {
 		rv = NNG_EAGAIN;
 	}
-	nng_aio_free(ap);
+	nni_aio_fini(&aio);
 
 	return (rv);
 }
@@ -171,24 +175,31 @@ nng_send(nng_socket s, void *buf, size_t len, int flags)
 int
 nng_sendmsg(nng_socket s, nng_msg *msg, int flags)
 {
-	int      rv;
-	nng_aio *ap;
+	int       rv;
+	nni_aio   aio;
+	nni_sock *sock;
 
-	if ((rv = nng_aio_alloc(&ap, NULL, NULL)) != 0) {
+	if (msg == NULL) {
+		return (NNG_EINVAL);
+	}
+	if ((rv = nni_sock_find(&sock, s.id)) != 0) {
 		return (rv);
 	}
+
+	nni_aio_init(&aio, NULL, NULL);
 	if ((flags & NNG_FLAG_NONBLOCK) == NNG_FLAG_NONBLOCK) {
-		nng_aio_set_timeout(ap, NNG_DURATION_ZERO);
+		nni_aio_set_timeout(&aio, NNG_DURATION_ZERO);
 	} else {
-		nng_aio_set_timeout(ap, NNG_DURATION_DEFAULT);
+		nni_aio_set_timeout(&aio, NNG_DURATION_DEFAULT);
 	}
 
-	nng_aio_set_msg(ap, msg);
-	nng_send_aio(s, ap);
-	nng_aio_wait(ap);
+	nng_aio_set_msg(&aio, msg);
+	nni_sock_send(sock, &aio);
+	nni_sock_rele(sock);
 
-	rv = nng_aio_result(ap);
-	nng_aio_free(ap);
+	nni_aio_wait(&aio);
+	rv = nni_aio_result(&aio);
+	nni_aio_fini(&aio);
 
 	// Possibly massage nonblocking attempt.  Note that nonblocking is
 	// still done asynchronously, and the calling thread loses context.
@@ -242,7 +253,7 @@ int
 nng_ctx_open(nng_ctx *cp, nng_socket s)
 {
 	nni_sock *sock;
-	nni_ctx * ctx;
+	nni_ctx  *ctx;
 	int       rv;
 	nng_ctx   c;
 
@@ -280,6 +291,40 @@ nng_ctx_id(nng_ctx c)
 	return (((int) c.id > 0) ? (int) c.id : -1);
 }
 
+int
+nng_ctx_recvmsg(nng_ctx cid, nng_msg **msgp, int flags)
+{
+	int      rv;
+	nni_aio  aio;
+	nni_ctx *ctx;
+
+	if ((rv = nni_ctx_find(&ctx, cid.id, false)) != 0) {
+		return (rv);
+	}
+
+	nni_aio_init(&aio, NULL, NULL);
+	if (flags & NNG_FLAG_NONBLOCK) {
+		nng_aio_set_timeout(&aio, NNG_DURATION_ZERO);
+	} else {
+		nng_aio_set_timeout(&aio, NNG_DURATION_DEFAULT);
+	}
+	nni_ctx_recv(ctx, &aio);
+	nni_ctx_rele(ctx);
+
+	nni_aio_wait(&aio);
+
+	if ((rv = nni_aio_result(&aio)) == 0) {
+		*msgp = nng_aio_get_msg(&aio);
+
+	} else if ((rv == NNG_ETIMEDOUT) &&
+	    ((flags & NNG_FLAG_NONBLOCK) == NNG_FLAG_NONBLOCK)) {
+		rv = NNG_EAGAIN;
+	}
+	nni_aio_fini(&aio);
+
+	return (rv);
+}
+
 void
 nng_ctx_recv(nng_ctx cid, nng_aio *aio)
 {
@@ -318,6 +363,45 @@ nng_ctx_send(nng_ctx cid, nng_aio *aio)
 	nni_ctx_rele(ctx);
 }
 
+int
+nng_ctx_sendmsg(nng_ctx cid, nng_msg *msg, int flags)
+{
+	int      rv;
+	nni_aio  aio;
+	nni_ctx *ctx;
+
+	if (msg == NULL) {
+		return (NNG_EINVAL);
+	}
+	if ((rv = nni_ctx_find(&ctx, cid.id, false)) != 0) {
+		return (rv);
+	}
+
+	nni_aio_init(&aio, NULL, NULL);
+	if ((flags & NNG_FLAG_NONBLOCK) == NNG_FLAG_NONBLOCK) {
+		nni_aio_set_timeout(&aio, NNG_DURATION_ZERO);
+	} else {
+		nni_aio_set_timeout(&aio, NNG_DURATION_DEFAULT);
+	}
+
+	nng_aio_set_msg(&aio, msg);
+	nni_ctx_send(ctx, &aio);
+	nni_ctx_rele(ctx);
+
+	nni_aio_wait(&aio);
+	rv = nni_aio_result(&aio);
+	nni_aio_fini(&aio);
+
+	// Possibly massage nonblocking attempt.  Note that nonblocking is
+	// still done asynchronously, and the calling thread loses context.
+	if ((rv == NNG_ETIMEDOUT) &&
+	    ((flags & NNG_FLAG_NONBLOCK) == NNG_FLAG_NONBLOCK)) {
+		rv = NNG_EAGAIN;
+	}
+
+	return (rv);
+}
+
 static int
 ctx_get(nng_ctx id, const char *n, void *v, size_t *szp, nni_type t)
 {
@@ -466,7 +550,7 @@ nng_dial(nng_socket sid, const char *addr, nng_dialer *dp, int flags)
 {
 	nni_dialer *d;
 	int         rv;
-	nni_sock *  s;
+	nni_sock   *s;
 
 	if ((rv = nni_sock_find(&s, sid.id)) != 0) {
 		return (rv);
@@ -492,7 +576,7 @@ int
 nng_listen(nng_socket sid, const char *addr, nng_listener *lp, int flags)
 {
 	int           rv;
-	nni_sock *    s;
+	nni_sock     *s;
 	nni_listener *l;
 
 	if ((rv = nni_sock_find(&s, sid.id)) != 0) {
@@ -519,7 +603,7 @@ nng_listen(nng_socket sid, const char *addr, nng_listener *lp, int flags)
 int
 nng_listener_create(nng_listener *lp, nng_socket sid, const char *addr)
 {
-	nni_sock *    s;
+	nni_sock     *s;
 	int           rv;
 	nni_listener *l;
 	nng_listener  lid;
@@ -560,7 +644,7 @@ nng_listener_id(nng_listener l)
 int
 nng_dialer_create(nng_dialer *dp, nng_socket sid, const char *addr)
 {
-	nni_sock *  s;
+	nni_sock   *s;
 	nni_dialer *d;
 	int         rv;
 	nng_dialer  did;
@@ -1074,8 +1158,8 @@ nng_pipe_notify(nng_socket s, nng_pipe_ev ev, nng_pipe_cb cb, void *arg)
 	return (0);
 }
 
-int
-nng_device(nng_socket s1, nng_socket s2)
+void
+nng_device_aio(nng_aio *aio, nng_socket s1, nng_socket s2)
 {
 	int       rv;
 	nni_sock *sock1 = NULL;
@@ -1083,23 +1167,44 @@ nng_device(nng_socket s1, nng_socket s2)
 
 	if ((s1.id > 0) && (s1.id != (uint32_t) -1)) {
 		if ((rv = nni_sock_find(&sock1, s1.id)) != 0) {
-			return (rv);
+			if (nni_aio_begin(aio) == 0) {
+				nni_aio_finish_error(aio, rv);
+			}
+			return;
 		}
 	}
 	if (((s2.id > 0) && (s2.id != (uint32_t) -1)) && (s2.id != s1.id)) {
 		if ((rv = nni_sock_find(&sock2, s2.id)) != 0) {
 			nni_sock_rele(sock1);
-			return (rv);
+			if (nni_aio_begin(aio) == 0) {
+				nni_aio_finish_error(aio, rv);
+			}
+			return;
 		}
 	}
 
-	rv = nni_device(sock1, sock2);
+	nni_device(aio, sock1, sock2);
 	if (sock1 != NULL) {
 		nni_sock_rele(sock1);
 	}
 	if (sock2 != NULL) {
 		nni_sock_rele(sock2);
 	}
+}
+
+int
+nng_device(nng_socket s1, nng_socket s2)
+{
+	nni_aio aio;
+	int     rv;
+	if ((rv = nni_init()) != 0) {
+		return (rv);
+	}
+	nni_aio_init(&aio, NULL, NULL);
+	nng_device_aio(&aio, s1, s2);
+	nni_aio_wait(&aio);
+	rv = nni_aio_result(&aio);
+	nni_aio_fini(&aio);
 	return (rv);
 }
 
@@ -1247,7 +1352,7 @@ nng_socket
 nng_pipe_socket(nng_pipe p)
 {
 	nng_socket s = NNG_SOCKET_INITIALIZER;
-	nni_pipe * pipe;
+	nni_pipe  *pipe;
 
 	if ((nni_init() == 0) && (nni_pipe_find(&pipe, p.id) == 0)) {
 		s.id = nni_pipe_sock_id(pipe);
@@ -1260,7 +1365,7 @@ nng_dialer
 nng_pipe_dialer(nng_pipe p)
 {
 	nng_dialer d = NNG_DIALER_INITIALIZER;
-	nni_pipe * pipe;
+	nni_pipe  *pipe;
 	if ((nni_init() == 0) && (nni_pipe_find(&pipe, p.id) == 0)) {
 		d.id = nni_pipe_dialer_id(pipe);
 		nni_pipe_rele(pipe);
@@ -1272,7 +1377,7 @@ nng_listener
 nng_pipe_listener(nng_pipe p)
 {
 	nng_listener l = NNG_LISTENER_INITIALIZER;
-	nni_pipe *   pipe;
+	nni_pipe    *pipe;
 	if ((nni_init() == 0) && (nni_pipe_find(&pipe, p.id) == 0)) {
 		l.id = nni_pipe_listener_id(pipe);
 		nni_pipe_rele(pipe);
@@ -1778,6 +1883,12 @@ nng_aio_wait(nng_aio *aio)
 	nni_aio_wait(aio);
 }
 
+bool
+nng_aio_busy(nng_aio *aio)
+{
+	return (nni_aio_busy(aio));
+}
+
 void
 nng_aio_abort(nng_aio *aio, int err_code)
 {
diff --git a/src/nng_legacy.c b/src/nng_legacy.c
index c38d0a2..a041cc0 100644
--- a/src/nng_legacy.c
+++ b/src/nng_legacy.c
@@ -63,6 +63,11 @@ nng_getopt_ms(nng_socket id, const char *n, nng_duration *v)
 	return (nng_socket_get_ms(id, n, v));
 }
 
+int nng_getopt_ptr(nng_socket id, const char *n, void **v)
+{
+	return (nng_socket_get_ptr(id, n, v));
+}
+
 int
 nng_getopt_string(nng_socket id, const char *n, char **v)
 {
diff --git a/src/platform/posix/CMakeLists.txt b/src/platform/posix/CMakeLists.txt
index 02a8cb5..7b619fa 100644
--- a/src/platform/posix/CMakeLists.txt
+++ b/src/platform/posix/CMakeLists.txt
@@ -105,4 +105,7 @@ if (NNG_PLATFORM_POSIX)
     else ()
         nng_sources(posix_rand_urandom.c)
     endif ()
+
+    nng_test(posix_ipcwinsec_test)
+
 endif ()
\ No newline at end of file
diff --git a/src/platform/posix/posix_atomic.c b/src/platform/posix/posix_atomic.c
index 57ef709..6087584 100644
--- a/src/platform/posix/posix_atomic.c
+++ b/src/platform/posix/posix_atomic.c
@@ -1,5 +1,5 @@
 //
-// Copyright 2020 Staysail Systems, Inc. <info@staysail.tech>
+// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
 // Copyright 2018 Capitar IT Group BV <info@capitar.com>
 //
 // This software is supplied under the terms of the MIT License, a
@@ -81,7 +81,19 @@ nni_atomic_get(nni_atomic_int *v)
 void
 nni_atomic_set(nni_atomic_int *v, int i)
 {
-	return (atomic_store(&v->v, i));
+	atomic_store(&v->v, i);
+}
+
+void *
+nni_atomic_get_ptr(nni_atomic_ptr *v)
+{
+	return ((void *) atomic_load(&v->v));
+}
+
+void
+nni_atomic_set_ptr(nni_atomic_ptr *v, void *p)
+{
+	atomic_store(&v->v, (uintptr_t) p);
 }
 
 int
@@ -178,6 +190,172 @@ nni_atomic_cas64(nni_atomic_u64 *v, uint64_t comp, uint64_t new)
 	return (atomic_compare_exchange_strong(&v->v, &cv, nv));
 }
 
+#elif NNI_GCC_VERSION >= 40700 || \
+    defined(__clang__) // we have "new" GCC __atomic builtins
+bool
+nni_atomic_flag_test_and_set(nni_atomic_flag *f)
+{
+	return (__atomic_test_and_set(&f->f, __ATOMIC_SEQ_CST));
+}
+
+void
+nni_atomic_flag_reset(nni_atomic_flag *f)
+{
+	__atomic_clear(&f->f, __ATOMIC_SEQ_CST);
+}
+
+void
+nni_atomic_set_bool(nni_atomic_bool *b, bool n)
+{
+	__atomic_store_n(&b->b, n, __ATOMIC_SEQ_CST);
+}
+
+bool
+nni_atomic_get_bool(nni_atomic_bool *b)
+{
+	return (__atomic_load_n(&b->b, __ATOMIC_SEQ_CST));
+}
+
+bool
+nni_atomic_swap_bool(nni_atomic_bool *b, bool n)
+{
+	return (__atomic_exchange_n(&b->b, n, __ATOMIC_SEQ_CST));
+}
+
+void
+nni_atomic_init_bool(nni_atomic_bool *b)
+{
+	__atomic_store_n(&b->b, false, __ATOMIC_SEQ_CST);
+}
+
+void
+nni_atomic_add64(nni_atomic_u64 *v, uint64_t bump)
+{
+	__atomic_add_fetch(&v->v, bump, __ATOMIC_RELAXED);
+}
+
+void
+nni_atomic_sub64(nni_atomic_u64 *v, uint64_t bump)
+{
+	__atomic_sub_fetch(&v->v, bump, __ATOMIC_RELAXED);
+}
+
+uint64_t
+nni_atomic_get64(nni_atomic_u64 *v)
+{
+	return (__atomic_load_n(&v->v, __ATOMIC_SEQ_CST));
+}
+
+void
+nni_atomic_set64(nni_atomic_u64 *v, uint64_t u)
+{
+	__atomic_store_n(&v->v, u, __ATOMIC_SEQ_CST);
+}
+
+uint64_t
+nni_atomic_swap64(nni_atomic_u64 *v, uint64_t u)
+{
+	return (__atomic_exchange_n(&v->v, u, __ATOMIC_SEQ_CST));
+}
+
+void
+nni_atomic_init64(nni_atomic_u64 *v)
+{
+	__atomic_store_n(&v->v, 0, __ATOMIC_SEQ_CST);
+}
+
+void
+nni_atomic_inc64(nni_atomic_u64 *v)
+{
+	__atomic_add_fetch(&v->v, 1, __ATOMIC_SEQ_CST);
+}
+
+uint64_t
+nni_atomic_dec64_nv(nni_atomic_u64 *v)
+{
+	return (__atomic_sub_fetch(&v->v, 1, __ATOMIC_SEQ_CST));
+}
+
+bool
+nni_atomic_cas64(nni_atomic_u64 *v, uint64_t comp, uint64_t new)
+{
+
+	return (__atomic_compare_exchange_n(
+	    &v->v, &comp, new, false, __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST));
+}
+
+int
+nni_atomic_swap(nni_atomic_int *v, int u)
+{
+	return (__atomic_exchange_n(&v->v, u, __ATOMIC_SEQ_CST));
+}
+
+void
+nni_atomic_init(nni_atomic_int *v)
+{
+	__atomic_store_n(&v->v, 0, __ATOMIC_SEQ_CST);
+}
+
+void
+nni_atomic_add(nni_atomic_int *v, int bump)
+{
+	__atomic_add_fetch(&v->v, bump, __ATOMIC_RELAXED);
+}
+
+void
+nni_atomic_sub(nni_atomic_int *v, int bump)
+{
+	__atomic_sub_fetch(&v->v, bump, __ATOMIC_RELAXED);
+}
+
+void
+nni_atomic_set(nni_atomic_int *v, int val)
+{
+	__atomic_store_n(&v->v, val, __ATOMIC_SEQ_CST);
+}
+
+int
+nni_atomic_get(nni_atomic_int *v)
+{
+	return (__atomic_load_n(&v->v, __ATOMIC_SEQ_CST));
+}
+void
+nni_atomic_inc(nni_atomic_int *v)
+{
+	__atomic_add_fetch(&v->v, 1, __ATOMIC_SEQ_CST);
+}
+
+void
+nni_atomic_dec(nni_atomic_int *v)
+{
+	__atomic_sub_fetch(&v->v, 1, __ATOMIC_SEQ_CST);
+}
+
+int
+nni_atomic_dec_nv(nni_atomic_int *v)
+{
+	return (__atomic_sub_fetch(&v->v, 1, __ATOMIC_SEQ_CST));
+}
+
+bool
+nni_atomic_cas(nni_atomic_int *v, int comp, int new)
+{
+	return (__atomic_compare_exchange_n(
+	    &v->v, &comp, new, false, __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST));
+}
+
+void *
+nni_atomic_get_ptr(nni_atomic_ptr *v)
+{
+	return (__atomic_load_n(&v->v, __ATOMIC_SEQ_CST));
+}
+
+void
+nni_atomic_set_ptr(nni_atomic_ptr *v, void *p)
+{
+	__atomic_store_n(&v->v, p, __ATOMIC_SEQ_CST);
+}
+
 #else
 
 #include <pthread.h>
@@ -363,6 +541,24 @@ nni_atomic_set(nni_atomic_int *v, int i)
 	pthread_mutex_unlock(&plat_atomic_lock);
 }
 
+void *
+nni_atomic_get_ptr(nni_atomic_ptr *v)
+{
+	void *p;
+	pthread_mutex_lock(&plat_atomic_lock);
+	p = v->v;
+	pthread_mutex_unlock(&plat_atomic_lock);
+	return (p);
+}
+
+void
+nni_atomic_set_ptr(nni_atomic_ptr *v, void *p)
+{
+	pthread_mutex_lock(&plat_atomic_lock);
+	v->v = p;
+	pthread_mutex_unlock(&plat_atomic_lock);
+}
+
 int
 nni_atomic_swap(nni_atomic_int *v, int i)
 {
diff --git a/src/platform/posix/posix_clock.c b/src/platform/posix/posix_clock.c
index d543500..0db447e 100644
--- a/src/platform/posix/posix_clock.c
+++ b/src/platform/posix/posix_clock.c
@@ -1,5 +1,5 @@
 //
-// Copyright 2021 Garrett D'Amore <garrett@damore.org>
+// Copyright 2022 Staysail Systems, Inc. <info@staysail.tech>
 // Copyright 2017 Capitar IT Group BV <info@capitar.com>
 //
 // This software is supplied under the terms of the MIT License, a
@@ -17,7 +17,7 @@
 #include <string.h>
 #include <time.h>
 
-#ifndef NNG_USE_GETTIMEOFDAY
+#if defined(NNG_HAVE_CLOCK_GETTIME) && !defined(NNG_USE_GETTIMEOFDAY)
 
 // Use POSIX realtime stuff
 nni_time
diff --git a/src/platform/posix/posix_config.h b/src/platform/posix/posix_config.h
index 2abe51b..f9d13d7 100644
--- a/src/platform/posix/posix_config.h
+++ b/src/platform/posix/posix_config.h
@@ -1,5 +1,5 @@
 //
-// Copyright 2019 Staysail Systems, Inc. <info@staysail.tech>
+// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
 //
 // This software is supplied under the terms of the MIT License, a
 // copy of which should be located in the distribution where this
@@ -20,11 +20,14 @@
 //	the system lacks clock_gettime, then it will choose this automatically.
 //	This value may be ignored on platforms that don't use POSIX clocks.
 //
-// #define NNG_USE_CLOCKID
+// #define NNG_USE_CLOCKID CLOCK_MONOTONIC
 //	This macro may be defined to a different clock id (see
-//	clock_gettime()).  By default we use CLOCK_MONOTONIC if it exists,
-//	or CLOCK_REALTIME otherwise.  This is ignored if NNG_USE_GETTIMEOFDAY
-//	is defined.  Platforms that don't use POSIX clocks will probably
+//	clock_gettime()).  By default, we use CLOCK_MONOTONIC if it exists,
+//	or CLOCK_REALTIME otherwise.  (Except for macOS, which does not have
+//	a functional pthread_condattr_setclock().)
+//
+//	This is ignored if NNG_USE_GETTIMEOFDAY is defined.
+//	Platforms that don't use POSIX clocks will probably
 //	ignore any setting here.
 //
 // #define NNG_HAVE_BACKTRACE
@@ -61,21 +64,18 @@
 #endif
 #endif
 
+#ifndef NNG_USE_CLOCKID
+#if defined(__APPLE__)
 #define NNG_USE_CLOCKID CLOCK_REALTIME
-#ifndef CLOCK_REALTIME
-#define NNG_USE_GETTIMEOFDAY
-#elif !defined(NNG_USE_CLOCKID)
+#elif defined(CLOCK_MONOTONIC)
 #define NNG_USE_CLOCKID CLOCK_MONOTONIC
-#else
+#elif defined(CLOCK_REALTIME)
 #define NNG_USE_CLOCKID CLOCK_REALTIME
-#endif // CLOCK_REALTIME
-
-#if defined(NNG_HAVE_KQUEUE)
-// pass
 #else
-// fallback to poll(2)
-#define NNG_USE_POSIX_POLLQ_POLL 1
+#define NNG_USE_GETTIMEOFDAY
+#endif
 #endif
+
 #define NNG_USE_POSIX_RESOLV_GAI 1
 
 #endif // NNG_PLATFORM_POSIX
diff --git a/src/platform/posix/posix_impl.h b/src/platform/posix/posix_impl.h
index 851c80d..afbdce9 100644
--- a/src/platform/posix/posix_impl.h
+++ b/src/platform/posix/posix_impl.h
@@ -58,15 +58,35 @@ struct nni_plat_mtx {
 	pthread_mutex_t mtx;
 };
 
+#define NNI_MTX_INITIALIZER               \
+	{                                 \
+		PTHREAD_MUTEX_INITIALIZER \
+	}
+
 struct nni_rwlock {
 	pthread_rwlock_t rwl;
 };
 
+#define NNI_RWLOCK_INITIALIZER             \
+	{                                  \
+		PTHREAD_RWLOCK_INITIALIZER \
+	}
+
+// No static form of CV initialization because of the need to use
+// attributes to set the clock type.
 struct nni_plat_cv {
 	pthread_cond_t cv;
-	nni_plat_mtx * mtx;
+	nni_plat_mtx  *mtx;
 };
 
+// NOTE: condition variables initialized with this should *NOT*
+// be used with nni_cv_until -- the clock attributes are not passed
+// and the wake-up times will not be correct.
+#define NNI_CV_INITIALIZER(mxp)                            \
+	{                                                  \
+		.mtx = mxp, .cv = PTHREAD_COND_INITIALIZER \
+	}
+
 struct nni_plat_thr {
 	pthread_t tid;
 	void (*func)(void *);
@@ -80,7 +100,6 @@ struct nni_plat_flock {
 #define NNG_PLATFORM_DIR_SEP "/"
 
 #ifdef NNG_HAVE_STDATOMIC
-
 #include <stdatomic.h>
 
 struct nni_atomic_flag {
@@ -99,6 +118,10 @@ struct nni_atomic_bool {
 	atomic_bool v;
 };
 
+struct nni_atomic_ptr {
+	atomic_uintptr_t v;
+};
+
 #else // NNG_HAVE_C11_ATOMIC
 struct nni_atomic_flag {
 	bool f;
@@ -116,6 +139,10 @@ struct nni_atomic_u64 {
 	uint64_t v;
 };
 
+struct nni_atomic_ptr {
+	void *v;
+};
+
 #endif
 
 #endif
diff --git a/src/platform/posix/posix_ipcdial.c b/src/platform/posix/posix_ipcdial.c
index 69ed4f7..464179a 100644
--- a/src/platform/posix/posix_ipcdial.c
+++ b/src/platform/posix/posix_ipcdial.c
@@ -37,9 +37,9 @@ ipc_dialer_close(void *arg)
 		while ((aio = nni_list_first(&d->connq)) != NULL) {
 			nni_ipc_conn *c;
 			nni_list_remove(&d->connq, aio);
-			if ((c = nni_aio_get_prov_extra(aio, 0)) != NULL) {
+			if ((c = nni_aio_get_prov_data(aio)) != NULL) {
 				c->dial_aio = NULL;
-				nni_aio_set_prov_extra(aio, 0, NULL);
+				nni_aio_set_prov_data(aio, NULL);
 				nng_stream_close(&c->stream);
 				nng_stream_free(&c->stream);
 			}
@@ -84,13 +84,13 @@ ipc_dialer_cancel(nni_aio *aio, void *arg, int rv)
 
 	nni_mtx_lock(&d->mtx);
 	if ((!nni_aio_list_active(aio)) ||
-	    ((c = nni_aio_get_prov_extra(aio, 0)) == NULL)) {
+	    ((c = nni_aio_get_prov_data(aio)) == NULL)) {
 		nni_mtx_unlock(&d->mtx);
 		return;
 	}
 	nni_aio_list_remove(aio);
 	c->dial_aio = NULL;
-	nni_aio_set_prov_extra(aio, 0, NULL);
+	nni_aio_set_prov_data(aio, NULL);
 	nni_mtx_unlock(&d->mtx);
 
 	nni_aio_finish_error(aio, rv);
@@ -133,7 +133,7 @@ ipc_dialer_cb(nni_posix_pfd *pfd, unsigned ev, void *arg)
 
 	c->dial_aio = NULL;
 	nni_aio_list_remove(aio);
-	nni_aio_set_prov_extra(aio, 0, NULL);
+	nni_aio_set_prov_data(aio, NULL);
 	nni_mtx_unlock(&d->mtx);
 
 	if (rv != 0) {
@@ -217,14 +217,14 @@ ipc_dialer_dial(void *arg, nni_aio *aio)
 			goto error;
 		}
 		c->dial_aio = aio;
-		nni_aio_set_prov_extra(aio, 0, c);
+		nni_aio_set_prov_data(aio, c);
 		nni_list_append(&d->connq, aio);
 		nni_mtx_unlock(&d->mtx);
 		return;
 	}
 	// Immediate connect, cool!  This probably only happens
-	// on loopback, and probably not on every platform.
-	nni_aio_set_prov_extra(aio, 0, NULL);
+	// on loop back, and probably not on every platform.
+	nni_aio_set_prov_data(aio, NULL);
 	nni_mtx_unlock(&d->mtx);
 	nni_posix_ipc_start(c);
 	nni_aio_set_output(aio, 0, c);
@@ -232,7 +232,7 @@ ipc_dialer_dial(void *arg, nni_aio *aio)
 	return;
 
 error:
-	nni_aio_set_prov_extra(aio, 0, NULL);
+	nni_aio_set_prov_data(aio, NULL);
 	nni_mtx_unlock(&d->mtx);
 	nng_stream_free(&c->stream);
 	nni_aio_finish_error(aio, rv);
diff --git a/src/platform/posix/posix_ipcwinsec_test.c b/src/platform/posix/posix_ipcwinsec_test.c
new file mode 100644
index 0000000..934eeea
--- /dev/null
+++ b/src/platform/posix/posix_ipcwinsec_test.c
@@ -0,0 +1,31 @@
+//
+// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
+// Copyright 2018 Capitar IT Group BV <info@capitar.com>
+//
+// This software is supplied under the terms of the MIT License, a
+// copy of which should be located in the distribution where this
+// file was obtained (LICENSE.txt).  A copy of the license may also be
+// found online at https://opensource.org/licenses/MIT.
+//
+#include <nng/nng.h>
+#include <nuts.h>
+
+void
+test_ipc_win_sec(void)
+{
+	char                 address[64];
+	nng_stream_listener *l;
+	int                  x;
+
+	nuts_scratch_addr("ipc", sizeof(address), address);
+	NUTS_PASS(nng_stream_listener_alloc(&l, address));
+	NUTS_FAIL(nng_stream_listener_set_ptr(
+	              l, NNG_OPT_IPC_SECURITY_DESCRIPTOR, &x),
+	    NNG_ENOTSUP);
+	nng_stream_listener_free(l);
+}
+
+NUTS_TESTS = {
+	{ "ipc security descriptor", test_ipc_win_sec },
+	{ NULL, NULL },
+};
diff --git a/src/platform/posix/posix_pipe.c b/src/platform/posix/posix_pipe.c
index 8132aff..ac827ab 100644
--- a/src/platform/posix/posix_pipe.c
+++ b/src/platform/posix/posix_pipe.c
@@ -1,5 +1,5 @@
 //
-// Copyright 2020 Staysail Systems, Inc. <info@staysail.tech>
+// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
 //
 // This software is supplied under the terms of the MIT License, a
 // copy of which should be located in the distribution where this
@@ -98,16 +98,16 @@ nni_plat_pipe_open(int *wfd, int *rfd)
 	return (0);
 }
 
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wunused-result"
 void
 nni_plat_pipe_raise(int wfd)
 {
 	char c = 1;
 
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wunused-result"
 	(void) write(wfd, &c, 1);
-#pragma GCC diagnostic pop
 }
+#pragma GCC diagnostic pop
 
 void
 nni_plat_pipe_clear(int rfd)
@@ -126,8 +126,8 @@ nni_plat_pipe_clear(int rfd)
 void
 nni_plat_pipe_close(int wfd, int rfd)
 {
-	close(wfd);
-	close(rfd);
+	(void) close(wfd);
+	(void) close(rfd);
 }
 
 #endif // NNG_USE_EVENTFD
diff --git a/src/platform/posix/posix_resolv_gai.c b/src/platform/posix/posix_resolv_gai.c
index 83974b3..1c209f1 100644
--- a/src/platform/posix/posix_resolv_gai.c
+++ b/src/platform/posix/posix_resolv_gai.c
@@ -1,5 +1,5 @@
 //
-// Copyright 2020 Staysail Systems, Inc. <info@staysail.tech>
+// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
 // Copyright 2018 Capitar IT Group BV <info@capitar.com>
 //
 // This software is supplied under the terms of the MIT License, a
@@ -33,9 +33,9 @@
 #define NNG_RESOLV_CONCURRENCY 4
 #endif
 
-static nni_mtx  resolv_mtx;
-static nni_cv   resolv_cv;
-static bool     resolv_fini;
+static nni_mtx  resolv_mtx  = NNI_MTX_INITIALIZER;
+static nni_cv   resolv_cv   = NNI_CV_INITIALIZER(&resolv_mtx);
+static bool     resolv_fini = false;
 static nni_list resolv_aios;
 static nni_thr  resolv_thrs[NNG_RESOLV_CONCURRENCY];
 
@@ -43,9 +43,9 @@ typedef struct resolv_item resolv_item;
 struct resolv_item {
 	int           family;
 	bool          passive;
-	char *        host;
-	char *        serv;
-	nni_aio *     aio;
+	char         *host;
+	char         *serv;
+	nni_aio      *aio;
 	nng_sockaddr *sa;
 };
 
@@ -63,12 +63,12 @@ resolv_cancel(nni_aio *aio, void *arg, int rv)
 	resolv_item *item = arg;
 
 	nni_mtx_lock(&resolv_mtx);
-	if (item != nni_aio_get_prov_extra(aio, 0)) {
+	if (item != nni_aio_get_prov_data(aio)) {
 		// Already canceled?
 		nni_mtx_unlock(&resolv_mtx);
 		return;
 	}
-	nni_aio_set_prov_extra(aio, 0, NULL);
+	nni_aio_set_prov_data(aio, NULL);
 	if (nni_aio_list_active(aio)) {
 		// We have not been picked up by a resolver thread yet,
 		// so we can just discard everything.
@@ -189,9 +189,9 @@ resolv_task(resolv_item *item)
 
 	nni_mtx_lock(&resolv_mtx);
 	if ((probe != NULL) && (item->aio != NULL)) {
-		struct sockaddr_in * sin;
+		struct sockaddr_in  *sin;
 		struct sockaddr_in6 *sin6;
-		nng_sockaddr *       sa = item->sa;
+		nng_sockaddr        *sa = item->sa;
 
 		switch (probe->ai_addr->sa_family) {
 		case AF_INET:
@@ -277,7 +277,7 @@ nni_resolv_ip(const char *host, const char *serv, int af, bool passive,
 	if (resolv_fini) {
 		rv = NNG_ECLOSED;
 	} else {
-		nni_aio_set_prov_extra(aio, 0, item);
+		nni_aio_set_prov_data(aio, item);
 		rv = nni_aio_schedule(aio, resolv_cancel, item);
 	}
 	if (rv != 0) {
@@ -301,7 +301,7 @@ resolv_worker(void *unused)
 
 	nni_mtx_lock(&resolv_mtx);
 	for (;;) {
-		nni_aio *    aio;
+		nni_aio     *aio;
 		resolv_item *item;
 		int          rv;
 
@@ -313,7 +313,7 @@ resolv_worker(void *unused)
 			continue;
 		}
 
-		item = nni_aio_get_prov_extra(aio, 0);
+		item = nni_aio_get_prov_data(aio);
 		nni_aio_list_remove(aio);
 
 		// Now attempt to do the work.  This runs synchronously.
@@ -324,7 +324,7 @@ resolv_worker(void *unused)
 		// Check to make sure we were not canceled.
 		if ((aio = item->aio) != NULL) {
 
-			nni_aio_set_prov_extra(aio, 0, NULL);
+			nni_aio_set_prov_data(aio, NULL);
 			item->aio = NULL;
 			item->sa  = NULL;
 
@@ -343,9 +343,9 @@ parse_ip(const char *addr, nng_sockaddr *sa, bool want_port)
 	int              rv;
 	bool             v6      = false;
 	bool             wrapped = false;
-	char *           port;
-	char *           host;
-	char *           buf;
+	char            *port;
+	char            *host;
+	char            *buf;
 	size_t           buf_len;
 
 	if (addr == NULL) {
@@ -443,11 +443,8 @@ nni_parse_ip_port(const char *addr, nni_sockaddr *sa)
 int
 nni_posix_resolv_sysinit(void)
 {
-	nni_mtx_init(&resolv_mtx);
-	nni_cv_init(&resolv_cv, &resolv_mtx);
-	nni_aio_list_init(&resolv_aios);
-
 	resolv_fini = false;
+	nni_aio_list_init(&resolv_aios);
 
 	for (int i = 0; i < NNG_RESOLV_CONCURRENCY; i++) {
 		int rv = nni_thr_init(&resolv_thrs[i], resolv_worker, NULL);
@@ -474,8 +471,6 @@ nni_posix_resolv_sysfini(void)
 	for (int i = 0; i < NNG_RESOLV_CONCURRENCY; i++) {
 		nni_thr_fini(&resolv_thrs[i]);
 	}
-	nni_cv_fini(&resolv_cv);
-	nni_mtx_fini(&resolv_mtx);
 }
 
 #endif // NNG_USE_POSIX_RESOLV_GAI
diff --git a/src/platform/posix/posix_tcpdial.c b/src/platform/posix/posix_tcpdial.c
index f7568db..d9b5821 100644
--- a/src/platform/posix/posix_tcpdial.c
+++ b/src/platform/posix/posix_tcpdial.c
@@ -1,5 +1,5 @@
 //
-// Copyright 2020 Staysail Systems, Inc. <info@staysail.tech>
+// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
 // Copyright 2018 Capitar IT Group BV <info@capitar.com>
 // Copyright 2018 Devolutions <info@devolutions.net>
 //
@@ -52,9 +52,9 @@ nni_tcp_dialer_close(nni_tcp_dialer *d)
 		while ((aio = nni_list_first(&d->connq)) != NULL) {
 			nni_tcp_conn *c;
 			nni_list_remove(&d->connq, aio);
-			if ((c = nni_aio_get_prov_extra(aio, 0)) != NULL) {
+			if ((c = nni_aio_get_prov_data(aio)) != NULL) {
 				c->dial_aio = NULL;
-				nni_aio_set_prov_extra(aio, 0, NULL);
+				nni_aio_set_prov_data(aio, NULL);
 				nng_stream_close(&c->stream);
 				nng_stream_free(&c->stream);
 			}
@@ -97,13 +97,13 @@ tcp_dialer_cancel(nni_aio *aio, void *arg, int rv)
 
 	nni_mtx_lock(&d->mtx);
 	if ((!nni_aio_list_active(aio)) ||
-	    ((c = nni_aio_get_prov_extra(aio, 0)) == NULL)) {
+	    ((c = nni_aio_get_prov_data(aio)) == NULL)) {
 		nni_mtx_unlock(&d->mtx);
 		return;
 	}
 	nni_aio_list_remove(aio);
 	c->dial_aio = NULL;
-	nni_aio_set_prov_extra(aio, 0, NULL);
+	nni_aio_set_prov_data(aio, NULL);
 	nni_mtx_unlock(&d->mtx);
 
 	nni_aio_finish_error(aio, rv);
@@ -148,7 +148,7 @@ tcp_dialer_cb(nni_posix_pfd *pfd, unsigned ev, void *arg)
 
 	c->dial_aio = NULL;
 	nni_aio_list_remove(aio);
-	nni_aio_set_prov_extra(aio, 0, NULL);
+	nni_aio_set_prov_data(aio, NULL);
 	nd = d->nodelay ? 1 : 0;
 	ka = d->keepalive ? 1 : 0;
 
@@ -237,14 +237,14 @@ nni_tcp_dial(nni_tcp_dialer *d, const nni_sockaddr *sa, nni_aio *aio)
 			goto error;
 		}
 		c->dial_aio = aio;
-		nni_aio_set_prov_extra(aio, 0, c);
+		nni_aio_set_prov_data(aio, c);
 		nni_list_append(&d->connq, aio);
 		nni_mtx_unlock(&d->mtx);
 		return;
 	}
 	// Immediate connect, cool!  This probably only happens
-	// on loopback, and probably not on every platform.
-	nni_aio_set_prov_extra(aio, 0, NULL);
+	// on loop back, and probably not on every platform.
+	nni_aio_set_prov_data(aio, NULL);
 	nd = d->nodelay ? 1 : 0;
 	ka = d->keepalive ? 1 : 0;
 	nni_mtx_unlock(&d->mtx);
@@ -254,7 +254,7 @@ nni_tcp_dial(nni_tcp_dialer *d, const nni_sockaddr *sa, nni_aio *aio)
 	return;
 
 error:
-	nni_aio_set_prov_extra(aio, 0, NULL);
+	nni_aio_set_prov_data(aio, NULL);
 	nni_mtx_unlock(&d->mtx);
 	nng_stream_free(&c->stream);
 	nni_aio_finish_error(aio, rv);
diff --git a/src/platform/posix/posix_thread.c b/src/platform/posix/posix_thread.c
index c47bcec..b7cd5e1 100644
--- a/src/platform/posix/posix_thread.c
+++ b/src/platform/posix/posix_thread.c
@@ -34,7 +34,7 @@
 #endif
 
 static pthread_mutex_t nni_plat_init_lock = PTHREAD_MUTEX_INITIALIZER;
-static int             nni_plat_inited    = 0;
+static volatile int    nni_plat_inited    = 0;
 static int             nni_plat_forked    = 0;
 
 pthread_condattr_t  nni_cvattr;
diff --git a/src/platform/windows/CMakeLists.txt b/src/platform/windows/CMakeLists.txt
index 174e77f..d1d158e 100644
--- a/src/platform/windows/CMakeLists.txt
+++ b/src/platform/windows/CMakeLists.txt
@@ -1,5 +1,5 @@
 #
-# Copyright 2020 Staysail Systems, Inc. <info@staystail.tech>
+# Copyright 2021 Staysail Systems, Inc. <info@staystail.tech>
 #
 # This software is supplied under the terms of the MIT License, a
 # copy of which should be located in the distribution where this
@@ -46,4 +46,7 @@ if (NNG_PLATFORM_WINDOWS)
             win_thread.c
             win_udp.c
     )
+
+    nng_test(win_ipc_sec_test)
+
 endif ()
\ No newline at end of file
diff --git a/src/platform/windows/win_impl.h b/src/platform/windows/win_impl.h
index de4f8e5..7842bdb 100644
--- a/src/platform/windows/win_impl.h
+++ b/src/platform/windows/win_impl.h
@@ -1,5 +1,5 @@
 //
-// Copyright 2018 Staysail Systems, Inc. <info@staysail.tech>
+// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
 // Copyright 2018 Capitar IT Group BV <info@capitar.com>
 //
 // This software is supplied under the terms of the MIT License, a
@@ -30,29 +30,42 @@
 
 struct nni_plat_thr {
 	void (*func)(void *);
-	void * arg;
+	void  *arg;
 	HANDLE handle;
 	DWORD  id;
 };
 
 struct nni_plat_mtx {
 	SRWLOCK srl;
-	DWORD   owner;
-	int     init;
 };
 
+#define NNI_MTX_INITIALIZER  \
+	{                    \
+		SRWLOCK_INIT \
+	}
+
 struct nni_rwlock {
 	SRWLOCK rwl;
 	BOOLEAN exclusive;
 };
 
+#define NNI_RWLOCK_INITIALIZER \
+	{                      \
+		SRWLOCK_INIT   \
+	}
+
 struct nni_plat_cv {
 	CONDITION_VARIABLE cv;
 	PSRWLOCK           srl;
 };
 
+#define NNI_CV_INITIALIZER(mxp)                                    \
+	{                                                          \
+		.srl = (void *) mxp, .cv = CONDITION_VARIABLE_INIT \
+	}
+
 struct nni_atomic_flag {
-	unsigned f;
+	LONG f;
 };
 
 struct nni_atomic_bool {
@@ -67,6 +80,10 @@ struct nni_atomic_u64 {
 	LONGLONG v;
 };
 
+struct nni_atomic_ptr {
+	LONGLONG v;
+};
+
 // nni_win_io is used with io completion ports.  This allows us to get
 // to a specific completion callback without requiring the poller (in the
 // completion port) to know anything about the event itself.
@@ -77,8 +94,8 @@ typedef void (*nni_win_io_cb)(nni_win_io *, int, size_t);
 struct nni_win_io {
 	OVERLAPPED    olpd;
 	HANDLE        f;
-	void *        ptr;
-	nni_aio *     aio;
+	void         *ptr;
+	nni_aio      *aio;
 	nni_win_io_cb cb;
 };
 
diff --git a/src/platform/windows/win_ipc_sec_test.c b/src/platform/windows/win_ipc_sec_test.c
new file mode 100644
index 0000000..ab65533
--- /dev/null
+++ b/src/platform/windows/win_ipc_sec_test.c
@@ -0,0 +1,190 @@
+//
+// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
+// Copyright 2018 Capitar IT Group BV <info@capitar.com>
+//
+// This software is supplied under the terms of the MIT License, a
+// copy of which should be located in the distribution where this
+// file was obtained (LICENSE.txt).  A copy of the license may also be
+// found online at https://opensource.org/licenses/MIT.
+//
+
+#include <nng/nng.h>
+#include <nuts.h>
+
+// Microsoft prefers CamelCase header names, but relies on case-insensitive
+// file systems to make that work.  The rest of the world (min-gw64 included)
+// uses case-sensitive names and lowercase.
+
+#include <accctrl.h>
+#include <aclapi.h>
+
+SECURITY_DESCRIPTOR *
+sdescAuthUsers(PSID sid, PACL *aclp)
+{
+	SECURITY_DESCRIPTOR *sdesc;
+	EXPLICIT_ACCESS      xa;
+	ACL                 *acl;
+
+	sdesc = calloc(SECURITY_DESCRIPTOR_MIN_LENGTH, 1);
+	NUTS_ASSERT(sdesc != NULL);
+
+	InitializeSecurityDescriptor(sdesc, SECURITY_DESCRIPTOR_REVISION);
+
+	xa.grfAccessPermissions = GENERIC_READ | GENERIC_WRITE;
+	xa.grfAccessMode        = SET_ACCESS;
+	xa.grfInheritance       = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
+	xa.Trustee.TrusteeForm  = TRUSTEE_IS_SID;
+	xa.Trustee.TrusteeType  = TRUSTEE_IS_WELL_KNOWN_GROUP;
+	xa.Trustee.ptstrName    = (LPSTR) sid;
+
+	SetEntriesInAcl(1, &xa, NULL, &acl);
+	*aclp = acl;
+
+	SetSecurityDescriptorDacl(sdesc, TRUE, acl, FALSE);
+	return (sdesc);
+}
+
+void
+test_ipc_security_descriptor(void)
+{
+	nng_stream_listener *l;
+	char                 address[64];
+	char                 pipe[64];
+	SECURITY_DESCRIPTOR *sd;
+	SID                  users;
+	DWORD                size;
+	PACL                 acl = NULL;
+	PACL                 dacl;
+	PSECURITY_DESCRIPTOR psd;
+	PACE_HEADER          ace;
+	PSID                 psid;
+	PACCESS_ALLOWED_ACE  allowed;
+	nng_aio             *aio;
+
+	nuts_scratch_addr("ipc", sizeof(address), address);
+
+	NUTS_PASS(nng_stream_listener_alloc(&l, address));
+	size = sizeof(users);
+	CreateWellKnownSid(WinAuthenticatedUserSid, NULL, &users, &size);
+	sd = sdescAuthUsers(&users, &acl);
+
+	NUTS_ASSERT(sd != NULL);
+	NUTS_ASSERT(acl != NULL);
+	NUTS_PASS(nng_aio_alloc(&aio, NULL, NULL));
+
+	NUTS_PASS(nng_stream_listener_set_ptr(
+	    l, NNG_OPT_IPC_SECURITY_DESCRIPTOR, sd));
+	NUTS_PASS(nng_stream_listener_listen(l));
+	nng_stream_listener_accept(l, aio);
+
+	(void) snprintf(pipe, sizeof(pipe), "\\\\.\\pipe\\%s", address+strlen("ipc://"));
+	HANDLE ph = CreateFileA(pipe, READ_CONTROL, 0, NULL, OPEN_EXISTING,
+	    FILE_FLAG_OVERLAPPED, NULL);
+
+	nng_aio_wait(aio);
+	NUTS_PASS(nng_aio_result(aio));
+	HANDLE pd = (HANDLE) nng_aio_get_output(aio, 0);
+
+	NUTS_ASSERT(ph != INVALID_HANDLE_VALUE);
+	NUTS_ASSERT(pd != INVALID_HANDLE_VALUE);
+
+	NUTS_ASSERT(
+	    GetSecurityInfo(ph, SE_KERNEL_OBJECT, DACL_SECURITY_INFORMATION,
+	        NULL, NULL, &dacl, NULL, &psd) == ERROR_SUCCESS);
+
+	NUTS_ASSERT(dacl->AceCount == 1);
+	NUTS_ASSERT(GetAce(dacl, 0, (void **) &ace) == TRUE);
+	allowed = (PACCESS_ALLOWED_ACE) ace;
+	psid    = (PSID) &allowed->SidStart;
+	NUTS_ASSERT(IsValidSid(psid));
+	NUTS_ASSERT(EqualSid(psid, &users) == TRUE);
+
+	CloseHandle(pd);
+	CloseHandle(ph);
+	free(sd);
+	LocalFree(acl);
+	LocalFree(psd);
+	nng_stream_listener_close(l);
+	nng_stream_listener_free(l);
+}
+
+void
+test_ipc_security_descriptor_busy(void)
+{
+	// This test ensures that the descriptor can only be set before
+	// the listener is started.
+	nng_stream_listener *l;
+	char                 address[64];
+	SECURITY_DESCRIPTOR *sd;
+	SID                  users;
+	DWORD                size;
+	PACL                 acl = NULL;
+
+	nuts_scratch_addr("ipc", sizeof(address), address);
+
+	NUTS_PASS(nng_stream_listener_alloc(&l, address));
+	size = sizeof(users);
+	CreateWellKnownSid(WinAuthenticatedUserSid, NULL, &users, &size);
+	sd = sdescAuthUsers(&users, &acl);
+
+	NUTS_ASSERT(sd != NULL);
+	NUTS_ASSERT(acl != NULL);
+
+	NUTS_PASS(nng_stream_listener_listen(l));
+
+	NUTS_FAIL(nng_stream_listener_set_ptr(
+	              l, NNG_OPT_IPC_SECURITY_DESCRIPTOR, sd),
+	    NNG_EBUSY);
+
+	free(sd);
+	nng_stream_listener_close(l);
+	nng_stream_listener_free(l);
+}
+
+void
+test_ipc_security_descriptor_bogus(void)
+{
+	nng_stream_listener *l;
+	char                 address[64];
+
+	nuts_scratch_addr("ipc", sizeof(address), address);
+
+	NUTS_PASS(nng_stream_listener_alloc(&l, address));
+
+	NUTS_FAIL(nng_stream_listener_set_ptr(
+	              l, NNG_OPT_IPC_SECURITY_DESCRIPTOR, NULL),
+	    NNG_EINVAL);
+
+	nng_stream_listener_close(l);
+	nng_stream_listener_free(l);
+}
+
+void
+test_ipc_security_descriptor_dialer(void)
+{
+	nng_stream_dialer   *d;
+	char                 address[64];
+	SECURITY_DESCRIPTOR *sdesc;
+
+	nuts_scratch_addr("ipc", sizeof(address), address);
+	NUTS_PASS(nng_stream_dialer_alloc(&d, address));
+
+	sdesc = calloc(SECURITY_DESCRIPTOR_MIN_LENGTH, 1);
+	NUTS_ASSERT(sdesc != NULL);
+	InitializeSecurityDescriptor(sdesc, SECURITY_DESCRIPTOR_REVISION);
+	NUTS_FAIL(nng_stream_dialer_set_ptr(
+	              d, NNG_OPT_IPC_SECURITY_DESCRIPTOR, sdesc),
+	    NNG_ENOTSUP);
+	free(sdesc);
+	nng_stream_dialer_free(d);
+}
+
+NUTS_TESTS = {
+	{ "ipc security descriptor", test_ipc_security_descriptor },
+	{ "ipc security descriptor busy", test_ipc_security_descriptor_busy },
+	{ "ipc security descriptor bogus",
+	    test_ipc_security_descriptor_bogus },
+	{ "ipc security descriptor dialer",
+	    test_ipc_security_descriptor_dialer },
+	{ NULL, NULL },
+};
diff --git a/src/platform/windows/win_ipclisten.c b/src/platform/windows/win_ipclisten.c
index c5f31b2..07969e9 100644
--- a/src/platform/windows/win_ipclisten.c
+++ b/src/platform/windows/win_ipclisten.c
@@ -1,5 +1,5 @@
 //
-// Copyright 2020 Staysail Systems, Inc. <info@staysail.tech>
+// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
 // Copyright 2018 Capitar IT Group BV <info@capitar.com>
 // Copyright 2019 Devolutions <info@devolutions.net>
 //
@@ -277,11 +277,7 @@ ipc_listener_accept(void *arg, nni_aio *aio)
 		nni_aio_finish_error(aio, NNG_ESTATE);
 		return;
 	}
-	if (l->closed) {
-		nni_mtx_unlock(&l->mtx);
-		nni_aio_finish_error(aio, NNG_ECLOSED);
-		return;
-	}
+	nni_aio_schedule(aio, ipc_accept_cancel, l);
 	nni_list_append(&l->aios, aio);
 	if (nni_list_first(&l->aios) == aio) {
 		ipc_accept_start(l);
diff --git a/src/platform/windows/win_resolv.c b/src/platform/windows/win_resolv.c
index 8628719..528da45 100644
--- a/src/platform/windows/win_resolv.c
+++ b/src/platform/windows/win_resolv.c
@@ -1,5 +1,5 @@
 //
-// Copyright 2020 Staysail Systems, Inc. <info@staysail.tech>
+// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
 // Copyright 2018 Capitar IT Group BV <info@capitar.com>
 //
 // This software is supplied under the terms of the MIT License, a
@@ -26,9 +26,9 @@
 #define NNG_RESOLV_CONCURRENCY 4
 #endif
 
-static nni_mtx  resolv_mtx;
-static nni_cv   resolv_cv;
-static bool     resolv_fini;
+static nni_mtx  resolv_mtx = NNI_MTX_INITIALIZER;
+static nni_cv   resolv_cv = NNI_CV_INITIALIZER(&resolv_mtx);
+static bool     resolv_fini = false;
 static nni_list resolv_aios;
 static nni_thr  resolv_thrs[NNG_RESOLV_CONCURRENCY];
 
@@ -56,11 +56,11 @@ resolv_cancel(nni_aio *aio, void *arg, int rv)
 	resolv_item *item = arg;
 
 	nni_mtx_lock(&resolv_mtx);
-	if (item != nni_aio_get_prov_extra(aio, 0)) {
+	if (item != nni_aio_get_prov_data(aio)) {
 		nni_mtx_unlock(&resolv_mtx);
 		return;
 	}
-	nni_aio_set_prov_extra(aio, 0, NULL);
+	nni_aio_set_prov_data(aio, NULL);
 	if (nni_aio_list_active(aio)) {
 		// We have not been picked up by a resolver thread yet,
 		// so we can just discard everything.
@@ -248,7 +248,7 @@ nni_resolv_ip(const char *host, const char *serv, int family, bool passive,
 	if (resolv_fini) {
 		rv = NNG_ECLOSED;
 	} else {
-		nni_aio_set_prov_extra(aio, 0, item);
+		nni_aio_set_prov_data(aio, item);
 		rv = nni_aio_schedule(aio, resolv_cancel, item);
 	}
 	if (rv != 0) {
@@ -282,7 +282,7 @@ resolv_worker(void *notused)
 			continue;
 		}
 
-		item = nni_aio_get_prov_extra(aio, 0);
+		item = nni_aio_get_prov_data(aio);
 		nni_aio_list_remove(aio);
 
 		// Now attempt to do the work.  This runs synchronously.
@@ -292,7 +292,7 @@ resolv_worker(void *notused)
 
 		// Check to make sure we were not canceled.
 		if ((aio = item->aio) != NULL) {
-			nni_aio_set_prov_extra(aio, 0, NULL);
+			nni_aio_set_prov_data(aio, NULL);
 			item->aio = NULL;
 			item->sa  = NULL;
 
@@ -408,11 +408,9 @@ nni_parse_ip_port(const char *addr, nni_sockaddr *sa)
 int
 nni_win_resolv_sysinit(void)
 {
-	nni_mtx_init(&resolv_mtx);
-	nni_cv_init(&resolv_cv, &resolv_mtx);
 	nni_aio_list_init(&resolv_aios);
-
 	resolv_fini = false;
+
 	for (int i = 0; i < NNG_RESOLV_CONCURRENCY; i++) {
 		int rv = nni_thr_init(&resolv_thrs[i], resolv_worker, NULL);
 		if (rv != 0) {
@@ -437,8 +435,6 @@ nni_win_resolv_sysfini(void)
 	for (int i = 0; i < NNG_RESOLV_CONCURRENCY; i++) {
 		nni_thr_fini(&resolv_thrs[i]);
 	}
-	nni_cv_fini(&resolv_cv);
-	nni_mtx_fini(&resolv_mtx);
 }
 
 #endif // NNG_PLATFORM_WINDOWS
diff --git a/src/platform/windows/win_tcpdial.c b/src/platform/windows/win_tcpdial.c
index 3353d38..9463c24 100644
--- a/src/platform/windows/win_tcpdial.c
+++ b/src/platform/windows/win_tcpdial.c
@@ -79,7 +79,7 @@ nni_tcp_dialer_close(nni_tcp_dialer *d)
 		NNI_LIST_FOREACH (&d->aios, aio) {
 			nni_tcp_conn *c;
 
-			if ((c = nni_aio_get_prov_extra(aio, 0)) != NULL) {
+			if ((c = nni_aio_get_prov_data(aio)) != NULL) {
 				c->conn_rv = NNG_ECLOSED;
 				CancelIoEx((HANDLE) c->s, &c->conn_io.olpd);
 			}
@@ -116,7 +116,7 @@ tcp_dial_cancel(nni_aio *aio, void *arg, int rv)
 	nni_tcp_conn *  c;
 
 	nni_mtx_lock(&d->mtx);
-	if ((c = nni_aio_get_prov_extra(aio, 0)) != NULL) {
+	if ((c = nni_aio_get_prov_data(aio)) != NULL) {
 		if (c->conn_rv == 0) {
 			c->conn_rv = rv;
 		}
@@ -144,7 +144,7 @@ tcp_dial_cb(nni_win_io *io, int rv, size_t cnt)
 	}
 
 	c->conn_aio = NULL;
-	nni_aio_set_prov_extra(aio, 0, NULL);
+	nni_aio_set_prov_data(aio, NULL);
 	nni_aio_list_remove(aio);
 	if (c->conn_rv != 0) {
 		rv = c->conn_rv;
@@ -240,7 +240,7 @@ nni_tcp_dial(nni_tcp_dialer *d, const nni_sockaddr *sa, nni_aio *aio)
 	}
 
 	c->dialer = d;
-	nni_aio_set_prov_extra(aio, 0, c);
+	nni_aio_set_prov_data(aio, c);
 	if ((rv = nni_aio_schedule(aio, tcp_dial_cancel, d)) != 0) {
 		nni_mtx_unlock(&d->mtx);
 		nng_stream_free(&c->ops);
diff --git a/src/platform/windows/win_tcplisten.c b/src/platform/windows/win_tcplisten.c
index 1e87fd3..7cfef8d 100644
--- a/src/platform/windows/win_tcplisten.c
+++ b/src/platform/windows/win_tcplisten.c
@@ -1,5 +1,5 @@
 //
-// Copyright 2020 Staysail Systems, Inc. <info@staysail.tech>
+// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
 // Copyright 2018 Capitar IT Group BV <info@capitar.com>
 // Copyright 2018 Devolutions <info@devolutions.net>
 //
@@ -88,7 +88,6 @@ tcp_accept_cb(nni_win_io *io, int rv, size_t cnt)
 	int               len2;
 	SOCKADDR *        sa1;
 	SOCKADDR *        sa2;
-	DWORD             yes;
 	BOOL              nd;
 	BOOL              ka;
 
@@ -102,7 +101,7 @@ tcp_accept_cb(nni_win_io *io, int rv, size_t cnt)
 		return;
 	}
 	c->conn_aio = NULL;
-	nni_aio_set_prov_extra(aio, 0, NULL);
+	nni_aio_set_prov_data(aio, NULL);
 	nni_aio_list_remove(aio);
 	if (c->conn_rv != 0) {
 		rv = c->conn_rv;
@@ -123,9 +122,8 @@ tcp_accept_cb(nni_win_io *io, int rv, size_t cnt)
 	memcpy(&c->sockname, sa1, len1);
 	memcpy(&c->peername, sa2, len2);
 
-	yes = 1;
 	(void) setsockopt(c->s, SOL_SOCKET, SO_UPDATE_ACCEPT_CONTEXT,
-	    (char *) &yes, sizeof(yes));
+	    (char *) &l->s, sizeof(l->s));
 
 	(void) setsockopt(
 	    c->s, SOL_SOCKET, SO_KEEPALIVE, (char *) &ka, sizeof(ka));
@@ -174,7 +172,7 @@ nni_tcp_listener_close(nni_tcp_listener *l)
 		NNI_LIST_FOREACH (&l->aios, aio) {
 			nni_tcp_conn *c;
 
-			if ((c = nni_aio_get_prov_extra(aio, 0)) != NULL) {
+			if ((c = nni_aio_get_prov_data(aio)) != NULL) {
 				c->conn_rv = NNG_ECLOSED;
 				CancelIoEx((HANDLE) c->s, &c->conn_io.olpd);
 			}
@@ -275,7 +273,7 @@ tcp_accept_cancel(nni_aio *aio, void *arg, int rv)
 	nni_tcp_conn *    c;
 
 	nni_mtx_lock(&l->mtx);
-	if ((c = nni_aio_get_prov_extra(aio, 0)) != NULL) {
+	if ((c = nni_aio_get_prov_data(aio)) != NULL) {
 		if (c->conn_rv == 0) {
 			c->conn_rv = rv;
 		}
@@ -323,10 +321,10 @@ nni_tcp_listener_accept(nni_tcp_listener *l, nni_aio *aio)
 	}
 	c->listener = l;
 	c->conn_aio = aio;
-	nni_aio_set_prov_extra(aio, 0, c);
+	nni_aio_set_prov_data(aio, c);
 	if (((rv = nni_win_io_init(&c->conn_io, tcp_accept_cb, c)) != 0) ||
 	    ((rv = nni_aio_schedule(aio, tcp_accept_cancel, l)) != 0)) {
-		nni_aio_set_prov_extra(aio, 0, NULL);
+		nni_aio_set_prov_data(aio, NULL);
 		nni_mtx_unlock(&l->mtx);
 		nng_stream_free(&c->ops);
 		nni_aio_finish_error(aio, rv);
diff --git a/src/platform/windows/win_thread.c b/src/platform/windows/win_thread.c
index dc9ed12..67ff60b 100644
--- a/src/platform/windows/win_thread.c
+++ b/src/platform/windows/win_thread.c
@@ -26,8 +26,10 @@ static pfnSetThreadDescription set_thread_desc;
 	__atomic_add_fetch(a, b, __ATOMIC_RELAXED)
 #define InterlockedIncrementAcquire64(a) \
 	__atomic_add_fetch(a, 1, __ATOMIC_ACQUIRE)
+#define InterlockedDecrementAcquire64(a) \
+	__atomic_sub_fetch(a, 1, __ATOMIC_ACQUIRE)
 #define InterlockedDecrementRelease64(a) \
-	__atomic_fetch_sub(a, 1, __ATOMIC_RELEASE)
+	__atomic_sub_fetch(a, 1, __ATOMIC_RELEASE)
 #endif
 
 #include <stdlib.h>
@@ -55,13 +57,11 @@ void
 nni_plat_mtx_init(nni_plat_mtx *mtx)
 {
 	InitializeSRWLock(&mtx->srl);
-	mtx->init = 1;
 }
 
 void
 nni_plat_mtx_fini(nni_plat_mtx *mtx)
 {
-	mtx->init = 0;
 }
 
 void
@@ -182,7 +182,7 @@ nni_atomic_set_bool(nni_atomic_bool *v, bool b)
 bool
 nni_atomic_get_bool(nni_atomic_bool *v)
 {
-	return ((bool) InterlockedAdd(&v->v, 0));
+	return ((bool) InterlockedExchangeAdd(&v->v, 0));
 }
 
 bool
@@ -223,6 +223,18 @@ nni_atomic_set64(nni_atomic_u64 *v, uint64_t u)
 	(void) InterlockedExchange64(&v->v, (LONGLONG) u);
 }
 
+void *
+nni_atomic_get_ptr(nni_atomic_ptr *v)
+{
+	return ((void *) (InterlockedExchangeAdd64(&v->v, 0)));
+}
+
+void
+nni_atomic_set_ptr(nni_atomic_ptr *v, void *p)
+{
+	(void) InterlockedExchange64(&v->v, (LONGLONG) (uintptr_t) p);
+}
+
 uint64_t
 nni_atomic_swap64(nni_atomic_u64 *v, uint64_t u)
 {
@@ -255,6 +267,16 @@ nni_atomic_dec64_nv(nni_atomic_u64 *v)
 #endif
 }
 
+void
+nni_atomic_dec64(nni_atomic_u64 *v)
+{
+#ifdef _WIN64
+	InterlockedDecrementAcquire64(&v->v);
+#else
+	InterlockedDecrement64(&v->v);
+#endif
+}
+
 bool
 nni_atomic_cas64(nni_atomic_u64 *v, uint64_t comp, uint64_t new)
 {
@@ -313,6 +335,12 @@ nni_atomic_dec_nv(nni_atomic_int *v)
 	return (InterlockedDecrementRelease(&v->v));
 }
 
+void
+nni_atomic_dec(nni_atomic_int *v)
+{
+	(void) InterlockedDecrementAcquire(&v->v);
+}
+
 bool
 nni_atomic_cas(nni_atomic_int *v, int comp, int new)
 {
@@ -381,7 +409,8 @@ nni_plat_thr_set_name(nni_plat_thr *thr, const char *name)
 		if ((wcs = nni_alloc(len * 2)) == NULL) {
 			return;
 		}
-		(void) MultiByteToWideChar(CP_UTF8, 0, name, len, wcs, len);
+		(void) MultiByteToWideChar(
+		    CP_UTF8, 0, name, (int) len, wcs, (int) len);
 		set_thread_desc(h, wcs);
 		nni_free(wcs, len * 2);
 	}
diff --git a/src/sp/CMakeLists.txt b/src/sp/CMakeLists.txt
index aa790c0..4704f80 100644
--- a/src/sp/CMakeLists.txt
+++ b/src/sp/CMakeLists.txt
@@ -13,6 +13,7 @@ add_subdirectory(protocol)
 add_subdirectory(transport)
 
 nng_sources(
+        protocol.c
         transport.c
         transport.h
 )
diff --git a/src/core/protocol.c b/src/sp/protocol.c
similarity index 93%
rename from src/core/protocol.c
rename to src/sp/protocol.c
index 2123d7e..512b27c 100644
--- a/src/core/protocol.c
+++ b/src/sp/protocol.c
@@ -19,9 +19,6 @@ nni_proto_open(nng_socket *sip, const nni_proto *proto)
 	int       rv;
 	nni_sock *sock;
 
-	if ((rv = nni_init()) != 0) {
-		return (rv);
-	}
 	if ((rv = nni_sock_open(&sock, proto)) == 0) {
 		nng_socket s;
 		s.id     = nni_sock_id(sock); // Keep socket held open.
diff --git a/src/sp/protocol/bus0/CMakeLists.txt b/src/sp/protocol/bus0/CMakeLists.txt
index 01c0b05..ca7ee9b 100644
--- a/src/sp/protocol/bus0/CMakeLists.txt
+++ b/src/sp/protocol/bus0/CMakeLists.txt
@@ -1,5 +1,5 @@
 #
-# Copyright 2020 Staysail Systems, Inc. <info@staysail.tech>
+# Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
 # Copyright 2018 Capitar IT Group BV <info@capitar.com>
 #
 # This software is supplied under the terms of the MIT License, a
@@ -15,4 +15,4 @@ nng_sources_if(NNG_PROTO_BUS0 bus.c)
 nng_headers_if(NNG_PROTO_BUS0 nng/protocol/bus0/bus.h)
 nng_defines_if(NNG_PROTO_BUS0 NNG_HAVE_BUS0)
 
-nng_test(bug1247_test)
\ No newline at end of file
+nng_test(bus_test)
\ No newline at end of file
diff --git a/src/sp/protocol/bus0/bug1247_test.c b/src/sp/protocol/bus0/bug1247_test.c
deleted file mode 100644
index bbc6958..0000000
--- a/src/sp/protocol/bus0/bug1247_test.c
+++ /dev/null
@@ -1,35 +0,0 @@
-//
-// Copyright 2020 Staysail Systems, Inc. <info@staysail.tech>
-//
-// This software is supplied under the terms of the MIT License, a
-// copy of which should be located in the distribution where this
-// file was obtained (LICENSE.txt).  A copy of the license may also be
-// found online at https://opensource.org/licenses/MIT.
-//
-
-#include <nuts.h>
-
-#include <nng/protocol/bus0/bus.h>
-
-void
-test_bug1247(void)
-{
-	nng_socket bus1, bus2;
-	char *     addr;
-
-	NUTS_ADDR(addr, "tcp");
-
-	NUTS_PASS(nng_bus0_open(&bus1));
-	NUTS_PASS(nng_bus0_open(&bus2));
-
-	NUTS_PASS(nng_listen(bus1, addr, NULL, 0));
-	NUTS_FAIL(nng_listen(bus2, addr, NULL, 0), NNG_EADDRINUSE);
-
-	NUTS_PASS(nng_close(bus2));
-	NUTS_PASS(nng_close(bus1));
-}
-
-TEST_LIST = {
-	{ "bug1247", test_bug1247 },
-	{ NULL, NULL },
-};
diff --git a/src/sp/protocol/bus0/bus.c b/src/sp/protocol/bus0/bus.c
index 9a610ac..faa94c1 100644
--- a/src/sp/protocol/bus0/bus.c
+++ b/src/sp/protocol/bus0/bus.c
@@ -1,5 +1,5 @@
 //
-// Copyright 2020 Staysail Systems, Inc. <info@staysail.tech>
+// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
 // Copyright 2018 Capitar IT Group BV <info@capitar.com>
 //
 // This software is supplied under the terms of the MIT License, a
@@ -13,6 +13,7 @@
 
 #include "core/nng_impl.h"
 #include "nng/protocol/bus0/bus.h"
+#include <stdio.h>
 
 // Bus protocol.  The BUS protocol, each peer sends a message to its peers.
 // However, bus protocols do not "forward" (absent a device).  So in order
@@ -26,41 +27,35 @@
 typedef struct bus0_pipe bus0_pipe;
 typedef struct bus0_sock bus0_sock;
 
-static void bus0_sock_getq(bus0_sock *);
 static void bus0_sock_send(void *, nni_aio *);
 static void bus0_sock_recv(void *, nni_aio *);
 
-static void bus0_pipe_getq(bus0_pipe *);
 static void bus0_pipe_recv(bus0_pipe *);
 
-static void bus0_sock_getq_cb(void *);
-static void bus0_sock_getq_cb_raw(void *);
-static void bus0_pipe_getq_cb(void *);
 static void bus0_pipe_send_cb(void *);
 static void bus0_pipe_recv_cb(void *);
-static void bus0_pipe_putq_cb(void *);
 
 // bus0_sock is our per-socket protocol private structure.
 struct bus0_sock {
-	nni_aio * aio_getq;
-	nni_list  pipes;
-	nni_mtx   mtx;
-	nni_msgq *uwq;
-	nni_msgq *urq;
-	bool      raw;
+	nni_list     pipes;
+	nni_mtx      mtx;
+	nni_pollable can_send;
+	nni_pollable can_recv;
+	nni_lmq      recv_msgs;
+	nni_list     recv_wait;
+	int          send_buf;
+	bool         raw;
 };
 
 // bus0_pipe is our per-pipe protocol private structure.
 struct bus0_pipe {
-	nni_pipe *    npipe;
-	bus0_sock *   psock;
-	nni_msgq *    sendq;
+	nni_pipe     *pipe;
+	bus0_sock    *bus;
+	nni_lmq       send_queue;
 	nni_list_node node;
-	nni_aio *     aio_getq;
-	nni_aio *     aio_recv;
-	nni_aio *     aio_send;
-	nni_aio *     aio_putq;
-	nni_mtx       mtx;
+	bool          busy;
+	nni_aio       aio_recv;
+	nni_aio       aio_send;
 };
 
 static void
@@ -68,63 +63,57 @@ bus0_sock_fini(void *arg)
 {
 	bus0_sock *s = arg;
 
-	nni_aio_free(s->aio_getq);
 	nni_mtx_fini(&s->mtx);
+	nni_pollable_fini(&s->can_send);
+	nni_pollable_fini(&s->can_recv);
+	nni_lmq_fini(&s->recv_msgs);
 }
 
-static int
-bus0_sock_init(void *arg, nni_sock *nsock)
+static void
+bus0_sock_init(void *arg, nni_sock *ns)
 {
 	bus0_sock *s = arg;
-	int        rv;
+
+	NNI_ARG_UNUSED(ns);
 
 	NNI_LIST_INIT(&s->pipes, bus0_pipe, node);
 	nni_mtx_init(&s->mtx);
-	if ((rv = nni_aio_alloc(&s->aio_getq, bus0_sock_getq_cb, s)) != 0) {
-		bus0_sock_fini(s);
-		return (rv);
-	}
-	s->uwq = nni_sock_sendq(nsock);
-	s->urq = nni_sock_recvq(nsock);
-	s->raw = false;
+	nni_aio_list_init(&s->recv_wait);
+	nni_pollable_init(&s->can_send);
+	nni_pollable_init(&s->can_recv);
+	nni_lmq_init(&s->recv_msgs, 16);
+	s->send_buf = 16;
 
-	return (0);
+	s->raw = false;
 }
 
-static int
-bus0_sock_init_raw(void *arg, nni_sock *nsock)
+static void
+bus0_sock_init_raw(void *arg, nni_sock *ns)
 {
 	bus0_sock *s = arg;
-	int        rv;
 
-	NNI_LIST_INIT(&s->pipes, bus0_pipe, node);
-	nni_mtx_init(&s->mtx);
-	if ((rv = nni_aio_alloc(&s->aio_getq, bus0_sock_getq_cb_raw, s)) !=
-	    0) {
-		bus0_sock_fini(s);
-		return (rv);
-	}
-	s->uwq = nni_sock_sendq(nsock);
-	s->urq = nni_sock_recvq(nsock);
+	bus0_sock_init(arg, ns);
 	s->raw = true;
-
-	return (0);
 }
 
 static void
 bus0_sock_open(void *arg)
 {
-	bus0_sock *s = arg;
-
-	bus0_sock_getq(s);
+	NNI_ARG_UNUSED(arg);
 }
 
 static void
 bus0_sock_close(void *arg)
 {
 	bus0_sock *s = arg;
+	nni_aio   *aio;
 
-	nni_aio_close(s->aio_getq);
+	nni_mtx_lock(&s->mtx);
+	while ((aio = nni_list_first(&s->recv_wait)) != NULL) {
+		nni_list_remove(&s->recv_wait, aio);
+		nni_aio_finish_error(aio, NNG_ECLOSED);
+	}
+	nni_mtx_unlock(&s->mtx);
 }
 
 static void
@@ -132,10 +121,8 @@ bus0_pipe_stop(void *arg)
 {
 	bus0_pipe *p = arg;
 
-	nni_aio_stop(p->aio_getq);
-	nni_aio_stop(p->aio_send);
-	nni_aio_stop(p->aio_recv);
-	nni_aio_stop(p->aio_putq);
+	nni_aio_stop(&p->aio_send);
+	nni_aio_stop(&p->aio_recv);
 }
 
 static void
@@ -143,33 +130,23 @@ bus0_pipe_fini(void *arg)
 {
 	bus0_pipe *p = arg;
 
-	nni_aio_free(p->aio_getq);
-	nni_aio_free(p->aio_send);
-	nni_aio_free(p->aio_recv);
-	nni_aio_free(p->aio_putq);
-	nni_msgq_fini(p->sendq);
-	nni_mtx_fini(&p->mtx);
+	nni_aio_fini(&p->aio_send);
+	nni_aio_fini(&p->aio_recv);
+	nni_lmq_fini(&p->send_queue);
 }
 
 static int
-bus0_pipe_init(void *arg, nni_pipe *npipe, void *s)
+bus0_pipe_init(void *arg, nni_pipe *np, void *s)
 {
 	bus0_pipe *p = arg;
-	int        rv;
 
+	p->pipe = np;
+	p->bus  = s;
 	NNI_LIST_NODE_INIT(&p->node);
-	nni_mtx_init(&p->mtx);
-	if (((rv = nni_msgq_init(&p->sendq, 16)) != 0) ||
-	    ((rv = nni_aio_alloc(&p->aio_getq, bus0_pipe_getq_cb, p)) != 0) ||
-	    ((rv = nni_aio_alloc(&p->aio_send, bus0_pipe_send_cb, p)) != 0) ||
-	    ((rv = nni_aio_alloc(&p->aio_recv, bus0_pipe_recv_cb, p)) != 0) ||
-	    ((rv = nni_aio_alloc(&p->aio_putq, bus0_pipe_putq_cb, p)) != 0)) {
-		bus0_pipe_fini(p);
-		return (rv);
-	}
+	nni_aio_init(&p->aio_send, bus0_pipe_send_cb, p);
+	nni_aio_init(&p->aio_recv, bus0_pipe_recv_cb, p);
+	nni_lmq_init(&p->send_queue, p->bus->send_buf);
 
-	p->npipe = npipe;
-	p->psock = s;
 	return (0);
 }
 
@@ -177,10 +154,9 @@ static int
 bus0_pipe_start(void *arg)
 {
 	bus0_pipe *p = arg;
-	bus0_sock *s = p->psock;
+	bus0_sock *s = p->bus;
 
-	if (nni_pipe_peer(p->npipe) != NNI_PROTO_BUS_V0) {
-		// Peer protocol mismatch.
+	if (nni_pipe_peer(p->pipe) != NNI_PROTO_BUS_V0) {
 		return (NNG_EPROTO);
 	}
 
@@ -189,7 +165,6 @@ bus0_pipe_start(void *arg)
 	nni_mtx_unlock(&s->mtx);
 
 	bus0_pipe_recv(p);
-	bus0_pipe_getq(p);
 
 	return (0);
 }
@@ -198,203 +173,292 @@ static void
 bus0_pipe_close(void *arg)
 {
 	bus0_pipe *p = arg;
-	bus0_sock *s = p->psock;
+	bus0_sock *s = p->bus;
 
-	nni_aio_close(p->aio_getq);
-	nni_aio_close(p->aio_send);
-	nni_aio_close(p->aio_recv);
-	nni_aio_close(p->aio_putq);
-	nni_msgq_close(p->sendq);
+	nni_aio_close(&p->aio_send);
+	nni_aio_close(&p->aio_recv);
 
 	nni_mtx_lock(&s->mtx);
+	nni_lmq_flush(&p->send_queue);
 	if (nni_list_active(&s->pipes, p)) {
 		nni_list_remove(&s->pipes, p);
 	}
 	nni_mtx_unlock(&s->mtx);
 }
 
-static void
-bus0_pipe_getq_cb(void *arg)
-{
-	bus0_pipe *p = arg;
-
-	if (nni_aio_result(p->aio_getq) != 0) {
-		// closed?
-		nni_pipe_close(p->npipe);
-		return;
-	}
-	nni_aio_set_msg(p->aio_send, nni_aio_get_msg(p->aio_getq));
-	nni_aio_set_msg(p->aio_getq, NULL);
-
-	nni_pipe_send(p->npipe, p->aio_send);
-}
-
 static void
 bus0_pipe_send_cb(void *arg)
 {
 	bus0_pipe *p = arg;
+	bus0_sock *s = p->bus;
+	nni_msg   *msg;
 
-	if (nni_aio_result(p->aio_send) != 0) {
+	if (nni_aio_result(&p->aio_send) != 0) {
 		// closed?
-		nni_msg_free(nni_aio_get_msg(p->aio_send));
-		nni_aio_set_msg(p->aio_send, NULL);
-		nni_pipe_close(p->npipe);
+		nni_msg_free(nni_aio_get_msg(&p->aio_send));
+		nni_aio_set_msg(&p->aio_send, NULL);
+		nni_pipe_close(p->pipe);
 		return;
 	}
 
-	bus0_pipe_getq(p);
+	nni_mtx_lock(&s->mtx);
+	if (nni_lmq_get(&p->send_queue, &msg) == 0) {
+		nni_aio_set_msg(&p->aio_send, msg);
+		nni_pipe_send(p->pipe, &p->aio_send);
+	} else {
+		p->busy = false;
+	}
+	nni_mtx_unlock(&s->mtx);
 }
 
 static void
 bus0_pipe_recv_cb(void *arg)
 {
-	bus0_pipe *p = arg;
-	bus0_sock *s = p->psock;
-	nni_msg *  msg;
+	bus0_pipe *p   = arg;
+	bus0_sock *s   = p->bus;
+	nni_aio   *aio = NULL;
+	nni_msg   *msg;
 
-	if (nni_aio_result(p->aio_recv) != 0) {
-		nni_pipe_close(p->npipe);
+	if (nni_aio_result(&p->aio_recv) != 0) {
+		nni_pipe_close(p->pipe);
 		return;
 	}
-	msg = nni_aio_get_msg(p->aio_recv);
 
+	msg = nni_aio_get_msg(&p->aio_recv);
+	nni_aio_set_msg(&p->aio_recv, NULL);
+	nni_msg_set_pipe(msg, nni_pipe_id(p->pipe));
+
+	nni_mtx_lock(&s->mtx);
 	if (s->raw) {
-		nni_msg_header_append_u32(msg, nni_pipe_id(p->npipe));
+		nni_msg_header_append_u32(msg, nni_pipe_id(p->pipe));
+	}
+
+	if (!nni_list_empty(&s->recv_wait)) {
+		aio = nni_list_first(&s->recv_wait);
+		nni_aio_list_remove(aio);
+		nni_aio_set_msg(aio, msg);
+	} else if (nni_lmq_put(&s->recv_msgs, msg) == 0) {
+		nni_pollable_raise(&s->can_recv);
+	} else {
+		// dropped message due to no room
+		nni_msg_free(msg);
 	}
+	nni_mtx_unlock(&s->mtx);
 
-	nni_msg_set_pipe(msg, nni_pipe_id(p->npipe));
-	nni_aio_set_msg(p->aio_putq, msg);
-	nni_aio_set_msg(p->aio_recv, NULL);
-	nni_msgq_aio_put(s->urq, p->aio_putq);
+	if (aio != NULL) {
+		nni_aio_finish_sync(aio, 0, nni_msg_len(msg));
+	}
+	bus0_pipe_recv(p);
 }
 
 static void
-bus0_pipe_putq_cb(void *arg)
+bus0_pipe_recv(bus0_pipe *p)
 {
-	bus0_pipe *p = arg;
-
-	if (nni_aio_result(p->aio_putq) != 0) {
-		nni_msg_free(nni_aio_get_msg(p->aio_putq));
-		nni_aio_set_msg(p->aio_putq, NULL);
-		nni_pipe_close(p->npipe);
-		return;
-	}
-
-	// Wait for another recv.
-	bus0_pipe_recv(p);
+	nni_pipe_recv(p->pipe, &p->aio_recv);
 }
 
 static void
-bus0_sock_getq_cb(void *arg)
+bus0_sock_send(void *arg, nni_aio *aio)
 {
 	bus0_sock *s = arg;
-	bus0_pipe *p;
-	bus0_pipe *lastp;
-	nni_msg *  msg;
-	nni_msg *  dup;
+	nni_msg   *msg;
+	bus0_pipe *pipe;
+	uint32_t   sender = 0;
+	size_t     len;
 
-	if (nni_aio_result(s->aio_getq) != 0) {
+	if (nni_aio_begin(aio) != 0) {
 		return;
 	}
 
-	msg = nni_aio_get_msg(s->aio_getq);
+	msg = nni_aio_get_msg(aio);
+	len = nni_msg_len(msg);
+	nni_aio_set_msg(aio, NULL);
 
-	// We ignore any headers present for cooked mode.
-	nni_msg_header_clear(msg);
+	if (s->raw) {
+		// In raw mode, we look for the message header, to see if it
+		// is being resent from another pipe (e.g. via a device).
+		// We don't want to send it back to the originator.
+		if (nni_msg_header_len(msg) >= sizeof(uint32_t)) {
+			sender = nni_msg_header_trim_u32(msg);
+		}
+	} else {
+		// In cooked mode just strip the header.
+		nni_msg_header_clear(msg);
+	}
 
 	nni_mtx_lock(&s->mtx);
-	lastp = nni_list_last(&s->pipes);
-	NNI_LIST_FOREACH (&s->pipes, p) {
-		if (p != lastp) {
-			if (nni_msg_dup(&dup, msg) != 0) {
-				continue;
-			}
-		} else {
-			dup = msg;
-			msg = NULL;
+	NNI_LIST_FOREACH (&s->pipes, pipe) {
+
+		if (s->raw && nni_pipe_id(pipe->pipe) == sender) {
+			continue;
 		}
-		if (nni_msgq_tryput(p->sendq, dup) != 0) {
-			nni_msg_free(dup);
+
+		// if the pipe isn't busy, then send this message direct.
+		if (!pipe->busy) {
+			pipe->busy = true;
+			nni_msg_clone(msg);
+			nni_aio_set_msg(&pipe->aio_send, msg);
+			nni_pipe_send(pipe->pipe, &pipe->aio_send);
+		} else if (!nni_lmq_full(&pipe->send_queue)) {
+			nni_msg_clone(msg);
+			nni_lmq_put(&pipe->send_queue, msg);
 		}
 	}
 	nni_mtx_unlock(&s->mtx);
-	nni_msg_free(msg);
 
-	bus0_sock_getq(s);
+	nni_msg_free(msg);
+	nni_aio_finish(aio, 0, len);
 }
 
 static void
-bus0_sock_getq_cb_raw(void *arg)
+bus0_recv_cancel(nng_aio *aio, void *arg, int rv)
 {
 	bus0_sock *s = arg;
-	bus0_pipe *p;
-	nni_msg *  msg;
-	uint32_t   sender;
-
-	if (nni_aio_result(s->aio_getq) != 0) {
-		return;
+	nni_mtx_lock(&s->mtx);
+	if (nni_aio_list_active(aio)) {
+		nni_aio_list_remove(aio);
+		nni_aio_finish_error(aio, rv);
 	}
+	nni_mtx_unlock(&s->mtx);
+}
 
-	msg = nni_aio_get_msg(s->aio_getq);
+static void
+bus0_sock_recv(void *arg, nni_aio *aio)
+{
+	bus0_sock *s = arg;
+	nni_msg   *msg;
 
-	// The header being present indicates that the message
-	// was received locally and we are rebroadcasting. (Device
-	// is doing this probably.)  In this case grab the pipe
-	// ID from the header, so we can exclude it.
-	if (nni_msg_header_len(msg) >= 4) {
-		sender = nni_msg_header_trim_u32(msg);
-	} else {
-		sender = 0;
+	if (nni_aio_begin(aio) != 0) {
+		return;
 	}
 
 	nni_mtx_lock(&s->mtx);
-	NNI_LIST_FOREACH (&s->pipes, p) {
-		if (nni_pipe_id(p->npipe) == sender) {
-			continue;
-		}
-		nni_msg_clone(msg);
-		if (nni_msgq_tryput(p->sendq, msg) != 0) {
-			nni_msg_free(msg);
+again:
+	if (nni_lmq_empty(&s->recv_msgs)) {
+		int rv;
+		if ((rv = nni_aio_schedule(aio, bus0_recv_cancel, s)) != 0) {
+			nni_mtx_unlock(&s->mtx);
+			nni_aio_finish_error(aio, rv);
+			return;
 		}
+		nni_list_append(&s->recv_wait, aio);
+		nni_mtx_unlock(&s->mtx);
+		return;
+	}
+
+	(void) nni_lmq_get(&s->recv_msgs, &msg);
+
+	if (nni_lmq_empty(&s->recv_msgs)) {
+		nni_pollable_clear(&s->can_recv);
 	}
+	if ((msg = nni_msg_unique(msg)) == NULL) {
+		goto again;
+	}
+	nni_aio_set_msg(aio, msg);
 	nni_mtx_unlock(&s->mtx);
-	nni_msg_free(msg);
+	nni_aio_finish(aio, 0, nni_msg_len(msg));
+}
 
-	bus0_sock_getq(s);
+static int
+bus0_sock_get_send_fd(void *arg, void *buf, size_t *szp, nni_type t)
+{
+	bus0_sock *sock = arg;
+	int        fd;
+	int        rv;
+	nni_mtx_lock(&sock->mtx);
+	// BUS sockets are *always* writable (best effort)
+	nni_pollable_raise(&sock->can_send);
+	rv = nni_pollable_getfd(&sock->can_send, &fd);
+	nni_mtx_unlock(&sock->mtx);
+
+	if (rv == 0) {
+		rv = nni_copyout_int(fd, buf, szp, t);
+	}
+	return (rv);
 }
 
-static void
-bus0_sock_getq(bus0_sock *s)
+static int
+bus0_sock_get_recv_fd(void *arg, void *buf, size_t *szp, nni_opt_type t)
 {
-	nni_msgq_aio_get(s->uwq, s->aio_getq);
+	bus0_sock *s = arg;
+	int        rv;
+	int        fd;
+
+	if ((rv = nni_pollable_getfd(&s->can_recv, &fd)) == 0) {
+		rv = nni_copyout_int(fd, buf, szp, t);
+	}
+	return (rv);
 }
 
-static void
-bus0_pipe_getq(bus0_pipe *p)
+static int
+bus0_sock_get_recv_buf_len(void *arg, void *buf, size_t *szp, nni_type t)
 {
-	nni_msgq_aio_get(p->sendq, p->aio_getq);
+	bus0_sock *s = arg;
+	int        val;
+	nni_mtx_lock(&s->mtx);
+	val = (int) nni_lmq_cap(&s->recv_msgs);
+	nni_mtx_unlock(&s->mtx);
+
+	return (nni_copyout_int(val, buf, szp, t));
 }
 
-static void
-bus0_pipe_recv(bus0_pipe *p)
+static int
+bus0_sock_get_send_buf_len(void *arg, void *buf, size_t *szp, nni_type t)
 {
-	nni_pipe_recv(p->npipe, p->aio_recv);
+	bus0_sock *s = arg;
+	int        val;
+	nni_mtx_lock(&s->mtx);
+	val = s->send_buf;
+	nni_mtx_unlock(&s->mtx);
+	return (nni_copyout_int(val, buf, szp, t));
 }
 
-static void
-bus0_sock_send(void *arg, nni_aio *aio)
+static int
+bus0_sock_set_recv_buf_len(void *arg, const void *buf, size_t sz, nni_type t)
 {
 	bus0_sock *s = arg;
+	int        val;
+	int        rv;
+
+	if ((rv = nni_copyin_int(&val, buf, sz, 1, 8192, t)) != 0) {
+		return (rv);
+	}
+	nni_mtx_lock(&s->mtx);
+	if ((rv = nni_lmq_resize(&s->recv_msgs, (size_t) val)) != 0) {
+		nni_mtx_unlock(&s->mtx);
+		return (rv);
+	}
 
-	nni_msgq_aio_put(s->uwq, aio);
+	nni_mtx_unlock(&s->mtx);
+	return (0);
 }
 
-static void
-bus0_sock_recv(void *arg, nni_aio *aio)
+static int
+bus0_sock_set_send_buf_len(void *arg, const void *buf, size_t sz, nni_type t)
 {
 	bus0_sock *s = arg;
+	bus0_pipe *p;
+	int        val;
+	int        rv;
+
+	if ((rv = nni_copyin_int(&val, buf, sz, 1, 8192, t)) != 0) {
+		return (rv);
+	}
 
-	nni_msgq_aio_get(s->urq, aio);
+	nni_mtx_lock(&s->mtx);
+	s->send_buf = val;
+	NNI_LIST_FOREACH (&s->pipes, p) {
+		// If we fail part way through (should only be ENOMEM), we
+		// stop short.  The others would likely fail for ENOMEM as
+		// well anyway.  There is a weird effect here where the
+		// buffers may have been set for *some* of the pipes, but
+		// we have no way to correct partial failure.
+		if ((rv = nni_lmq_resize(&p->send_queue, (size_t) val)) != 0) {
+			break;
+		}
+	}
+	nni_mtx_unlock(&s->mtx);
+	return (rv);
 }
 
 static nni_proto_pipe_ops bus0_pipe_ops = {
@@ -407,6 +471,24 @@ static nni_proto_pipe_ops bus0_pipe_ops = {
 };
 
 static nni_option bus0_sock_options[] = {
+	{
+	    .o_name = NNG_OPT_SENDFD,
+	    .o_get  = bus0_sock_get_send_fd,
+	},
+	{
+	    .o_name = NNG_OPT_RECVFD,
+	    .o_get  = bus0_sock_get_recv_fd,
+	},
+	{
+	    .o_name = NNG_OPT_RECVBUF,
+	    .o_get  = bus0_sock_get_recv_buf_len,
+	    .o_set  = bus0_sock_set_recv_buf_len,
+	},
+	{
+	    .o_name = NNG_OPT_SENDBUF,
+	    .o_get  = bus0_sock_get_send_buf_len,
+	    .o_set  = bus0_sock_set_send_buf_len,
+	},
 	// terminate list
 	{
 	    .o_name = NULL,
@@ -454,13 +536,13 @@ static nni_proto bus0_proto_raw = {
 };
 
 int
-nng_bus0_open(nng_socket *sidp)
+nng_bus0_open(nng_socket *id)
 {
-	return (nni_proto_open(sidp, &bus0_proto));
+	return (nni_proto_open(id, &bus0_proto));
 }
 
 int
-nng_bus0_open_raw(nng_socket *sidp)
+nng_bus0_open_raw(nng_socket *id)
 {
-	return (nni_proto_open(sidp, &bus0_proto_raw));
+	return (nni_proto_open(id, &bus0_proto_raw));
 }
diff --git a/src/sp/protocol/bus0/bus_test.c b/src/sp/protocol/bus0/bus_test.c
new file mode 100644
index 0000000..6a21497
--- /dev/null
+++ b/src/sp/protocol/bus0/bus_test.c
@@ -0,0 +1,423 @@
+//
+// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
+//
+// This software is supplied under the terms of the MIT License, a
+// copy of which should be located in the distribution where this
+// file was obtained (LICENSE.txt).  A copy of the license may also be
+// found online at https://opensource.org/licenses/MIT.
+//
+
+#include <nuts.h>
+
+#include <nng/protocol/bus0/bus.h>
+
+#define SECOND 1000
+
+void
+test_bus_identity(void)
+{
+	nng_socket s;
+	int        p;
+	char      *n;
+
+	NUTS_PASS(nng_bus0_open(&s));
+	NUTS_PASS(nng_socket_get_int(s, NNG_OPT_PROTO, &p));
+	NUTS_TRUE(p == NNG_BUS0_SELF);
+	NUTS_PASS(nng_socket_get_int(s, NNG_OPT_PEER, &p));
+	NUTS_TRUE(p == NNG_BUS0_PEER); // 49
+	NUTS_PASS(nng_socket_get_string(s, NNG_OPT_PROTONAME, &n));
+	NUTS_MATCH(n, NNG_BUS0_SELF_NAME);
+	nng_strfree(n);
+	NUTS_PASS(nng_socket_get_string(s, NNG_OPT_PEERNAME, &n));
+	NUTS_MATCH(n, NNG_BUS0_PEER_NAME);
+	nng_strfree(n);
+	NUTS_CLOSE(s);
+}
+
+static void
+test_bus_star(void)
+{
+	nng_socket s1, s2, s3;
+
+	NUTS_PASS(nng_bus0_open(&s1));
+	NUTS_PASS(nng_bus0_open(&s2));
+	NUTS_PASS(nng_bus0_open(&s3));
+
+	NUTS_PASS(nng_socket_set_ms(s1, NNG_OPT_RECVTIMEO, SECOND));
+	NUTS_PASS(nng_socket_set_ms(s2, NNG_OPT_RECVTIMEO, SECOND));
+	NUTS_PASS(nng_socket_set_ms(s3, NNG_OPT_RECVTIMEO, SECOND));
+
+	NUTS_MARRY(s1, s2);
+	NUTS_MARRY(s1, s3);
+
+	NUTS_SEND(s1, "one");
+	NUTS_RECV(s2, "one");
+	NUTS_RECV(s3, "one");
+
+	NUTS_SEND(s2, "two");
+	NUTS_SEND(s1, "one");
+	NUTS_RECV(s1, "two");
+	NUTS_RECV(s2, "one");
+	NUTS_RECV(s3, "one");
+
+	NUTS_CLOSE(s1);
+	NUTS_CLOSE(s2);
+	NUTS_CLOSE(s3);
+}
+
+static void
+test_bus_device(void)
+{
+	nng_socket s1, s2, s3;
+	nng_socket none = NNG_SOCKET_INITIALIZER;
+	nng_aio *aio;
+
+	NUTS_PASS(nng_bus0_open_raw(&s1));
+	NUTS_PASS(nng_bus0_open(&s2));
+	NUTS_PASS(nng_bus0_open(&s3));
+	NUTS_PASS(nng_aio_alloc(&aio, NULL, NULL));
+
+	NUTS_PASS(nng_socket_set_ms(s1, NNG_OPT_RECVTIMEO, SECOND));
+	NUTS_PASS(nng_socket_set_ms(s2, NNG_OPT_RECVTIMEO, SECOND));
+	NUTS_PASS(nng_socket_set_ms(s3, NNG_OPT_RECVTIMEO, SECOND));
+
+	NUTS_MARRY(s1, s2);
+	NUTS_MARRY(s1, s3);
+
+	nng_device_aio(aio, s1, none);
+
+	NUTS_SEND(s2, "two");
+	NUTS_SEND(s3, "three");
+	NUTS_RECV(s2, "three");
+	NUTS_RECV(s3, "two");
+
+	NUTS_CLOSE(s1);
+	NUTS_CLOSE(s2);
+	NUTS_CLOSE(s3);
+
+	nng_aio_free(aio);
+}
+
+static void
+test_bus_validate_peer(void)
+{
+	nng_socket s1, s2;
+	nng_stat  *stats;
+	nng_stat  *reject;
+	char      *addr;
+
+	NUTS_ADDR(addr, "inproc");
+	NUTS_PASS(nng_bus0_open(&s1));
+	NUTS_PASS(nng_pair0_open(&s2));
+
+	NUTS_PASS(nng_listen(s1, addr, NULL, 0));
+	NUTS_PASS(nng_dial(s2, addr, NULL, NNG_FLAG_NONBLOCK));
+
+	NUTS_SLEEP(100);
+	NUTS_PASS(nng_stats_get(&stats));
+
+	NUTS_TRUE(stats != NULL);
+	NUTS_TRUE((reject = nng_stat_find_socket(stats, s1)) != NULL);
+	NUTS_TRUE((reject = nng_stat_find(reject, "reject")) != NULL);
+
+	NUTS_TRUE(nng_stat_type(reject) == NNG_STAT_COUNTER);
+	NUTS_TRUE(nng_stat_value(reject) > 0);
+
+	NUTS_CLOSE(s1);
+	NUTS_CLOSE(s2);
+	nng_stats_free(stats);
+}
+
+static void
+test_bus_no_context(void)
+{
+	nng_socket s;
+	nng_ctx    ctx;
+
+	NUTS_PASS(nng_bus0_open(&s));
+	NUTS_FAIL(nng_ctx_open(&ctx, s), NNG_ENOTSUP);
+	NUTS_CLOSE(s);
+}
+
+static void
+test_bus_recv_cancel(void)
+{
+	nng_socket s1;
+	nng_aio   *aio;
+
+	NUTS_PASS(nng_bus0_open(&s1));
+	NUTS_PASS(nng_aio_alloc(&aio, NULL, NULL));
+
+	nng_aio_set_timeout(aio, SECOND);
+	nng_recv_aio(s1, aio);
+	nng_aio_abort(aio, NNG_ECANCELED);
+
+	nng_aio_wait(aio);
+	NUTS_FAIL(nng_aio_result(aio), NNG_ECANCELED);
+	NUTS_CLOSE(s1);
+	nng_aio_free(aio);
+}
+
+static void
+test_bus_close_recv_abort(void)
+{
+	nng_socket s1;
+	nng_aio   *aio;
+
+	NUTS_PASS(nng_bus0_open(&s1));
+	NUTS_PASS(nng_aio_alloc(&aio, NULL, NULL));
+
+	nng_aio_set_timeout(aio, SECOND);
+	nng_recv_aio(s1, aio);
+	NUTS_CLOSE(s1);
+
+	nng_aio_wait(aio);
+	NUTS_FAIL(nng_aio_result(aio), NNG_ECLOSED);
+	nng_aio_free(aio);
+}
+
+static void
+test_bus_aio_stopped(void)
+{
+	nng_socket s1;
+	nng_aio   *aio;
+	nng_msg   *msg;
+
+	NUTS_PASS(nng_bus0_open(&s1));
+	NUTS_PASS(nng_msg_alloc(&msg, 0));
+	NUTS_PASS(nng_aio_alloc(&aio, NULL, NULL));
+	nng_aio_stop(aio);
+
+	nng_recv_aio(s1, aio);
+	nng_aio_wait(aio);
+	NUTS_FAIL(nng_aio_result(aio), NNG_ECANCELED);
+
+	nng_aio_set_msg(aio, msg);
+	nng_send_aio(s1, aio);
+	nng_aio_wait(aio);
+	NUTS_FAIL(nng_aio_result(aio), NNG_ECANCELED);
+
+	nng_aio_free(aio);
+	nng_msg_free(msg);
+	NUTS_CLOSE(s1);
+}
+
+static void
+test_bus_send_no_pipes(void)
+{
+	nng_socket s1;
+
+	NUTS_PASS(nng_bus0_open(&s1));
+	NUTS_SEND(s1, "DROP1");
+	NUTS_SEND(s1, "DROP2");
+	NUTS_CLOSE(s1);
+}
+
+static void
+test_bus_send_flood(void)
+{
+	nng_socket s1, s2;
+
+	NUTS_PASS(nng_bus0_open(&s1));
+	NUTS_PASS(nng_bus0_open(&s2));
+	NUTS_PASS(nng_socket_set_int(s2, NNG_OPT_SENDBUF, 1));
+
+	// Even after connect (no message yet)
+	NUTS_MARRY(s1, s2);
+
+	// Even if we send messages.
+	for (int i = 0; i < 1000; i++) {
+		NUTS_SEND(s2, "one thousand");
+	}
+
+	NUTS_CLOSE(s1);
+	NUTS_CLOSE(s2);
+}
+
+static void
+test_bus_poll_readable(void)
+{
+	int        fd;
+	nng_socket s1, s2;
+
+	NUTS_PASS(nng_bus0_open(&s1));
+	NUTS_PASS(nng_bus0_open(&s2));
+	NUTS_PASS(nng_socket_set_ms(s1, NNG_OPT_RECVTIMEO, 1000));
+	NUTS_PASS(nng_socket_set_ms(s2, NNG_OPT_SENDTIMEO, 1000));
+	NUTS_PASS(nng_socket_get_int(s1, NNG_OPT_RECVFD, &fd));
+	NUTS_TRUE(fd >= 0);
+
+	// Not readable if not connected!
+	NUTS_TRUE(nuts_poll_fd(fd) == false);
+
+	// Even after connect (no message yet)
+	NUTS_MARRY(s2, s1);
+	NUTS_TRUE(nuts_poll_fd(fd) == false);
+
+	// But once we send messages, it is.
+	// We have to send a request, in order to send a reply.
+	NUTS_SEND(s2, "abc");
+	NUTS_SLEEP(100);
+	NUTS_TRUE(nuts_poll_fd(fd));
+
+	// and receiving makes it no longer ready
+	NUTS_RECV(s1, "abc");
+	NUTS_TRUE(nuts_poll_fd(fd) == false);
+
+	NUTS_CLOSE(s2);
+	NUTS_CLOSE(s1);
+}
+
+static void
+test_bus_poll_writeable(void)
+{
+	int        fd;
+	nng_socket s1, s2;
+
+	NUTS_PASS(nng_bus0_open(&s1));
+	NUTS_PASS(nng_bus0_open(&s2));
+	NUTS_PASS(nng_socket_set_int(s2, NNG_OPT_SENDBUF, 1));
+	NUTS_PASS(nng_socket_get_int(s2, NNG_OPT_SENDFD, &fd));
+	NUTS_TRUE(fd >= 0);
+
+	// Pub is *always* writeable
+	NUTS_TRUE(nuts_poll_fd(fd));
+
+	// Even after connect (no message yet)
+	NUTS_MARRY(s1, s2);
+	NUTS_TRUE(nuts_poll_fd(fd));
+
+	// Even if we send messages.
+	NUTS_SEND(s2, "abc");
+	NUTS_TRUE(nuts_poll_fd(fd));
+
+	NUTS_CLOSE(s1);
+	NUTS_CLOSE(s2);
+}
+
+static void
+test_bus_recv_buf_option(void)
+{
+	nng_socket  s;
+	int         v;
+	bool        b;
+	size_t      sz;
+	const char *opt = NNG_OPT_RECVBUF;
+
+	NUTS_PASS(nng_bus0_open(&s));
+
+	NUTS_PASS(nng_socket_set_int(s, opt, 1));
+	NUTS_FAIL(nng_socket_set_int(s, opt, 0), NNG_EINVAL);
+	NUTS_FAIL(nng_socket_set_int(s, opt, -1), NNG_EINVAL);
+	NUTS_FAIL(nng_socket_set_int(s, opt, 1000000), NNG_EINVAL);
+	NUTS_PASS(nng_socket_set_int(s, opt, 3));
+	NUTS_PASS(nng_socket_get_int(s, opt, &v));
+	NUTS_TRUE(v == 3);
+	v  = 0;
+	sz = sizeof(v);
+	NUTS_PASS(nng_socket_get(s, opt, &v, &sz));
+	NUTS_TRUE(v == 3);
+	NUTS_TRUE(sz == sizeof(v));
+
+	NUTS_FAIL(nng_socket_set(s, opt, "", 1), NNG_EINVAL);
+	sz = 1;
+	NUTS_FAIL(nng_socket_get(s, opt, &v, &sz), NNG_EINVAL);
+	NUTS_FAIL(nng_socket_set_bool(s, opt, true), NNG_EBADTYPE);
+	NUTS_FAIL(nng_socket_get_bool(s, opt, &b), NNG_EBADTYPE);
+
+	NUTS_CLOSE(s);
+}
+
+static void
+test_bus_send_buf_option(void)
+{
+	nng_socket  s1;
+	nng_socket  s2;
+	int         v;
+	bool        b;
+	size_t      sz;
+	const char *opt = NNG_OPT_SENDBUF;
+
+	NUTS_PASS(nng_bus0_open(&s1));
+	NUTS_PASS(nng_bus0_open(&s2));
+	NUTS_MARRY(s1, s2);
+
+	NUTS_PASS(nng_socket_set_int(s1, opt, 1));
+	NUTS_FAIL(nng_socket_set_int(s1, opt, 0), NNG_EINVAL);
+	NUTS_FAIL(nng_socket_set_int(s1, opt, -1), NNG_EINVAL);
+	NUTS_FAIL(nng_socket_set_int(s1, opt, 1000000), NNG_EINVAL);
+	NUTS_PASS(nng_socket_set_int(s1, opt, 3));
+	NUTS_PASS(nng_socket_get_int(s1, opt, &v));
+	NUTS_TRUE(v == 3);
+	v  = 0;
+	sz = sizeof(v);
+	NUTS_PASS(nng_socket_get(s1, opt, &v, &sz));
+	NUTS_TRUE(v == 3);
+	NUTS_TRUE(sz == sizeof(v));
+
+	NUTS_FAIL(nng_socket_set(s1, opt, "", 1), NNG_EINVAL);
+	sz = 1;
+	NUTS_FAIL(nng_socket_get(s1, opt, &v, &sz), NNG_EINVAL);
+	NUTS_FAIL(nng_socket_set_bool(s1, opt, true), NNG_EBADTYPE);
+	NUTS_FAIL(nng_socket_get_bool(s1, opt, &b), NNG_EBADTYPE);
+
+	NUTS_CLOSE(s1);
+	NUTS_CLOSE(s2);
+}
+
+static void
+test_bus_cooked(void)
+{
+	nng_socket s;
+	bool       b;
+
+	NUTS_PASS(nng_bus0_open(&s));
+	NUTS_PASS(nng_socket_get_bool(s, NNG_OPT_RAW, &b));
+	NUTS_TRUE(!b);
+	NUTS_FAIL(nng_socket_set_bool(s, NNG_OPT_RAW, true), NNG_EREADONLY);
+	NUTS_PASS(nng_close(s));
+
+	// raw pub only differs in the option setting
+	NUTS_PASS(nng_bus0_open_raw(&s));
+	NUTS_PASS(nng_socket_get_bool(s, NNG_OPT_RAW, &b));
+	NUTS_TRUE(b);
+	NUTS_CLOSE(s);
+}
+
+static void
+test_bug1247(void)
+{
+	nng_socket bus1, bus2;
+	char      *addr;
+
+	NUTS_ADDR(addr, "tcp");
+
+	NUTS_PASS(nng_bus0_open(&bus1));
+	NUTS_PASS(nng_bus0_open(&bus2));
+
+	NUTS_PASS(nng_listen(bus1, addr, NULL, 0));
+	NUTS_FAIL(nng_listen(bus2, addr, NULL, 0), NNG_EADDRINUSE);
+
+	NUTS_CLOSE(bus2);
+	NUTS_CLOSE(bus1);
+}
+
+TEST_LIST = {
+	{ "bus identity", test_bus_identity },
+	{ "bus star", test_bus_star },
+	{ "bus device", test_bus_device },
+	{ "bus validate peer", test_bus_validate_peer },
+	{ "bus no context", test_bus_no_context },
+	{ "bus poll read", test_bus_poll_readable },
+	{ "bus poll write", test_bus_poll_writeable },
+	{ "bus send no pipes", test_bus_send_no_pipes },
+	{ "bus send flood", test_bus_send_flood },
+	{ "bus recv cancel", test_bus_recv_cancel },
+	{ "bus close recv abort", test_bus_close_recv_abort },
+	{ "bus aio stopped", test_bus_aio_stopped },
+	{ "bus recv buf option", test_bus_recv_buf_option },
+	{ "bus send buf option", test_bus_send_buf_option },
+	{ "bus cooked", test_bus_cooked },
+	{ "bug1247", test_bug1247 },
+	{ NULL, NULL },
+};
diff --git a/src/sp/protocol/pair0/pair.c b/src/sp/protocol/pair0/pair.c
index c2407d8..4abeb16 100644
--- a/src/sp/protocol/pair0/pair.c
+++ b/src/sp/protocol/pair0/pair.c
@@ -32,7 +32,7 @@ static void pair0_pipe_send(pair0_pipe *, nni_msg *);
 
 // pair0_sock is our per-socket protocol private structure.
 struct pair0_sock {
-	pair0_pipe * p;
+	pair0_pipe  *p;
 	nni_mtx      mtx;
 	nni_lmq      wmq;
 	nni_list     waq;
@@ -44,18 +44,18 @@ struct pair0_sock {
 	bool         wr_ready; // pipe ready for write
 };
 
-// An pair0_pipe is our per-pipe protocol private structure.  We keep
+// A pair0_pipe is our per-pipe protocol private structure.  We keep
 // one of these even though in theory we'd only have a single underlying
 // pipe.  The separate data structure is more like other protocols that do
 // manage multiple pipes.
 struct pair0_pipe {
-	nni_pipe *  pipe;
+	nni_pipe   *pipe;
 	pair0_sock *pair;
 	nni_aio     aio_send;
 	nni_aio     aio_recv;
 };
 
-static int
+static void
 pair0_sock_init(void *arg, nni_sock *sock)
 {
 	pair0_sock *s = arg;
@@ -71,7 +71,6 @@ pair0_sock_init(void *arg, nni_sock *sock)
 	nni_pollable_init(&s->readable);
 
 	s->p = NULL;
-	return (0);
 }
 
 static void
@@ -190,8 +189,8 @@ pair0_pipe_recv_cb(void *arg)
 {
 	pair0_pipe *p = arg;
 	pair0_sock *s = p->pair;
-	nni_msg *   msg;
-	nni_aio *   a;
+	nni_msg    *msg;
+	nni_aio    *a;
 
 	if (nni_aio_result(&p->aio_recv) != 0) {
 		nni_pipe_close(p->pipe);
@@ -217,7 +216,7 @@ pair0_pipe_recv_cb(void *arg)
 
 	// maybe we have room in the rmq?
 	if (!nni_lmq_full(&s->rmq)) {
-		nni_lmq_putq(&s->rmq, msg);
+		nni_lmq_put(&s->rmq, msg);
 		nni_aio_set_msg(&p->aio_recv, NULL);
 		nni_pipe_recv(p->pipe, &p->aio_recv);
 	} else {
@@ -231,8 +230,8 @@ static void
 pair0_send_sched(pair0_sock *s)
 {
 	pair0_pipe *p;
-	nni_msg *   m;
-	nni_aio *   a = NULL;
+	nni_msg    *m;
+	nni_aio    *a = NULL;
 	size_t      l = 0;
 
 	nni_mtx_lock(&s->mtx);
@@ -245,14 +244,14 @@ pair0_send_sched(pair0_sock *s)
 	s->wr_ready = true;
 
 	// if message waiting in buffered queue, then we prefer that.
-	if (nni_lmq_getq(&s->wmq, &m) == 0) {
+	if (nni_lmq_get(&s->wmq, &m) == 0) {
 		pair0_pipe_send(p, m);
 
 		if ((a = nni_list_first(&s->waq)) != NULL) {
 			nni_aio_list_remove(a);
 			m = nni_aio_get_msg(a);
 			l = nni_msg_len(m);
-			nni_lmq_putq(&s->wmq, m);
+			nni_lmq_put(&s->wmq, m);
 		}
 
 	} else if ((a = nni_list_first(&s->waq)) != NULL) {
@@ -303,16 +302,16 @@ static void
 pair0_sock_close(void *arg)
 {
 	pair0_sock *s = arg;
-	nni_aio *   a;
-	nni_msg *   m;
+	nni_aio    *a;
+	nni_msg    *m;
 	nni_mtx_lock(&s->mtx);
 	while (((a = nni_list_first(&s->raq)) != NULL) ||
 	    ((a = nni_list_first(&s->waq)) != NULL)) {
 		nni_aio_list_remove(a);
 		nni_aio_finish_error(a, NNG_ECLOSED);
 	}
-	while ((nni_lmq_getq(&s->rmq, &m) == 0) ||
-	    (nni_lmq_getq(&s->wmq, &m) == 0)) {
+	while ((nni_lmq_get(&s->rmq, &m) == 0) ||
+	    (nni_lmq_get(&s->wmq, &m) == 0)) {
 		nni_msg_free(m);
 	}
 	nni_mtx_unlock(&s->mtx);
@@ -334,7 +333,7 @@ static void
 pair0_sock_send(void *arg, nni_aio *aio)
 {
 	pair0_sock *s = arg;
-	nni_msg *   m;
+	nni_msg    *m;
 	size_t      len;
 	int         rv;
 
@@ -359,7 +358,7 @@ pair0_sock_send(void *arg, nni_aio *aio)
 	}
 
 	// Can we maybe queue it.
-	if (nni_lmq_putq(&s->wmq, m) == 0) {
+	if (nni_lmq_put(&s->wmq, m) == 0) {
 		// Yay, we can.  So we're done.
 		nni_aio_set_msg(aio, NULL);
 		nni_aio_finish(aio, 0, len);
@@ -384,7 +383,7 @@ pair0_sock_recv(void *arg, nni_aio *aio)
 {
 	pair0_sock *s = arg;
 	pair0_pipe *p;
-	nni_msg *   m;
+	nni_msg    *m;
 	int         rv;
 
 	if (nni_aio_begin(aio) != 0) {
@@ -396,14 +395,14 @@ pair0_sock_recv(void *arg, nni_aio *aio)
 
 	// Buffered read.  If there is a message waiting for us, pick
 	// it up.  We might need to post another read request as well.
-	if (nni_lmq_getq(&s->rmq, &m) == 0) {
+	if (nni_lmq_get(&s->rmq, &m) == 0) {
 		nni_aio_set_msg(aio, m);
 		nni_aio_finish(aio, 0, nni_msg_len(m));
 		if (s->rd_ready) {
 			s->rd_ready = false;
 			m           = nni_aio_get_msg(&p->aio_recv);
 			nni_aio_set_msg(&p->aio_recv, NULL);
-			nni_lmq_putq(&s->rmq, m);
+			nni_lmq_put(&s->rmq, m);
 			nni_pipe_recv(p->pipe, &p->aio_recv);
 		}
 		if (nni_lmq_empty(&s->rmq)) {
@@ -463,7 +462,7 @@ pair0_get_send_buf_len(void *arg, void *buf, size_t *szp, nni_opt_type t)
 	int         val;
 
 	nni_mtx_lock(&s->mtx);
-	val = nni_lmq_cap(&s->wmq);
+	val = (int) nni_lmq_cap(&s->wmq);
 	nni_mtx_unlock(&s->mtx);
 
 	return (nni_copyout_int(val, buf, szp, t));
@@ -498,7 +497,7 @@ pair0_get_recv_buf_len(void *arg, void *buf, size_t *szp, nni_opt_type t)
 	int         val;
 
 	nni_mtx_lock(&s->mtx);
-	val = nni_lmq_cap(&s->rmq);
+	val = (int) nni_lmq_cap(&s->rmq);
 	nni_mtx_unlock(&s->mtx);
 
 	return (nni_copyout_int(val, buf, szp, t));
@@ -531,28 +530,28 @@ pair0_sock_get_send_fd(void *arg, void *buf, size_t *szp, nni_opt_type t)
 }
 
 static nni_option pair0_sock_options[] = {
-    {
-	.o_name = NNG_OPT_RECVFD,
-	.o_get  = pair0_sock_get_recv_fd,
-    },
-    {
-	.o_name = NNG_OPT_SENDFD,
-	.o_get  = pair0_sock_get_send_fd,
-    },
-    {
-	.o_name = NNG_OPT_SENDBUF,
-	.o_get  = pair0_get_send_buf_len,
-	.o_set  = pair0_set_send_buf_len,
-    },
-    {
-	.o_name = NNG_OPT_RECVBUF,
-	.o_get  = pair0_get_recv_buf_len,
-	.o_set  = pair0_set_recv_buf_len,
-    },
-    // terminate list
-    {
-	.o_name = NULL,
-    },
+	{
+	    .o_name = NNG_OPT_RECVFD,
+	    .o_get  = pair0_sock_get_recv_fd,
+	},
+	{
+	    .o_name = NNG_OPT_SENDFD,
+	    .o_get  = pair0_sock_get_send_fd,
+	},
+	{
+	    .o_name = NNG_OPT_SENDBUF,
+	    .o_get  = pair0_get_send_buf_len,
+	    .o_set  = pair0_set_send_buf_len,
+	},
+	{
+	    .o_name = NNG_OPT_RECVBUF,
+	    .o_get  = pair0_get_recv_buf_len,
+	    .o_set  = pair0_set_recv_buf_len,
+	},
+	// terminate list
+	{
+	    .o_name = NULL,
+	},
 };
 
 static nni_proto_pipe_ops pair0_pipe_ops = {
diff --git a/src/sp/protocol/pair0/pair0_test.c b/src/sp/protocol/pair0/pair0_test.c
index 20acc20..0bce1bb 100644
--- a/src/sp/protocol/pair0/pair0_test.c
+++ b/src/sp/protocol/pair0/pair0_test.c
@@ -81,10 +81,10 @@ test_faithful(void)
 	NUTS_PASS(nng_pair0_open(&s1));
 	NUTS_PASS(nng_pair0_open(&c1));
 	NUTS_PASS(nng_pair0_open(&c2));
-	NUTS_PASS(nng_setopt_ms(s1, NNG_OPT_RECVTIMEO, SECOND / 4));
-	NUTS_PASS(nng_setopt_ms(c1, NNG_OPT_SENDTIMEO, SECOND));
-	NUTS_PASS(nng_setopt_ms(c2, NNG_OPT_SENDTIMEO, SECOND));
-	NUTS_PASS(nng_setopt_int(c2, NNG_OPT_SENDBUF, 2));
+	NUTS_PASS(nng_socket_set_ms(s1, NNG_OPT_RECVTIMEO, SECOND / 4));
+	NUTS_PASS(nng_socket_set_ms(c1, NNG_OPT_SENDTIMEO, SECOND));
+	NUTS_PASS(nng_socket_set_ms(c2, NNG_OPT_SENDTIMEO, SECOND));
+	NUTS_PASS(nng_socket_set_int(c2, NNG_OPT_SENDBUF, 2));
 
 	NUTS_PASS(nng_listen(s1, addr, NULL, 0));
 	NUTS_MARRY(s1, c1);
@@ -121,10 +121,10 @@ test_back_pressure(void)
 
 	NUTS_PASS(nng_pair0_open(&s1));
 	NUTS_PASS(nng_pair0_open(&c1));
-	NUTS_PASS(nng_setopt_int(s1, NNG_OPT_RECVBUF, 1));
-	NUTS_PASS(nng_setopt_int(s1, NNG_OPT_SENDBUF, 1));
-	NUTS_PASS(nng_setopt_int(c1, NNG_OPT_RECVBUF, 1));
-	NUTS_PASS(nng_setopt_ms(s1, NNG_OPT_SENDTIMEO, to));
+	NUTS_PASS(nng_socket_set_int(s1, NNG_OPT_RECVBUF, 1));
+	NUTS_PASS(nng_socket_set_int(s1, NNG_OPT_SENDBUF, 1));
+	NUTS_PASS(nng_socket_set_int(c1, NNG_OPT_RECVBUF, 1));
+	NUTS_PASS(nng_socket_set_ms(s1, NNG_OPT_SENDTIMEO, to));
 
 	NUTS_MARRY(s1, c1);
 
@@ -151,7 +151,7 @@ test_send_no_peer(void)
 	nng_duration to = 100;
 
 	NUTS_PASS(nng_pair0_open(&s1));
-	NUTS_PASS(nng_setopt_ms(s1, NNG_OPT_SENDTIMEO, to));
+	NUTS_PASS(nng_socket_set_ms(s1, NNG_OPT_SENDTIMEO, to));
 
 	NUTS_PASS(nng_msg_alloc(&msg, 0));
 	NUTS_FAIL(nng_sendmsg(s1, msg, 0), NNG_ETIMEDOUT);
@@ -170,8 +170,8 @@ test_raw_exchange(void)
 	NUTS_PASS(nng_pair0_open_raw(&s1));
 	NUTS_PASS(nng_pair0_open_raw(&c1));
 
-	NUTS_PASS(nng_setopt_ms(s1, NNG_OPT_RECVTIMEO, SECOND));
-	NUTS_PASS(nng_setopt_ms(c1, NNG_OPT_RECVTIMEO, SECOND));
+	NUTS_PASS(nng_socket_set_ms(s1, NNG_OPT_RECVTIMEO, SECOND));
+	NUTS_PASS(nng_socket_set_ms(c1, NNG_OPT_RECVTIMEO, SECOND));
 	NUTS_MARRY(s1, c1);
 
 	nng_pipe p = NNG_PIPE_INITIALIZER;
@@ -226,15 +226,15 @@ test_pair0_raw(void)
 	bool       raw;
 
 	NUTS_PASS(nng_pair0_open(&s1));
-	NUTS_PASS(nng_getopt_bool(s1, NNG_OPT_RAW, &raw));
+	NUTS_PASS(nng_socket_get_bool(s1, NNG_OPT_RAW, &raw));
 	NUTS_TRUE(raw == false);
-	NUTS_FAIL(nng_setopt_bool(s1, NNG_OPT_RAW, true), NNG_EREADONLY);
+	NUTS_FAIL(nng_socket_set_bool(s1, NNG_OPT_RAW, true), NNG_EREADONLY);
 	NUTS_PASS(nng_close(s1));
 
 	NUTS_PASS(nng_pair0_open_raw(&s1));
-	NUTS_PASS(nng_getopt_bool(s1, NNG_OPT_RAW, &raw));
+	NUTS_PASS(nng_socket_get_bool(s1, NNG_OPT_RAW, &raw));
 	NUTS_TRUE(raw == true);
-	NUTS_FAIL(nng_setopt_bool(s1, NNG_OPT_RAW, false), NNG_EREADONLY);
+	NUTS_FAIL(nng_socket_set_bool(s1, NNG_OPT_RAW, false), NNG_EREADONLY);
 	NUTS_PASS(nng_close(s1));
 }
 
@@ -288,17 +288,17 @@ test_pair0_send_buffer(void)
 	size_t     sz;
 
 	NUTS_PASS(nng_pair0_open(&s));
-	NUTS_PASS(nng_getopt_int(s, NNG_OPT_SENDBUF, &v));
+	NUTS_PASS(nng_socket_get_int(s, NNG_OPT_SENDBUF, &v));
 	NUTS_TRUE(v == 0);
-	NUTS_FAIL(nng_getopt_bool(s, NNG_OPT_SENDBUF, &b), NNG_EBADTYPE);
+	NUTS_FAIL(nng_socket_get_bool(s, NNG_OPT_SENDBUF, &b), NNG_EBADTYPE);
 	sz = 1;
-	NUTS_FAIL(nng_getopt(s, NNG_OPT_SENDBUF, &b, &sz), NNG_EINVAL);
-	NUTS_FAIL(nng_setopt_int(s, NNG_OPT_SENDBUF, -1), NNG_EINVAL);
-	NUTS_FAIL(nng_setopt_int(s, NNG_OPT_SENDBUF, 100000), NNG_EINVAL);
-	NUTS_FAIL(nng_setopt_bool(s, NNG_OPT_SENDBUF, false), NNG_EBADTYPE);
-	NUTS_FAIL(nng_setopt(s, NNG_OPT_SENDBUF, &b, 1), NNG_EINVAL);
-	NUTS_PASS(nng_setopt_int(s, NNG_OPT_SENDBUF, 100));
-	NUTS_PASS(nng_getopt_int(s, NNG_OPT_SENDBUF, &v));
+	NUTS_FAIL(nng_socket_get(s, NNG_OPT_SENDBUF, &b, &sz), NNG_EINVAL);
+	NUTS_FAIL(nng_socket_set_int(s, NNG_OPT_SENDBUF, -1), NNG_EINVAL);
+	NUTS_FAIL(nng_socket_set_int(s, NNG_OPT_SENDBUF, 100000), NNG_EINVAL);
+	NUTS_FAIL(nng_socket_set_bool(s, NNG_OPT_SENDBUF, false), NNG_EBADTYPE);
+	NUTS_FAIL(nng_socket_set(s, NNG_OPT_SENDBUF, &b, 1), NNG_EINVAL);
+	NUTS_PASS(nng_socket_set_int(s, NNG_OPT_SENDBUF, 100));
+	NUTS_PASS(nng_socket_get_int(s, NNG_OPT_SENDBUF, &v));
 	NUTS_TRUE(v == 100);
 	NUTS_CLOSE(s);
 }
@@ -312,17 +312,17 @@ test_pair0_recv_buffer(void)
 	size_t     sz;
 
 	NUTS_PASS(nng_pair0_open(&s));
-	NUTS_PASS(nng_getopt_int(s, NNG_OPT_RECVBUF, &v));
+	NUTS_PASS(nng_socket_get_int(s, NNG_OPT_RECVBUF, &v));
 	NUTS_TRUE(v == 0);
-	NUTS_FAIL(nng_getopt_bool(s, NNG_OPT_RECVBUF, &b), NNG_EBADTYPE);
+	NUTS_FAIL(nng_socket_get_bool(s, NNG_OPT_RECVBUF, &b), NNG_EBADTYPE);
 	sz = 1;
-	NUTS_FAIL(nng_getopt(s, NNG_OPT_RECVBUF, &b, &sz), NNG_EINVAL);
-	NUTS_FAIL(nng_setopt_int(s, NNG_OPT_RECVBUF, -1), NNG_EINVAL);
-	NUTS_FAIL(nng_setopt_int(s, NNG_OPT_RECVBUF, 100000), NNG_EINVAL);
-	NUTS_FAIL(nng_setopt_bool(s, NNG_OPT_RECVBUF, false), NNG_EBADTYPE);
-	NUTS_FAIL(nng_setopt(s, NNG_OPT_RECVBUF, &b, 1), NNG_EINVAL);
-	NUTS_PASS(nng_setopt_int(s, NNG_OPT_RECVBUF, 100));
-	NUTS_PASS(nng_getopt_int(s, NNG_OPT_RECVBUF, &v));
+	NUTS_FAIL(nng_socket_get(s, NNG_OPT_RECVBUF, &b, &sz), NNG_EINVAL);
+	NUTS_FAIL(nng_socket_set_int(s, NNG_OPT_RECVBUF, -1), NNG_EINVAL);
+	NUTS_FAIL(nng_socket_set_int(s, NNG_OPT_RECVBUF, 100000), NNG_EINVAL);
+	NUTS_FAIL(nng_socket_set_bool(s, NNG_OPT_RECVBUF, false), NNG_EBADTYPE);
+	NUTS_FAIL(nng_socket_set(s, NNG_OPT_RECVBUF, &b, 1), NNG_EINVAL);
+	NUTS_PASS(nng_socket_set_int(s, NNG_OPT_RECVBUF, 100));
+	NUTS_PASS(nng_socket_get_int(s, NNG_OPT_RECVBUF, &v));
 	NUTS_TRUE(v == 100);
 	NUTS_CLOSE(s);
 }
diff --git a/src/sp/protocol/pair1/pair.c b/src/sp/protocol/pair1/pair.c
index 4a90988..e98e1ed 100644
--- a/src/sp/protocol/pair1/pair.c
+++ b/src/sp/protocol/pair1/pair.c
@@ -32,9 +32,9 @@ static void pair1_pipe_send(pair1_pipe *, nni_msg *);
 
 // pair1_sock is our per-socket protocol private structure.
 struct pair1_sock {
-	nni_sock *     sock;
+	nni_sock      *sock;
 	bool           raw;
-	pair1_pipe *   p;
+	pair1_pipe    *p;
 	nni_atomic_int ttl;
 	nni_mtx        mtx;
 	nni_lmq        wmq;
@@ -63,7 +63,7 @@ struct pair1_sock {
 
 // pair1_pipe is our per-pipe protocol private structure.
 struct pair1_pipe {
-	nni_pipe *  pipe;
+	nni_pipe   *pipe;
 	pair1_sock *pair;
 	nni_aio     aio_send;
 	nni_aio     aio_recv;
@@ -91,7 +91,7 @@ pair1_add_sock_stat(
 }
 #endif
 
-static int
+static void
 pair1_sock_init_impl(void *arg, nni_sock *sock, bool raw)
 {
 	pair1_sock *s = arg;
@@ -179,20 +179,18 @@ pair1_sock_init_impl(void *arg, nni_sock *sock, bool raw)
 	nni_stat_set_bool(&s->stat_raw, raw);
 	nni_stat_set_bool(&s->stat_poly, false);
 #endif
-
-	return (0);
 }
 
-static int
+static void
 pair1_sock_init(void *arg, nni_sock *sock)
 {
-	return (pair1_sock_init_impl(arg, sock, false));
+	pair1_sock_init_impl(arg, sock, false);
 }
 
-static int
+static void
 pair1_sock_init_raw(void *arg, nni_sock *sock)
 {
-	return (pair1_sock_init_impl(arg, sock, true));
+	pair1_sock_init_impl(arg, sock, true);
 }
 
 static void
@@ -302,11 +300,11 @@ pair1_pipe_recv_cb(void *arg)
 {
 	pair1_pipe *p = arg;
 	pair1_sock *s = p->pair;
-	nni_msg *   msg;
+	nni_msg    *msg;
 	uint32_t    hdr;
-	nni_pipe *  pipe = p->pipe;
+	nni_pipe   *pipe = p->pipe;
 	size_t      len;
-	nni_aio *   a;
+	nni_aio    *a;
 
 	if (nni_aio_result(&p->aio_recv) != 0) {
 		nni_pipe_close(p->pipe);
@@ -358,7 +356,7 @@ pair1_pipe_recv_cb(void *arg)
 
 	// maybe we have room in the rmq?
 	if (!nni_lmq_full(&s->rmq)) {
-		nni_lmq_putq(&s->rmq, msg);
+		nni_lmq_put(&s->rmq, msg);
 		nni_aio_set_msg(&p->aio_recv, NULL);
 		nni_pipe_recv(pipe, &p->aio_recv);
 	} else {
@@ -372,8 +370,8 @@ static void
 pair1_send_sched(pair1_sock *s)
 {
 	pair1_pipe *p;
-	nni_msg *   m;
-	nni_aio *   a = NULL;
+	nni_msg    *m;
+	nni_aio    *a = NULL;
 	size_t      l = 0;
 
 	nni_mtx_lock(&s->mtx);
@@ -386,14 +384,14 @@ pair1_send_sched(pair1_sock *s)
 	s->wr_ready = true;
 
 	// if message waiting in buffered queue, then we prefer that.
-	if (nni_lmq_getq(&s->wmq, &m) == 0) {
+	if (nni_lmq_get(&s->wmq, &m) == 0) {
 		pair1_pipe_send(p, m);
 
 		if ((a = nni_list_first(&s->waq)) != NULL) {
 			nni_aio_list_remove(a);
 			m = nni_aio_get_msg(a);
 			l = nni_msg_len(m);
-			nni_lmq_putq(&s->wmq, m);
+			nni_lmq_put(&s->wmq, m);
 		}
 
 	} else if ((a = nni_list_first(&s->waq)) != NULL) {
@@ -444,16 +442,16 @@ static void
 pair1_sock_close(void *arg)
 {
 	pair1_sock *s = arg;
-	nni_aio *   a;
-	nni_msg *   m;
+	nni_aio    *a;
+	nni_msg    *m;
 	nni_mtx_lock(&s->mtx);
 	while (((a = nni_list_first(&s->raq)) != NULL) ||
 	    ((a = nni_list_first(&s->waq)) != NULL)) {
 		nni_aio_list_remove(a);
 		nni_aio_finish_error(a, NNG_ECLOSED);
 	}
-	while ((nni_lmq_getq(&s->rmq, &m) == 0) ||
-	    (nni_lmq_getq(&s->wmq, &m) == 0)) {
+	while ((nni_lmq_get(&s->rmq, &m) == 0) ||
+	    (nni_lmq_get(&s->wmq, &m) == 0)) {
 		nni_msg_free(m);
 	}
 	nni_mtx_unlock(&s->mtx);
@@ -521,7 +519,7 @@ static void
 pair1_sock_send(void *arg, nni_aio *aio)
 {
 	pair1_sock *s = arg;
-	nni_msg *   m;
+	nni_msg    *m;
 	size_t      len;
 	int         rv;
 
@@ -540,7 +538,7 @@ pair1_sock_send(void *arg, nni_aio *aio)
 #endif
 
 	// Raw mode messages have the header already formed, with a hop count.
-	// Cooked mode messages have no header so we have to add one.
+	// Cooked mode messages have no header, so we have to add one.
 	if (s->raw) {
 		if ((nni_msg_header_len(m) != sizeof(uint32_t)) ||
 		    (nni_msg_header_peek_u32(m) >= 0xff)) {
@@ -551,7 +549,7 @@ pair1_sock_send(void *arg, nni_aio *aio)
 
 	} else {
 		// Strip off any previously existing header, such as when
-		// replying to messages.
+		// replying to a message.
 		nni_msg_header_clear(m);
 		nni_msg_header_append_u32(m, 0);
 	}
@@ -573,8 +571,8 @@ inject:
 		return;
 	}
 
-	// Can we maybe queue it.
-	if (nni_lmq_putq(&s->wmq, m) == 0) {
+	// Can we queue it?
+	if (nni_lmq_put(&s->wmq, m) == 0) {
 		// Yay, we can.  So we're done.
 		nni_aio_set_msg(aio, NULL);
 		nni_aio_finish(aio, 0, len);
@@ -599,7 +597,7 @@ pair1_sock_recv(void *arg, nni_aio *aio)
 {
 	pair1_sock *s = arg;
 	pair1_pipe *p;
-	nni_msg *   m;
+	nni_msg    *m;
 	int         rv;
 
 	if (nni_aio_begin(aio) != 0) {
@@ -611,14 +609,14 @@ pair1_sock_recv(void *arg, nni_aio *aio)
 
 	// Buffered read.  If there is a message waiting for us, pick
 	// it up.  We might need to post another read request as well.
-	if (nni_lmq_getq(&s->rmq, &m) == 0) {
+	if (nni_lmq_get(&s->rmq, &m) == 0) {
 		nni_aio_set_msg(aio, m);
 		nni_aio_finish(aio, 0, nni_msg_len(m));
 		if (s->rd_ready) {
 			s->rd_ready = false;
 			m           = nni_aio_get_msg(&p->aio_recv);
 			nni_aio_set_msg(&p->aio_recv, NULL);
-			nni_lmq_putq(&s->rmq, m);
+			nni_lmq_put(&s->rmq, m);
 			nni_pipe_recv(p->pipe, &p->aio_recv);
 		}
 		if (nni_lmq_empty(&s->rmq)) {
@@ -678,7 +676,7 @@ pair1_get_send_buf_len(void *arg, void *buf, size_t *szp, nni_opt_type t)
 	int         val;
 
 	nni_mtx_lock(&s->mtx);
-	val = nni_lmq_cap(&s->wmq);
+	val = (int) nni_lmq_cap(&s->wmq);
 	nni_mtx_unlock(&s->mtx);
 
 	return (nni_copyout_int(val, buf, szp, t));
@@ -713,7 +711,7 @@ pair1_get_recv_buf_len(void *arg, void *buf, size_t *szp, nni_opt_type t)
 	int         val;
 
 	nni_mtx_lock(&s->mtx);
-	val = nni_lmq_cap(&s->rmq);
+	val = (int) nni_lmq_cap(&s->rmq);
 	nni_mtx_unlock(&s->mtx);
 
 	return (nni_copyout_int(val, buf, szp, t));
diff --git a/src/sp/protocol/pair1/pair1_poly.c b/src/sp/protocol/pair1/pair1_poly.c
index 6c16745..06afc57 100644
--- a/src/sp/protocol/pair1/pair1_poly.c
+++ b/src/sp/protocol/pair1/pair1_poly.c
@@ -13,9 +13,9 @@
 #include "core/nng_impl.h"
 #include "nng/protocol/pair1/pair.h"
 
-// Pair1 polyamorous mode.  The PAIRv1 protocol is normally a simple 1:1
+// Pair1 poly-amorous mode.  The PAIRv1 protocol is normally a simple 1:1
 // messaging pattern, but this mode offers the ability to use a best-effort
-// multicast type of communication.  There are limitations however.
+// multicast type of communication.  There are limitations, however.
 // Most notably this does not interact well with nng_device type
 // proxies, and there is no support for raw mode.
 
@@ -90,7 +90,7 @@ pair1_add_sock_stat(
 }
 #endif
 
-static int
+static void
 pair1poly_sock_init(void *arg, nni_sock *sock)
 {
 	pair1poly_sock *s = arg;
@@ -173,8 +173,6 @@ pair1poly_sock_init(void *arg, nni_sock *sock)
 	s->urq = nni_sock_recvq(sock);
 	nni_atomic_init(&s->ttl);
 	nni_atomic_set(&s->ttl, 8);
-
-	return (0);
 }
 
 static void
@@ -250,7 +248,7 @@ pair1poly_pipe_start(void *arg)
 	s->started = true;
 	nni_mtx_unlock(&s->mtx);
 
-	// Schedule a get.  In polyamorous mode we get on the per pipe
+	// Schedule a get.  In poly-amorous mode we get on the per pipe
 	// send_queue, as the socket distributes to us. In monogamous mode
 	// we bypass and get from the upper write queue directly (saving a
 	// set of context switches).
@@ -398,12 +396,12 @@ pair1poly_pipe_get_cb(void *arg)
 	msg = nni_aio_get_msg(&p->aio_get);
 	nni_aio_set_msg(&p->aio_get, NULL);
 
-	// Cooked mode messages have no header so we have to add one.
+	// Cooked mode messages have no header, so we have to add one.
 	// Strip off any previously existing header, such as when
-	// replying to messages.
+	// replying to a message.
 	nni_msg_header_clear(msg);
 
-	// Insert the hops header.
+	// Insert the hop count header.
 	nni_msg_header_append_u32(msg, 1);
 
 	nni_aio_set_msg(&p->aio_send, msg);
diff --git a/src/sp/protocol/pair1/pair1_poly_test.c b/src/sp/protocol/pair1/pair1_poly_test.c
index dd59e29..3aabb24 100644
--- a/src/sp/protocol/pair1/pair1_poly_test.c
+++ b/src/sp/protocol/pair1/pair1_poly_test.c
@@ -48,10 +48,10 @@ test_poly_best_effort(void)
 	NUTS_PASS(nng_pair1_open_poly(&s1));
 	NUTS_PASS(nng_pair1_open(&c1));
 
-	NUTS_PASS(nng_setopt_int(s1, NNG_OPT_RECVBUF, 1));
-	NUTS_PASS(nng_setopt_int(s1, NNG_OPT_SENDBUF, 1));
-	NUTS_PASS(nng_setopt_int(c1, NNG_OPT_RECVBUF, 1));
-	NUTS_PASS(nng_setopt_ms(s1, NNG_OPT_SENDTIMEO, SECOND));
+	NUTS_PASS(nng_socket_set_int(s1, NNG_OPT_RECVBUF, 1));
+	NUTS_PASS(nng_socket_set_int(s1, NNG_OPT_SENDBUF, 1));
+	NUTS_PASS(nng_socket_set_int(c1, NNG_OPT_RECVBUF, 1));
+	NUTS_PASS(nng_socket_set_ms(s1, NNG_OPT_SENDTIMEO, SECOND));
 
 	NUTS_MARRY(s1, c1);
 
@@ -78,14 +78,14 @@ test_poly_cooked(void)
 	NUTS_PASS(nng_pair1_open_poly(&s1));
 	NUTS_PASS(nng_pair1_open(&c1));
 	NUTS_PASS(nng_pair1_open(&c2));
-	NUTS_PASS(nng_setopt_ms(s1, NNG_OPT_SENDTIMEO, SECOND));
-	NUTS_PASS(nng_setopt_ms(c1, NNG_OPT_SENDTIMEO, SECOND));
-	NUTS_PASS(nng_setopt_ms(c2, NNG_OPT_SENDTIMEO, SECOND));
-	NUTS_PASS(nng_setopt_ms(s1, NNG_OPT_RECVTIMEO, SECOND / 10));
-	NUTS_PASS(nng_setopt_ms(c1, NNG_OPT_RECVTIMEO, SECOND / 10));
-	NUTS_PASS(nng_setopt_ms(c2, NNG_OPT_RECVTIMEO, SECOND / 10));
-
-	NUTS_PASS(nng_getopt_bool(s1, NNG_OPT_PAIR1_POLY, &v));
+	NUTS_PASS(nng_socket_set_ms(s1, NNG_OPT_SENDTIMEO, SECOND));
+	NUTS_PASS(nng_socket_set_ms(c1, NNG_OPT_SENDTIMEO, SECOND));
+	NUTS_PASS(nng_socket_set_ms(c2, NNG_OPT_SENDTIMEO, SECOND));
+	NUTS_PASS(nng_socket_set_ms(s1, NNG_OPT_RECVTIMEO, SECOND / 10));
+	NUTS_PASS(nng_socket_set_ms(c1, NNG_OPT_RECVTIMEO, SECOND / 10));
+	NUTS_PASS(nng_socket_set_ms(c2, NNG_OPT_RECVTIMEO, SECOND / 10));
+
+	NUTS_PASS(nng_socket_get_bool(s1, NNG_OPT_PAIR1_POLY, &v));
 	NUTS_TRUE(v);
 
 	NUTS_MARRY(s1, c1);
@@ -151,9 +151,9 @@ test_poly_default(void)
 	NUTS_PASS(nng_pair1_open_poly(&s1));
 	NUTS_PASS(nng_pair1_open(&c1));
 	NUTS_PASS(nng_pair1_open(&c2));
-	NUTS_PASS(nng_setopt_ms(s1, NNG_OPT_SENDTIMEO, SECOND));
-	NUTS_PASS(nng_setopt_ms(c1, NNG_OPT_SENDTIMEO, SECOND));
-	NUTS_PASS(nng_setopt_ms(c2, NNG_OPT_SENDTIMEO, SECOND));
+	NUTS_PASS(nng_socket_set_ms(s1, NNG_OPT_SENDTIMEO, SECOND));
+	NUTS_PASS(nng_socket_set_ms(c1, NNG_OPT_SENDTIMEO, SECOND));
+	NUTS_PASS(nng_socket_set_ms(c2, NNG_OPT_SENDTIMEO, SECOND));
 
 	NUTS_MARRY(s1, c1);
 	NUTS_MARRY(s1, c2);
@@ -190,10 +190,10 @@ test_poly_close_abort(void)
 
 	NUTS_PASS(nng_pair1_open_poly(&s));
 	NUTS_PASS(nng_pair1_open(&c));
-	NUTS_PASS(nng_setopt_ms(s, NNG_OPT_RECVTIMEO, 100));
-	NUTS_PASS(nng_setopt_ms(s, NNG_OPT_SENDTIMEO, 200));
-	NUTS_PASS(nng_setopt_int(s, NNG_OPT_RECVBUF, 1));
-	NUTS_PASS(nng_setopt_int(c, NNG_OPT_SENDBUF, 20));
+	NUTS_PASS(nng_socket_set_ms(s, NNG_OPT_RECVTIMEO, 100));
+	NUTS_PASS(nng_socket_set_ms(s, NNG_OPT_SENDTIMEO, 200));
+	NUTS_PASS(nng_socket_set_int(s, NNG_OPT_RECVBUF, 1));
+	NUTS_PASS(nng_socket_set_int(c, NNG_OPT_SENDBUF, 20));
 
 	NUTS_MARRY(c, s);
 
@@ -215,9 +215,9 @@ test_poly_recv_no_header(void)
 
 	NUTS_PASS(nng_pair1_open_poly(&s));
 	NUTS_PASS(nng_pair1_open(&c));
-	NUTS_PASS(nng_setopt_bool(c, "pair1_test_inject_header", true));
-	NUTS_PASS(nng_setopt_ms(s, NNG_OPT_RECVTIMEO, 100));
-	NUTS_PASS(nng_setopt_ms(s, NNG_OPT_SENDTIMEO, 200));
+	NUTS_PASS(nng_socket_set_bool(c, "pair1_test_inject_header", true));
+	NUTS_PASS(nng_socket_set_ms(s, NNG_OPT_RECVTIMEO, 100));
+	NUTS_PASS(nng_socket_set_ms(s, NNG_OPT_SENDTIMEO, 200));
 
 	NUTS_MARRY(c, s);
 
@@ -238,9 +238,9 @@ test_poly_recv_garbage(void)
 
 	NUTS_PASS(nng_pair1_open_poly(&s));
 	NUTS_PASS(nng_pair1_open(&c));
-	NUTS_PASS(nng_setopt_bool(c, "pair1_test_inject_header", true));
-	NUTS_PASS(nng_setopt_ms(s, NNG_OPT_RECVTIMEO, 100));
-	NUTS_PASS(nng_setopt_ms(s, NNG_OPT_SENDTIMEO, 200));
+	NUTS_PASS(nng_socket_set_bool(c, "pair1_test_inject_header", true));
+	NUTS_PASS(nng_socket_set_ms(s, NNG_OPT_RECVTIMEO, 100));
+	NUTS_PASS(nng_socket_set_ms(s, NNG_OPT_SENDTIMEO, 200));
 
 	NUTS_MARRY(c, s);
 
@@ -265,21 +265,21 @@ test_poly_ttl(void)
 
 	NUTS_PASS(nng_pair1_open_poly(&s1));
 	NUTS_PASS(nng_pair1_open_raw(&c1));
-	NUTS_PASS(nng_setopt_ms(s1, NNG_OPT_RECVTIMEO, SECOND / 5));
-	NUTS_PASS(nng_setopt_ms(c1, NNG_OPT_RECVTIMEO, SECOND / 5));
+	NUTS_PASS(nng_socket_set_ms(s1, NNG_OPT_RECVTIMEO, SECOND / 5));
+	NUTS_PASS(nng_socket_set_ms(c1, NNG_OPT_RECVTIMEO, SECOND / 5));
 
 	// cannot set insane TTLs
-	NUTS_FAIL(nng_setopt_int(s1, NNG_OPT_MAXTTL, 0), NNG_EINVAL);
-	NUTS_FAIL(nng_setopt_int(s1, NNG_OPT_MAXTTL, 1000), NNG_EINVAL);
+	NUTS_FAIL(nng_socket_set_int(s1, NNG_OPT_MAXTTL, 0), NNG_EINVAL);
+	NUTS_FAIL(nng_socket_set_int(s1, NNG_OPT_MAXTTL, 1000), NNG_EINVAL);
 	ttl = 8;
-	NUTS_FAIL(nng_setopt(s1, NNG_OPT_MAXTTL, &ttl, 1), NNG_EINVAL);
-	NUTS_FAIL(nng_setopt_bool(s1, NNG_OPT_MAXTTL, true), NNG_EBADTYPE);
+	NUTS_FAIL(nng_socket_set(s1, NNG_OPT_MAXTTL, &ttl, 1), NNG_EINVAL);
+	NUTS_FAIL(nng_socket_set_bool(s1, NNG_OPT_MAXTTL, true), NNG_EBADTYPE);
 
 	NUTS_MARRY(s1, c1);
 
 	// Let's check enforcement of TTL
-	NUTS_PASS(nng_setopt_int(s1, NNG_OPT_MAXTTL, 4));
-	NUTS_PASS(nng_getopt_int(s1, NNG_OPT_MAXTTL, &ttl));
+	NUTS_PASS(nng_socket_set_int(s1, NNG_OPT_MAXTTL, 4));
+	NUTS_PASS(nng_socket_get_int(s1, NNG_OPT_MAXTTL, &ttl));
 	NUTS_TRUE(ttl == 4);
 
 	// Bad TTL bounces
@@ -301,7 +301,7 @@ test_poly_ttl(void)
 	nng_msg_free(msg);
 
 	// Large TTL passes
-	NUTS_PASS(nng_setopt_int(s1, NNG_OPT_MAXTTL, 15));
+	NUTS_PASS(nng_socket_set_int(s1, NNG_OPT_MAXTTL, 15));
 	NUTS_PASS(nng_msg_alloc(&msg, 0));
 	NUTS_PASS(nng_msg_append_u32(msg, 1234));
 	NUTS_PASS(nng_msg_header_append_u32(msg, 14));
@@ -314,7 +314,7 @@ test_poly_ttl(void)
 	nng_msg_free(msg);
 
 	// Max TTL fails
-	NUTS_PASS(nng_setopt_int(s1, NNG_OPT_MAXTTL, 15));
+	NUTS_PASS(nng_socket_set_int(s1, NNG_OPT_MAXTTL, 15));
 	NUTS_PASS(nng_msg_alloc(&msg, 0));
 	NUTS_PASS(nng_msg_header_append_u32(msg, 15));
 	NUTS_PASS(nng_sendmsg(c1, msg, 0));
diff --git a/src/sp/protocol/pair1/pair1_test.c b/src/sp/protocol/pair1/pair1_test.c
index 3185a3a..83c9647 100644
--- a/src/sp/protocol/pair1/pair1_test.c
+++ b/src/sp/protocol/pair1/pair1_test.c
@@ -81,10 +81,10 @@ test_mono_faithful(void)
 	NUTS_PASS(nng_pair1_open(&s1));
 	NUTS_PASS(nng_pair1_open(&c1));
 	NUTS_PASS(nng_pair1_open(&c2));
-	NUTS_PASS(nng_setopt_ms(s1, NNG_OPT_RECVTIMEO, SECOND / 4));
-	NUTS_PASS(nng_setopt_ms(c1, NNG_OPT_SENDTIMEO, SECOND));
-	NUTS_PASS(nng_setopt_ms(c2, NNG_OPT_SENDTIMEO, SECOND));
-	NUTS_PASS(nng_setopt_int(c2, NNG_OPT_SENDBUF, 2));
+	NUTS_PASS(nng_socket_set_ms(s1, NNG_OPT_RECVTIMEO, SECOND / 4));
+	NUTS_PASS(nng_socket_set_ms(c1, NNG_OPT_SENDTIMEO, SECOND));
+	NUTS_PASS(nng_socket_set_ms(c2, NNG_OPT_SENDTIMEO, SECOND));
+	NUTS_PASS(nng_socket_set_int(c2, NNG_OPT_SENDBUF, 2));
 
 	NUTS_PASS(nng_listen(s1, addr, NULL, 0));
 	NUTS_MARRY(s1, c1);
@@ -121,10 +121,10 @@ test_mono_back_pressure(void)
 
 	NUTS_PASS(nng_pair1_open(&s1));
 	NUTS_PASS(nng_pair1_open(&c1));
-	NUTS_PASS(nng_setopt_int(s1, NNG_OPT_RECVBUF, 1));
-	NUTS_PASS(nng_setopt_int(s1, NNG_OPT_SENDBUF, 1));
-	NUTS_PASS(nng_setopt_int(c1, NNG_OPT_RECVBUF, 1));
-	NUTS_PASS(nng_setopt_ms(s1, NNG_OPT_SENDTIMEO, to));
+	NUTS_PASS(nng_socket_set_int(s1, NNG_OPT_RECVBUF, 1));
+	NUTS_PASS(nng_socket_set_int(s1, NNG_OPT_SENDBUF, 1));
+	NUTS_PASS(nng_socket_set_int(c1, NNG_OPT_RECVBUF, 1));
+	NUTS_PASS(nng_socket_set_ms(s1, NNG_OPT_SENDTIMEO, to));
 
 	NUTS_MARRY(s1, c1);
 
@@ -151,7 +151,7 @@ test_send_no_peer(void)
 	nng_duration to = 100;
 
 	NUTS_PASS(nng_pair1_open(&s1));
-	NUTS_PASS(nng_setopt_ms(s1, NNG_OPT_SENDTIMEO, to));
+	NUTS_PASS(nng_socket_set_ms(s1, NNG_OPT_SENDTIMEO, to));
 
 	NUTS_PASS(nng_msg_alloc(&msg, 0));
 	NUTS_FAIL(nng_sendmsg(s1, msg, 0), NNG_ETIMEDOUT);
@@ -171,8 +171,8 @@ test_mono_raw_exchange(void)
 	NUTS_PASS(nng_pair1_open_raw(&s1));
 	NUTS_PASS(nng_pair1_open_raw(&c1));
 
-	NUTS_PASS(nng_setopt_ms(s1, NNG_OPT_RECVTIMEO, SECOND));
-	NUTS_PASS(nng_setopt_ms(c1, NNG_OPT_RECVTIMEO, SECOND));
+	NUTS_PASS(nng_socket_set_ms(s1, NNG_OPT_RECVTIMEO, SECOND));
+	NUTS_PASS(nng_socket_set_ms(c1, NNG_OPT_RECVTIMEO, SECOND));
 	NUTS_MARRY(s1, c1);
 
 	nng_pipe p = NNG_PIPE_INITIALIZER;
@@ -220,8 +220,8 @@ test_mono_raw_header(void)
 	NUTS_PASS(nng_pair1_open_raw(&s1));
 	NUTS_PASS(nng_pair1_open_raw(&c1));
 
-	NUTS_PASS(nng_setopt_ms(s1, NNG_OPT_RECVTIMEO, SECOND / 5));
-	NUTS_PASS(nng_setopt_ms(c1, NNG_OPT_RECVTIMEO, SECOND / 5));
+	NUTS_PASS(nng_socket_set_ms(s1, NNG_OPT_RECVTIMEO, SECOND / 5));
+	NUTS_PASS(nng_socket_set_ms(c1, NNG_OPT_RECVTIMEO, SECOND / 5));
 	NUTS_MARRY(s1, c1);
 
 	// Missing bits in the header
@@ -292,15 +292,15 @@ test_pair1_raw(void)
 	bool       raw;
 
 	NUTS_PASS(nng_pair1_open(&s1));
-	NUTS_PASS(nng_getopt_bool(s1, NNG_OPT_RAW, &raw));
+	NUTS_PASS(nng_socket_get_bool(s1, NNG_OPT_RAW, &raw));
 	NUTS_TRUE(raw == false);
-	NUTS_FAIL(nng_setopt_bool(s1, NNG_OPT_RAW, true), NNG_EREADONLY);
+	NUTS_FAIL(nng_socket_set_bool(s1, NNG_OPT_RAW, true), NNG_EREADONLY);
 	NUTS_PASS(nng_close(s1));
 
 	NUTS_PASS(nng_pair1_open_raw(&s1));
-	NUTS_PASS(nng_getopt_bool(s1, NNG_OPT_RAW, &raw));
+	NUTS_PASS(nng_socket_get_bool(s1, NNG_OPT_RAW, &raw));
 	NUTS_TRUE(raw == true);
-	NUTS_FAIL(nng_setopt_bool(s1, NNG_OPT_RAW, false), NNG_EREADONLY);
+	NUTS_FAIL(nng_socket_set_bool(s1, NNG_OPT_RAW, false), NNG_EREADONLY);
 	NUTS_PASS(nng_close(s1));
 }
 
@@ -315,21 +315,21 @@ test_pair1_ttl(void)
 
 	NUTS_PASS(nng_pair1_open_raw(&s1));
 	NUTS_PASS(nng_pair1_open_raw(&c1));
-	NUTS_PASS(nng_setopt_ms(s1, NNG_OPT_RECVTIMEO, SECOND / 5));
-	NUTS_PASS(nng_setopt_ms(c1, NNG_OPT_RECVTIMEO, SECOND / 5));
+	NUTS_PASS(nng_socket_set_ms(s1, NNG_OPT_RECVTIMEO, SECOND / 5));
+	NUTS_PASS(nng_socket_set_ms(c1, NNG_OPT_RECVTIMEO, SECOND / 5));
 
 	// cannot set insane TTLs
-	NUTS_FAIL(nng_setopt_int(s1, NNG_OPT_MAXTTL, 0), NNG_EINVAL);
-	NUTS_FAIL(nng_setopt_int(s1, NNG_OPT_MAXTTL, 1000), NNG_EINVAL);
+	NUTS_FAIL(nng_socket_set_int(s1, NNG_OPT_MAXTTL, 0), NNG_EINVAL);
+	NUTS_FAIL(nng_socket_set_int(s1, NNG_OPT_MAXTTL, 1000), NNG_EINVAL);
 	ttl = 8;
-	NUTS_FAIL(nng_setopt(s1, NNG_OPT_MAXTTL, &ttl, 1), NNG_EINVAL);
-	NUTS_FAIL(nng_setopt_bool(s1, NNG_OPT_MAXTTL, true), NNG_EBADTYPE);
+	NUTS_FAIL(nng_socket_set(s1, NNG_OPT_MAXTTL, &ttl, 1), NNG_EINVAL);
+	NUTS_FAIL(nng_socket_set_bool(s1, NNG_OPT_MAXTTL, true), NNG_EBADTYPE);
 
 	NUTS_MARRY(s1, c1);
 
 	// Let's check enforcement of TTL
-	NUTS_PASS(nng_setopt_int(s1, NNG_OPT_MAXTTL, 4));
-	NUTS_PASS(nng_getopt_int(s1, NNG_OPT_MAXTTL, &ttl));
+	NUTS_PASS(nng_socket_set_int(s1, NNG_OPT_MAXTTL, 4));
+	NUTS_PASS(nng_socket_get_int(s1, NNG_OPT_MAXTTL, &ttl));
 	NUTS_TRUE(ttl == 4);
 
 	// Bad TTL bounces
@@ -351,7 +351,7 @@ test_pair1_ttl(void)
 	nng_msg_free(msg);
 
 	// Large TTL passes
-	NUTS_PASS(nng_setopt_int(s1, NNG_OPT_MAXTTL, 15));
+	NUTS_PASS(nng_socket_set_int(s1, NNG_OPT_MAXTTL, 15));
 	NUTS_PASS(nng_msg_alloc(&msg, 0));
 	NUTS_PASS(nng_msg_append_u32(msg, 1234));
 	NUTS_PASS(nng_msg_header_append_u32(msg, 14));
@@ -364,7 +364,7 @@ test_pair1_ttl(void)
 	nng_msg_free(msg);
 
 	// Max TTL fails
-	NUTS_PASS(nng_setopt_int(s1, NNG_OPT_MAXTTL, 15));
+	NUTS_PASS(nng_socket_set_int(s1, NNG_OPT_MAXTTL, 15));
 	NUTS_PASS(nng_msg_alloc(&msg, 0));
 	NUTS_PASS(nng_msg_header_append_u32(msg, 15));
 	NUTS_PASS(nng_sendmsg(c1, msg, 0));
@@ -413,9 +413,9 @@ test_pair1_recv_no_header(void)
 
 	NUTS_PASS(nng_pair1_open(&s));
 	NUTS_PASS(nng_pair1_open(&c));
-	NUTS_PASS(nng_setopt_bool(c, "pair1_test_inject_header", true));
-	NUTS_PASS(nng_setopt_ms(s, NNG_OPT_RECVTIMEO, 100));
-	NUTS_PASS(nng_setopt_ms(s, NNG_OPT_SENDTIMEO, 200));
+	NUTS_PASS(nng_socket_set_bool(c, "pair1_test_inject_header", true));
+	NUTS_PASS(nng_socket_set_ms(s, NNG_OPT_RECVTIMEO, 100));
+	NUTS_PASS(nng_socket_set_ms(s, NNG_OPT_SENDTIMEO, 200));
 
 	NUTS_MARRY(c, s);
 
@@ -436,9 +436,9 @@ test_pair1_recv_garbage(void)
 
 	NUTS_PASS(nng_pair1_open(&s));
 	NUTS_PASS(nng_pair1_open(&c));
-	NUTS_PASS(nng_setopt_bool(c, "pair1_test_inject_header", true));
-	NUTS_PASS(nng_setopt_ms(s, NNG_OPT_RECVTIMEO, 100));
-	NUTS_PASS(nng_setopt_ms(s, NNG_OPT_SENDTIMEO, 200));
+	NUTS_PASS(nng_socket_set_bool(c, "pair1_test_inject_header", true));
+	NUTS_PASS(nng_socket_set_ms(s, NNG_OPT_RECVTIMEO, 100));
+	NUTS_PASS(nng_socket_set_ms(s, NNG_OPT_SENDTIMEO, 200));
 
 	NUTS_MARRY(c, s);
 
@@ -472,17 +472,17 @@ test_pair1_send_buffer(void)
 	size_t     sz;
 
 	NUTS_PASS(nng_pair1_open(&s));
-	NUTS_PASS(nng_getopt_int(s, NNG_OPT_SENDBUF, &v));
+	NUTS_PASS(nng_socket_get_int(s, NNG_OPT_SENDBUF, &v));
 	NUTS_TRUE(v == 0);
-	NUTS_FAIL(nng_getopt_bool(s, NNG_OPT_SENDBUF, &b), NNG_EBADTYPE);
+	NUTS_FAIL(nng_socket_get_bool(s, NNG_OPT_SENDBUF, &b), NNG_EBADTYPE);
 	sz = 1;
-	NUTS_FAIL(nng_getopt(s, NNG_OPT_SENDBUF, &b, &sz), NNG_EINVAL);
-	NUTS_FAIL(nng_setopt_int(s, NNG_OPT_SENDBUF, -1), NNG_EINVAL);
-	NUTS_FAIL(nng_setopt_int(s, NNG_OPT_SENDBUF, 100000), NNG_EINVAL);
-	NUTS_FAIL(nng_setopt_bool(s, NNG_OPT_SENDBUF, false), NNG_EBADTYPE);
-	NUTS_FAIL(nng_setopt(s, NNG_OPT_SENDBUF, &b, 1), NNG_EINVAL);
-	NUTS_PASS(nng_setopt_int(s, NNG_OPT_SENDBUF, 100));
-	NUTS_PASS(nng_getopt_int(s, NNG_OPT_SENDBUF, &v));
+	NUTS_FAIL(nng_socket_get(s, NNG_OPT_SENDBUF, &b, &sz), NNG_EINVAL);
+	NUTS_FAIL(nng_socket_set_int(s, NNG_OPT_SENDBUF, -1), NNG_EINVAL);
+	NUTS_FAIL(nng_socket_set_int(s, NNG_OPT_SENDBUF, 100000), NNG_EINVAL);
+	NUTS_FAIL(nng_socket_set_bool(s, NNG_OPT_SENDBUF, false), NNG_EBADTYPE);
+	NUTS_FAIL(nng_socket_set(s, NNG_OPT_SENDBUF, &b, 1), NNG_EINVAL);
+	NUTS_PASS(nng_socket_set_int(s, NNG_OPT_SENDBUF, 100));
+	NUTS_PASS(nng_socket_get_int(s, NNG_OPT_SENDBUF, &v));
 	NUTS_TRUE(v == 100);
 	NUTS_CLOSE(s);
 }
@@ -496,17 +496,17 @@ test_pair1_recv_buffer(void)
 	size_t     sz;
 
 	NUTS_PASS(nng_pair1_open(&s));
-	NUTS_PASS(nng_getopt_int(s, NNG_OPT_RECVBUF, &v));
+	NUTS_PASS(nng_socket_get_int(s, NNG_OPT_RECVBUF, &v));
 	NUTS_TRUE(v == 0);
-	NUTS_FAIL(nng_getopt_bool(s, NNG_OPT_RECVBUF, &b), NNG_EBADTYPE);
+	NUTS_FAIL(nng_socket_get_bool(s, NNG_OPT_RECVBUF, &b), NNG_EBADTYPE);
 	sz = 1;
-	NUTS_FAIL(nng_getopt(s, NNG_OPT_RECVBUF, &b, &sz), NNG_EINVAL);
-	NUTS_FAIL(nng_setopt_int(s, NNG_OPT_RECVBUF, -1), NNG_EINVAL);
-	NUTS_FAIL(nng_setopt_int(s, NNG_OPT_RECVBUF, 100000), NNG_EINVAL);
-	NUTS_FAIL(nng_setopt_bool(s, NNG_OPT_RECVBUF, false), NNG_EBADTYPE);
-	NUTS_FAIL(nng_setopt(s, NNG_OPT_RECVBUF, &b, 1), NNG_EINVAL);
-	NUTS_PASS(nng_setopt_int(s, NNG_OPT_RECVBUF, 100));
-	NUTS_PASS(nng_getopt_int(s, NNG_OPT_RECVBUF, &v));
+	NUTS_FAIL(nng_socket_get(s, NNG_OPT_RECVBUF, &b, &sz), NNG_EINVAL);
+	NUTS_FAIL(nng_socket_set_int(s, NNG_OPT_RECVBUF, -1), NNG_EINVAL);
+	NUTS_FAIL(nng_socket_set_int(s, NNG_OPT_RECVBUF, 100000), NNG_EINVAL);
+	NUTS_FAIL(nng_socket_set_bool(s, NNG_OPT_RECVBUF, false), NNG_EBADTYPE);
+	NUTS_FAIL(nng_socket_set(s, NNG_OPT_RECVBUF, &b, 1), NNG_EINVAL);
+	NUTS_PASS(nng_socket_set_int(s, NNG_OPT_RECVBUF, 100));
+	NUTS_PASS(nng_socket_get_int(s, NNG_OPT_RECVBUF, &v));
 	NUTS_TRUE(v == 100);
 	NUTS_CLOSE(s);
 }
diff --git a/src/sp/protocol/pipeline0/pull.c b/src/sp/protocol/pipeline0/pull.c
index 616b081..07d5540 100644
--- a/src/sp/protocol/pipeline0/pull.c
+++ b/src/sp/protocol/pipeline0/pull.c
@@ -1,5 +1,5 @@
 //
-// Copyright 2020 Staysail Systems, Inc. <info@staysail.tech>
+// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
 // Copyright 2018 Capitar IT Group BV <info@capitar.com>
 //
 // This software is supplied under the terms of the MIT License, a
@@ -47,7 +47,7 @@ struct pull0_pipe {
 	nni_list_node node;
 };
 
-static int
+static void
 pull0_sock_init(void *arg, nni_sock *sock)
 {
 	pull0_sock *s = arg;
@@ -57,7 +57,6 @@ pull0_sock_init(void *arg, nni_sock *sock)
 	NNI_LIST_INIT(&s->pl, pull0_pipe, node);
 	nni_mtx_init(&s->m);
 	nni_pollable_init(&s->readable);
-	return (0);
 }
 
 static void
diff --git a/src/sp/protocol/pipeline0/push.c b/src/sp/protocol/pipeline0/push.c
index ad43d96..09953cc 100644
--- a/src/sp/protocol/pipeline0/push.c
+++ b/src/sp/protocol/pipeline0/push.c
@@ -1,5 +1,5 @@
 //
-// Copyright 2020 Staysail Systems, Inc. <info@staysail.tech>
+// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
 // Copyright 2018 Capitar IT Group BV <info@capitar.com>
 //
 // This software is supplied under the terms of the MIT License, a
@@ -43,15 +43,15 @@ struct push0_sock {
 
 // push0_pipe is our per-pipe protocol private structure.
 struct push0_pipe {
-	nni_pipe *    pipe;
-	push0_sock *  push;
+	nni_pipe     *pipe;
+	push0_sock   *push;
 	nni_list_node node;
 
 	nni_aio aio_recv;
 	nni_aio aio_send;
 };
 
-static int
+static void
 push0_sock_init(void *arg, nni_sock *sock)
 {
 	push0_sock *s = arg;
@@ -62,8 +62,6 @@ push0_sock_init(void *arg, nni_sock *sock)
 	NNI_LIST_INIT(&s->pl, push0_pipe, node);
 	nni_lmq_init(&s->wq, 0); // initially we start unbuffered.
 	nni_pollable_init(&s->writable);
-
-	return (0);
 }
 
 static void
@@ -85,7 +83,7 @@ static void
 push0_sock_close(void *arg)
 {
 	push0_sock *s = arg;
-	nni_aio *   a;
+	nni_aio    *a;
 	nni_mtx_lock(&s->m);
 	while ((a = nni_list_first(&s->aq)) != NULL) {
 		nni_aio_list_remove(a);
@@ -182,8 +180,8 @@ static void
 push0_pipe_ready(push0_pipe *p)
 {
 	push0_sock *s = p->push;
-	nni_msg *   m;
-	nni_aio *   a = NULL;
+	nni_msg    *m;
+	nni_aio    *a = NULL;
 	size_t      l;
 	bool        blocked;
 
@@ -193,7 +191,7 @@ push0_pipe_ready(push0_pipe *p)
 
 	// if  message is waiting in the buffered queue
 	// then we prefer that.
-	if (nni_lmq_getq(&s->wq, &m) == 0) {
+	if (nni_lmq_get(&s->wq, &m) == 0) {
 		nni_aio_set_msg(&p->aio_send, m);
 		nni_pipe_send(p->pipe, &p->aio_send);
 
@@ -201,7 +199,7 @@ push0_pipe_ready(push0_pipe *p)
 			nni_aio_list_remove(a);
 			m = nni_aio_get_msg(a);
 			l = nni_msg_len(m);
-			nni_lmq_putq(&s->wq, m);
+			nni_lmq_put(&s->wq, m);
 		}
 
 	} else if ((a = nni_list_first(&s->aq)) != NULL) {
@@ -266,7 +264,7 @@ push0_sock_send(void *arg, nni_aio *aio)
 {
 	push0_sock *s = arg;
 	push0_pipe *p;
-	nni_msg *   m;
+	nni_msg    *m;
 	size_t      l;
 	int         rv;
 
@@ -299,8 +297,8 @@ push0_sock_send(void *arg, nni_aio *aio)
 		return;
 	}
 
-	// Can we maybe queue it.
-	if (nni_lmq_putq(&s->wq, m) == 0) {
+	// Can we queue it?
+	if (nni_lmq_put(&s->wq, m) == 0) {
 		// Yay, we can.  So we're done.
 		nni_aio_set_msg(aio, NULL);
 		nni_aio_finish(aio, 0, l);
@@ -356,7 +354,7 @@ push0_get_send_buf_len(void *arg, void *buf, size_t *szp, nni_opt_type t)
 	int         val;
 
 	nni_mtx_lock(&s->m);
-	val = nni_lmq_cap(&s->wq);
+	val = (int) nni_lmq_cap(&s->wq);
 	nni_mtx_unlock(&s->m);
 
 	return (nni_copyout_int(val, buf, szp, t));
diff --git a/src/sp/protocol/pipeline0/push_test.c b/src/sp/protocol/pipeline0/push_test.c
index d22ccaa..9bdd963 100644
--- a/src/sp/protocol/pipeline0/push_test.c
+++ b/src/sp/protocol/pipeline0/push_test.c
@@ -387,7 +387,7 @@ test_push_send_late_buffered(void)
 	NUTS_PASS(nng_push0_open(&s));
 	NUTS_PASS(nng_pull0_open(&pull));
 	NUTS_PASS(nng_aio_alloc(&aio, NULL, NULL));
-	NUTS_PASS(nng_setopt_int(s, NNG_OPT_SENDBUF, 2));
+	NUTS_PASS(nng_socket_set_int(s, NNG_OPT_SENDBUF, 2));
 	NUTS_PASS(nng_msg_alloc(&m, 0));
 	NUTS_PASS(nng_msg_append(m, "123\0", 4));
 
@@ -429,7 +429,7 @@ test_push_load_balance_buffered(void)
 	NUTS_PASS(nng_pull0_open(&pull1));
 	NUTS_PASS(nng_pull0_open(&pull2));
 	NUTS_PASS(nng_pull0_open(&pull3));
-	NUTS_PASS(nng_setopt_int(s, NNG_OPT_SENDBUF, 4));
+	NUTS_PASS(nng_socket_set_int(s, NNG_OPT_SENDBUF, 4));
 	NUTS_MARRY(s, pull1);
 	NUTS_MARRY(s, pull2);
 	NUTS_MARRY(s, pull3);
@@ -486,17 +486,17 @@ test_push_send_buffer(void)
 	size_t     sz;
 
 	NUTS_PASS(nng_push0_open(&s));
-	NUTS_PASS(nng_getopt_int(s, NNG_OPT_SENDBUF, &v));
+	NUTS_PASS(nng_socket_get_int(s, NNG_OPT_SENDBUF, &v));
 	NUTS_TRUE(v == 0);
-	NUTS_FAIL(nng_getopt_bool(s, NNG_OPT_SENDBUF, &b), NNG_EBADTYPE);
+	NUTS_FAIL(nng_socket_get_bool(s, NNG_OPT_SENDBUF, &b), NNG_EBADTYPE);
 	sz = 1;
-	NUTS_FAIL(nng_getopt(s, NNG_OPT_SENDBUF, &b, &sz), NNG_EINVAL);
-	NUTS_FAIL(nng_setopt_int(s, NNG_OPT_SENDBUF, -1), NNG_EINVAL);
-	NUTS_FAIL(nng_setopt_int(s, NNG_OPT_SENDBUF, 100000), NNG_EINVAL);
-	NUTS_FAIL(nng_setopt_bool(s, NNG_OPT_SENDBUF, false), NNG_EBADTYPE);
-	NUTS_FAIL(nng_setopt(s, NNG_OPT_SENDBUF, &b, 1), NNG_EINVAL);
-	NUTS_PASS(nng_setopt_int(s, NNG_OPT_SENDBUF, 100));
-	NUTS_PASS(nng_getopt_int(s, NNG_OPT_SENDBUF, &v));
+	NUTS_FAIL(nng_socket_get(s, NNG_OPT_SENDBUF, &b, &sz), NNG_EINVAL);
+	NUTS_FAIL(nng_socket_set_int(s, NNG_OPT_SENDBUF, -1), NNG_EINVAL);
+	NUTS_FAIL(nng_socket_set_int(s, NNG_OPT_SENDBUF, 100000), NNG_EINVAL);
+	NUTS_FAIL(nng_socket_set_bool(s, NNG_OPT_SENDBUF, false), NNG_EBADTYPE);
+	NUTS_FAIL(nng_socket_set(s, NNG_OPT_SENDBUF, &b, 1), NNG_EINVAL);
+	NUTS_PASS(nng_socket_set_int(s, NNG_OPT_SENDBUF, 100));
+	NUTS_PASS(nng_socket_get_int(s, NNG_OPT_SENDBUF, &v));
 	NUTS_TRUE(v == 100);
 	NUTS_CLOSE(s);
 }
diff --git a/src/sp/protocol/pubsub0/pub.c b/src/sp/protocol/pubsub0/pub.c
index e3d4f16..b0a9ef0 100644
--- a/src/sp/protocol/pubsub0/pub.c
+++ b/src/sp/protocol/pubsub0/pub.c
@@ -1,5 +1,5 @@
 //
-// Copyright 2020 Staysail Systems, Inc. <info@staysail.tech>
+// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
 // Copyright 2018 Capitar IT Group BV <info@capitar.com>
 //
 // This software is supplied under the terms of the MIT License, a
@@ -36,22 +36,22 @@ static void pub0_pipe_fini(void *);
 
 // pub0_sock is our per-socket protocol private structure.
 struct pub0_sock {
-	nni_list      pipes;
-	nni_mtx       mtx;
-	bool          closed;
-	size_t        sendbuf;
-	nni_pollable *sendable;
+	nni_list     pipes;
+	nni_mtx      mtx;
+	bool         closed;
+	size_t       sendbuf;
+	nni_pollable sendable;
 };
 
 // pub0_pipe is our per-pipe protocol private structure.
 struct pub0_pipe {
-	nni_pipe *    pipe;
-	pub0_sock *   pub;
+	nni_pipe     *pipe;
+	pub0_sock    *pub;
 	nni_lmq       sendq;
 	bool          closed;
 	bool          busy;
-	nni_aio *     aio_send;
-	nni_aio *     aio_recv;
+	nni_aio       aio_send;
+	nni_aio       aio_recv;
 	nni_list_node node;
 };
 
@@ -60,24 +60,20 @@ pub0_sock_fini(void *arg)
 {
 	pub0_sock *s = arg;
 
-	nni_pollable_free(s->sendable);
+	nni_pollable_fini(&s->sendable);
 	nni_mtx_fini(&s->mtx);
 }
 
-static int
-pub0_sock_init(void *arg, nni_sock *nsock)
+static void
+pub0_sock_init(void *arg, nni_sock *ns)
 {
 	pub0_sock *sock = arg;
-	int        rv;
-	NNI_ARG_UNUSED(nsock);
+	NNI_ARG_UNUSED(ns);
 
-	if ((rv = nni_pollable_alloc(&sock->sendable)) != 0) {
-		return (rv);
-	}
+	nni_pollable_init(&sock->sendable);
 	nni_mtx_init(&sock->mtx);
 	NNI_LIST_INIT(&sock->pipes, pub0_pipe, node);
 	sock->sendbuf = 16; // fairly arbitrary
-	return (0);
 }
 
 static void
@@ -97,8 +93,8 @@ pub0_pipe_stop(void *arg)
 {
 	pub0_pipe *p = arg;
 
-	nni_aio_stop(p->aio_send);
-	nni_aio_stop(p->aio_recv);
+	nni_aio_stop(&p->aio_send);
+	nni_aio_stop(&p->aio_recv);
 }
 
 static void
@@ -106,8 +102,8 @@ pub0_pipe_fini(void *arg)
 {
 	pub0_pipe *p = arg;
 
-	nni_aio_free(p->aio_send);
-	nni_aio_free(p->aio_recv);
+	nni_aio_fini(&p->aio_send);
+	nni_aio_fini(&p->aio_recv);
 	nni_lmq_fini(&p->sendq);
 }
 
@@ -116,21 +112,15 @@ pub0_pipe_init(void *arg, nni_pipe *pipe, void *s)
 {
 	pub0_pipe *p    = arg;
 	pub0_sock *sock = s;
-	int        rv;
 	size_t     len;
 
 	nni_mtx_lock(&sock->mtx);
 	len = sock->sendbuf;
 	nni_mtx_unlock(&sock->mtx);
 
-	// XXX: consider making this depth tunable
-	if (((rv = nni_lmq_init(&p->sendq, len)) != 0) ||
-	    ((rv = nni_aio_alloc(&p->aio_send, pub0_pipe_send_cb, p)) != 0) ||
-	    ((rv = nni_aio_alloc(&p->aio_recv, pub0_pipe_recv_cb, p)) != 0)) {
-
-		pub0_pipe_fini(p);
-		return (rv);
-	}
+	nni_lmq_init(&p->sendq, len);
+	nni_aio_init(&p->aio_send, pub0_pipe_send_cb, p);
+	nni_aio_init(&p->aio_recv, pub0_pipe_recv_cb, p);
 
 	p->busy = false;
 	p->pipe = pipe;
@@ -152,7 +142,7 @@ pub0_pipe_start(void *arg)
 	nni_mtx_unlock(&sock->mtx);
 
 	// Start the receiver.
-	nni_pipe_recv(p->pipe, p->aio_recv);
+	nni_pipe_recv(p->pipe, &p->aio_recv);
 
 	return (0);
 }
@@ -163,8 +153,8 @@ pub0_pipe_close(void *arg)
 	pub0_pipe *p    = arg;
 	pub0_sock *sock = p->pub;
 
-	nni_aio_close(p->aio_send);
-	nni_aio_close(p->aio_recv);
+	nni_aio_close(&p->aio_send);
+	nni_aio_close(&p->aio_recv);
 
 	nni_mtx_lock(&sock->mtx);
 	p->closed = true;
@@ -183,8 +173,8 @@ pub0_pipe_recv_cb(void *arg)
 
 	// We should never receive a message -- the only valid reason for us to
 	// be here is on pipe close.
-	if (nni_aio_result(p->aio_recv) == 0) {
-		nni_msg_free(nni_aio_get_msg(p->aio_recv));
+	if (nni_aio_result(&p->aio_recv) == 0) {
+		nni_msg_free(nni_aio_get_msg(&p->aio_recv));
 	}
 	nni_pipe_close(p->pipe);
 }
@@ -194,11 +184,11 @@ pub0_pipe_send_cb(void *arg)
 {
 	pub0_pipe *p    = arg;
 	pub0_sock *sock = p->pub;
-	nni_msg *  msg;
+	nni_msg   *msg;
 
-	if (nni_aio_result(p->aio_send) != 0) {
-		nni_msg_free(nni_aio_get_msg(p->aio_send));
-		nni_aio_set_msg(p->aio_send, NULL);
+	if (nni_aio_result(&p->aio_send) != 0) {
+		nni_msg_free(nni_aio_get_msg(&p->aio_send));
+		nni_aio_set_msg(&p->aio_send, NULL);
 		nni_pipe_close(p->pipe);
 		return;
 	}
@@ -208,9 +198,9 @@ pub0_pipe_send_cb(void *arg)
 		nni_mtx_unlock(&sock->mtx);
 		return;
 	}
-	if (nni_lmq_getq(&p->sendq, &msg) == 0) {
-		nni_aio_set_msg(p->aio_send, msg);
-		nni_pipe_send(p->pipe, p->aio_send);
+	if (nni_lmq_get(&p->sendq, &msg) == 0) {
+		nni_aio_set_msg(&p->aio_send, msg);
+		nni_pipe_send(p->pipe, &p->aio_send);
 	} else {
 		p->busy = false;
 	}
@@ -231,7 +221,7 @@ pub0_sock_send(void *arg, nni_aio *aio)
 {
 	pub0_sock *sock = arg;
 	pub0_pipe *p;
-	nng_msg *  msg;
+	nng_msg   *msg;
 	size_t     len;
 
 	msg = nni_aio_get_msg(aio);
@@ -244,14 +234,14 @@ pub0_sock_send(void *arg, nni_aio *aio)
 			if (nni_lmq_full(&p->sendq)) {
 				// Make space for the new message.
 				nni_msg *old;
-				(void) nni_lmq_getq(&p->sendq, &old);
+				(void) nni_lmq_get(&p->sendq, &old);
 				nni_msg_free(old);
 			}
-			nni_lmq_putq(&p->sendq, msg);
+			nni_lmq_put(&p->sendq, msg);
 		} else {
 			p->busy = true;
-			nni_aio_set_msg(p->aio_send, msg);
-			nni_pipe_send(p->pipe, p->aio_send);
+			nni_aio_set_msg(&p->aio_send, msg);
+			nni_pipe_send(p->pipe, &p->aio_send);
 		}
 	}
 	nni_mtx_unlock(&sock->mtx);
@@ -267,8 +257,8 @@ pub0_sock_get_sendfd(void *arg, void *buf, size_t *szp, nni_type t)
 	int        rv;
 	nni_mtx_lock(&sock->mtx);
 	// PUB sockets are *always* writable.
-	nni_pollable_raise(sock->sendable);
-	rv = nni_pollable_getfd(sock->sendable, &fd);
+	nni_pollable_raise(&sock->sendable);
+	rv = nni_pollable_getfd(&sock->sendable, &fd);
 	nni_mtx_unlock(&sock->mtx);
 
 	if (rv == 0) {
@@ -292,7 +282,7 @@ pub0_sock_set_sendbuf(void *arg, const void *buf, size_t sz, nni_type t)
 	nni_mtx_lock(&sock->mtx);
 	sock->sendbuf = (size_t) val;
 	NNI_LIST_FOREACH (&sock->pipes, p) {
-		// If we fail part way thru (should only be ENOMEM), we
+		// If we fail part way through (should only be ENOMEM), we
 		// stop short.  The others would likely fail for ENOMEM as
 		// well anyway.  There is a weird effect here where the
 		// buffers may have been set for *some* of the pipes, but
@@ -371,13 +361,13 @@ static nni_proto pub0_proto_raw = {
 };
 
 int
-nng_pub0_open(nng_socket *sidp)
+nng_pub0_open(nng_socket *id)
 {
-	return (nni_proto_open(sidp, &pub0_proto));
+	return (nni_proto_open(id, &pub0_proto));
 }
 
 int
-nng_pub0_open_raw(nng_socket *sidp)
+nng_pub0_open_raw(nng_socket *id)
 {
-	return (nni_proto_open(sidp, &pub0_proto_raw));
+	return (nni_proto_open(id, &pub0_proto_raw));
 }
diff --git a/src/sp/protocol/pubsub0/sub.c b/src/sp/protocol/pubsub0/sub.c
index a40ee07..10f4272 100644
--- a/src/sp/protocol/pubsub0/sub.c
+++ b/src/sp/protocol/pubsub0/sub.c
@@ -1,5 +1,5 @@
 //
-// Copyright 2020 Staysail Systems, Inc. <info@staysail.tech>
+// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
 // Copyright 2018 Capitar IT Group BV <info@capitar.com>
 // Copyright 2019 Nathan Kent <nate@nkent.net>
 //
@@ -27,7 +27,7 @@
 #define NNI_PROTO_PUB_V0 NNI_PROTO(2, 0)
 #endif
 
-// By default we accept 128 messages.
+// By default, we accept 128 messages.
 #define SUB0_DEFAULT_RECV_BUF_LEN 128
 
 // By default, prefer new messages when the queue is full.
@@ -115,7 +115,7 @@ again:
 		return;
 	}
 
-	(void) nni_lmq_getq(&ctx->lmq, &msg);
+	(void) nni_lmq_get(&ctx->lmq, &msg);
 
 	if (nni_lmq_empty(&ctx->lmq) && (ctx == &sock->master)) {
 		nni_pollable_clear(&sock->readable);
@@ -175,22 +175,19 @@ sub0_ctx_fini(void *arg)
 	nni_lmq_fini(&ctx->lmq);
 }
 
-static int
+static void
 sub0_ctx_init(void *ctx_arg, void *sock_arg)
 {
 	sub0_sock *sock = sock_arg;
 	sub0_ctx * ctx  = ctx_arg;
 	size_t     len;
 	bool       prefer_new;
-	int        rv;
 
 	nni_mtx_lock(&sock->lk);
 	len        = sock->recv_buf_len;
 	prefer_new = sock->prefer_new;
 
-	if ((rv = nni_lmq_init(&ctx->lmq, len)) != 0) {
-		return (rv);
-	}
+	nni_lmq_init(&ctx->lmq, len);
 	ctx->prefer_new = prefer_new;
 
 	nni_aio_list_init(&ctx->recv_queue);
@@ -201,8 +198,6 @@ sub0_ctx_init(void *ctx_arg, void *sock_arg)
 	nni_list_append(&sock->contexts, ctx);
 	sock->num_contexts++;
 	nni_mtx_unlock(&sock->lk);
-
-	return (0);
 }
 
 static void
@@ -215,11 +210,10 @@ sub0_sock_fini(void *arg)
 	nni_mtx_fini(&sock->lk);
 }
 
-static int
+static void
 sub0_sock_init(void *arg, nni_sock *unused)
 {
 	sub0_sock *sock = arg;
-	int        rv;
 
 	NNI_ARG_UNUSED(unused);
 
@@ -229,12 +223,7 @@ sub0_sock_init(void *arg, nni_sock *unused)
 	sock->prefer_new   = SUB0_DEFAULT_PREFER_NEW;
 	nni_pollable_init(&sock->readable);
 
-	if ((rv = sub0_ctx_init(&sock->master, sock)) != 0) {
-		sub0_sock_fini(sock);
-		return (rv);
-	}
-
-	return (0);
+	sub0_ctx_init(&sock->master, sock);
 }
 
 static void
@@ -385,14 +374,14 @@ sub0_recv_cb(void *arg)
 		} else if (nni_lmq_full(&ctx->lmq)) {
 			// Make space for the new message.
 			nni_msg *old;
-			(void) nni_lmq_getq(&ctx->lmq, &old);
+			(void) nni_lmq_get(&ctx->lmq, &old);
 			nni_msg_free(old);
 
-			(void) nni_lmq_putq(&ctx->lmq, dup_msg);
+			(void) nni_lmq_put(&ctx->lmq, dup_msg);
 			queued = true;
 
 		} else {
-			(void) nni_lmq_putq(&ctx->lmq, dup_msg);
+			(void) nni_lmq_put(&ctx->lmq, dup_msg);
 			queued = true;
 		}
 		if (queued && ctx == &sock->master) {
@@ -459,7 +448,7 @@ sub0_ctx_set_recv_buf_len(void *arg, const void *buf, size_t sz, nni_type t)
 	return (0);
 }
 
-// For now we maintain subscriptions on a sorted linked list.  As we do not
+// For now, we maintain subscriptions on a sorted linked list.  As we do not
 // expect to have huge numbers of subscriptions, and as the operation is
 // really O(n), we think this is acceptable.  In the future we might decide
 // to replace this with a patricia trie, like old nanomsg had.
@@ -534,9 +523,9 @@ sub0_ctx_unsubscribe(void *arg, const void *buf, size_t sz, nni_type t)
 	for (size_t i = 0; i < len; i++) {
 		nni_msg *msg;
 
-		(void) nni_lmq_getq(&ctx->lmq, &msg);
+		(void) nni_lmq_get(&ctx->lmq, &msg);
 		if (sub0_matches(ctx, nni_msg_body(msg), nni_msg_len(msg))) {
-			(void) nni_lmq_putq(&ctx->lmq, msg);
+			(void) nni_lmq_put(&ctx->lmq, msg);
 		} else {
 			nni_msg_free(msg);
 		}
diff --git a/src/sp/protocol/pubsub0/xsub.c b/src/sp/protocol/pubsub0/xsub.c
index 0013b8b..ad06008 100644
--- a/src/sp/protocol/pubsub0/xsub.c
+++ b/src/sp/protocol/pubsub0/xsub.c
@@ -1,5 +1,5 @@
 //
-// Copyright 2020 Staysail Systems, Inc. <info@staysail.tech>
+// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
 // Copyright 2018 Capitar IT Group BV <info@capitar.com>
 //
 // This software is supplied under the terms of the MIT License, a
@@ -44,13 +44,12 @@ struct xsub0_pipe {
 	nni_aio    aio_recv;
 };
 
-static int
+static void
 xsub0_sock_init(void *arg, nni_sock *sock)
 {
 	xsub0_sock *s = arg;
 
 	s->urq = nni_sock_recvq(sock);
-	return (0);
 }
 
 static void
diff --git a/src/sp/protocol/reqrep0/rep.c b/src/sp/protocol/reqrep0/rep.c
index aa32d24..a15488c 100644
--- a/src/sp/protocol/reqrep0/rep.c
+++ b/src/sp/protocol/reqrep0/rep.c
@@ -1,5 +1,5 @@
 //
-// Copyright 2020 Staysail Systems, Inc. <info@staysail.tech>
+// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
 // Copyright 2018 Capitar IT Group BV <info@capitar.com>
 //
 // This software is supplied under the terms of the MIT License, a
@@ -93,7 +93,7 @@ rep0_ctx_fini(void *arg)
 	rep0_ctx_close(ctx);
 }
 
-static int
+static void
 rep0_ctx_init(void *carg, void *sarg)
 {
 	rep0_sock *s   = sarg;
@@ -104,8 +104,6 @@ rep0_ctx_init(void *carg, void *sarg)
 	ctx->btrace_len = 0;
 	ctx->sock       = s;
 	ctx->pipe_id    = 0;
-
-	return (0);
 }
 
 static void
@@ -217,7 +215,7 @@ rep0_sock_fini(void *arg)
 	nni_mtx_fini(&s->lk);
 }
 
-static int
+static void
 rep0_sock_init(void *arg, nni_sock *sock)
 {
 	rep0_sock *s = arg;
@@ -231,14 +229,12 @@ rep0_sock_init(void *arg, nni_sock *sock)
 	nni_atomic_init(&s->ttl);
 	nni_atomic_set(&s->ttl, 8);
 
-	(void) rep0_ctx_init(&s->ctx, s);
+	rep0_ctx_init(&s->ctx, s);
 
 	// We start off without being either readable or writable.
 	// Readability comes when there is something on the socket.
 	nni_pollable_init(&s->writable);
 	nni_pollable_init(&s->readable);
-
-	return (0);
 }
 
 static void
diff --git a/src/sp/protocol/reqrep0/req.c b/src/sp/protocol/reqrep0/req.c
index cb3c939..ecea9fb 100644
--- a/src/sp/protocol/reqrep0/req.c
+++ b/src/sp/protocol/reqrep0/req.c
@@ -1,5 +1,5 @@
 //
-// Copyright 2020 Staysail Systems, Inc. <info@staysail.tech>
+// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
 // Copyright 2018 Capitar IT Group BV <info@capitar.com>
 //
 // This software is supplied under the terms of the MIT License, a
@@ -24,22 +24,22 @@ static void req0_ctx_reset(req0_ctx *);
 static void req0_ctx_timeout(void *);
 static void req0_pipe_fini(void *);
 static void req0_ctx_fini(void *);
-static int  req0_ctx_init(void *, void *);
+static void req0_ctx_init(void *, void *);
 
 // A req0_ctx is a "context" for the request.  It uses most of the
 // socket, but keeps track of its own outstanding replays, the request ID,
 // and so forth.
 struct req0_ctx {
-	req0_sock *    sock;
+	req0_sock     *sock;
 	nni_list_node  sock_node;  // node on the socket context list
 	nni_list_node  send_node;  // node on the send_queue
 	nni_list_node  pipe_node;  // node on the pipe list
 	uint32_t       request_id; // request ID, without high bit set
-	nni_aio *      recv_aio;   // user aio waiting to recv - only one!
-	nni_aio *      send_aio;   // user aio waiting to send
-	nng_msg *      req_msg;    // request message (owned by protocol)
+	nni_aio       *recv_aio;   // user aio waiting to recv - only one!
+	nni_aio       *send_aio;   // user aio waiting to send
+	nng_msg       *req_msg;    // request message (owned by protocol)
 	size_t         req_len;    // length of request message (for stats)
-	nng_msg *      rep_msg;    // reply message
+	nng_msg       *rep_msg;    // reply message
 	nni_timer_node timer;
 	nni_duration   retry;
 	bool           conn_reset; // sent message w/o retry, peer disconnect
@@ -64,8 +64,8 @@ struct req0_sock {
 
 // A req0_pipe is our per-pipe protocol private structure.
 struct req0_pipe {
-	nni_pipe *    pipe;
-	req0_sock *   req;
+	nni_pipe     *pipe;
+	req0_sock    *req;
 	nni_list_node node;
 	nni_list      contexts; // contexts with pending traffic
 	bool          closed;
@@ -77,7 +77,7 @@ static void req0_sock_fini(void *);
 static void req0_send_cb(void *);
 static void req0_recv_cb(void *);
 
-static int
+static void
 req0_sock_init(void *arg, nni_sock *sock)
 {
 	req0_sock *s = arg;
@@ -100,14 +100,13 @@ req0_sock_init(void *arg, nni_sock *sock)
 	// this is "semi random" start for request IDs.
 	s->retry = NNI_SECOND * 60;
 
-	(void) req0_ctx_init(&s->master, s);
+	req0_ctx_init(&s->master, s);
 
 	nni_pollable_init(&s->writable);
 	nni_pollable_init(&s->readable);
 
 	nni_atomic_init(&s->ttl);
 	nni_atomic_set(&s->ttl, 8);
-	return (0);
 }
 
 static void
@@ -205,7 +204,7 @@ req0_pipe_close(void *arg)
 {
 	req0_pipe *p = arg;
 	req0_sock *s = p->req;
-	req0_ctx * ctx;
+	req0_ctx  *ctx;
 
 	nni_aio_close(&p->aio_recv);
 	nni_aio_close(&p->aio_send);
@@ -231,7 +230,7 @@ req0_pipe_close(void *arg)
 			if ((aio = ctx->recv_aio) != NULL) {
 				ctx->recv_aio = NULL;
 				nni_aio_finish_error(aio, NNG_ECONNRESET);
-                                req0_ctx_reset(ctx);
+				req0_ctx_reset(ctx);
 			} else {
 				req0_ctx_reset(ctx);
 				ctx->conn_reset = true;
@@ -258,7 +257,7 @@ req0_send_cb(void *arg)
 {
 	req0_pipe *p = arg;
 	req0_sock *s = p->req;
-	nni_aio *  aio;
+	nni_aio   *aio;
 	nni_list   sent_list;
 
 	nni_aio_list_init(&sent_list);
@@ -299,9 +298,9 @@ req0_recv_cb(void *arg)
 {
 	req0_pipe *p = arg;
 	req0_sock *s = p->req;
-	req0_ctx * ctx;
-	nni_msg *  msg;
-	nni_aio *  aio;
+	req0_ctx  *ctx;
+	nni_msg   *msg;
+	nni_aio   *aio;
 	uint32_t   id;
 
 	if (nni_aio_result(&p->aio_recv) != 0) {
@@ -370,7 +369,7 @@ malformed:
 static void
 req0_ctx_timeout(void *arg)
 {
-	req0_ctx * ctx = arg;
+	req0_ctx  *ctx = arg;
 	req0_sock *s   = ctx->sock;
 
 	nni_mtx_lock(&s->mtx);
@@ -383,11 +382,11 @@ req0_ctx_timeout(void *arg)
 	nni_mtx_unlock(&s->mtx);
 }
 
-static int
+static void
 req0_ctx_init(void *arg, void *sock)
 {
 	req0_sock *s   = sock;
-	req0_ctx * ctx = arg;
+	req0_ctx  *ctx = arg;
 
 	nni_timer_init(&ctx->timer, req0_ctx_timeout, ctx);
 
@@ -397,16 +396,14 @@ req0_ctx_init(void *arg, void *sock)
 	ctx->retry    = s->retry;
 	nni_list_append(&s->contexts, ctx);
 	nni_mtx_unlock(&s->mtx);
-
-	return (0);
 }
 
 static void
 req0_ctx_fini(void *arg)
 {
-	req0_ctx * ctx = arg;
+	req0_ctx  *ctx = arg;
 	req0_sock *s   = ctx->sock;
-	nni_aio *  aio;
+	nni_aio   *aio;
 
 	nni_mtx_lock(&s->mtx);
 	if ((aio = ctx->recv_aio) != NULL) {
@@ -445,7 +442,7 @@ static void
 req0_run_send_queue(req0_sock *s, nni_list *sent_list)
 {
 	req0_ctx *ctx;
-	nni_aio * aio;
+	nni_aio  *aio;
 
 	// Note: This routine should be called with the socket lock held.
 	while ((ctx = nni_list_first(&s->send_queue)) != NULL) {
@@ -540,7 +537,7 @@ req0_ctx_reset(req0_ctx *ctx)
 static void
 req0_ctx_cancel_recv(nni_aio *aio, void *arg, int rv)
 {
-	req0_ctx * ctx = arg;
+	req0_ctx  *ctx = arg;
 	req0_sock *s   = ctx->sock;
 
 	nni_mtx_lock(&s->mtx);
@@ -564,9 +561,9 @@ req0_ctx_cancel_recv(nni_aio *aio, void *arg, int rv)
 static void
 req0_ctx_recv(void *arg, nni_aio *aio)
 {
-	req0_ctx * ctx = arg;
+	req0_ctx  *ctx = arg;
 	req0_sock *s   = ctx->sock;
-	nni_msg *  msg;
+	nni_msg   *msg;
 
 	if (nni_aio_begin(aio) != 0) {
 		return;
@@ -616,7 +613,7 @@ req0_ctx_recv(void *arg, nni_aio *aio)
 static void
 req0_ctx_cancel_send(nni_aio *aio, void *arg, int rv)
 {
-	req0_ctx * ctx = arg;
+	req0_ctx  *ctx = arg;
 	req0_sock *s   = ctx->sock;
 
 	nni_mtx_lock(&s->mtx);
@@ -647,9 +644,9 @@ req0_ctx_cancel_send(nni_aio *aio, void *arg, int rv)
 static void
 req0_ctx_send(void *arg, nni_aio *aio)
 {
-	req0_ctx * ctx = arg;
+	req0_ctx  *ctx = arg;
 	req0_sock *s   = ctx->sock;
-	nng_msg *  msg = nni_aio_get_msg(aio);
+	nng_msg   *msg = nni_aio_get_msg(aio);
 	int        rv;
 
 	if (nni_aio_begin(aio) != 0) {
diff --git a/src/sp/protocol/reqrep0/req_test.c b/src/sp/protocol/reqrep0/req_test.c
index fb78efa..347ba61 100644
--- a/src/sp/protocol/reqrep0/req_test.c
+++ b/src/sp/protocol/reqrep0/req_test.c
@@ -669,8 +669,8 @@ test_req_ctx_no_poll(void)
 
 	NUTS_PASS(nng_req0_open(&req));
 	NUTS_PASS(nng_ctx_open(&ctx, req));
-	NUTS_FAIL(nng_ctx_getopt_int(ctx, NNG_OPT_SENDFD, &fd), NNG_ENOTSUP);
-	NUTS_FAIL(nng_ctx_getopt_int(ctx, NNG_OPT_RECVFD, &fd), NNG_ENOTSUP);
+	NUTS_FAIL(nng_ctx_get_int(ctx, NNG_OPT_SENDFD, &fd), NNG_ENOTSUP);
+	NUTS_FAIL(nng_ctx_get_int(ctx, NNG_OPT_RECVFD, &fd), NNG_ENOTSUP);
 	NUTS_PASS(nng_ctx_close(ctx));
 	NUTS_CLOSE(req);
 }
diff --git a/src/sp/protocol/reqrep0/xrep.c b/src/sp/protocol/reqrep0/xrep.c
index 9737c60..9241dcc 100644
--- a/src/sp/protocol/reqrep0/xrep.c
+++ b/src/sp/protocol/reqrep0/xrep.c
@@ -1,5 +1,5 @@
 //
-// Copyright 2020 Staysail Systems, Inc. <info@staysail.tech>
+// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
 // Copyright 2018 Capitar IT Group BV <info@capitar.com>
 //
 // This software is supplied under the terms of the MIT License, a
@@ -58,7 +58,7 @@ xrep0_sock_fini(void *arg)
 	nni_mtx_fini(&s->lk);
 }
 
-static int
+static void
 xrep0_sock_init(void *arg, nni_sock *sock)
 {
 	xrep0_sock *s = arg;
@@ -71,7 +71,6 @@ xrep0_sock_init(void *arg, nni_sock *sock)
 	s->urq = nni_sock_recvq(sock);
 
 	nni_id_map_init(&s->pipes, 0, 0, false);
-	return (0);
 }
 
 static void
diff --git a/src/sp/protocol/reqrep0/xreq.c b/src/sp/protocol/reqrep0/xreq.c
index bcb218b..787c230 100644
--- a/src/sp/protocol/reqrep0/xreq.c
+++ b/src/sp/protocol/reqrep0/xreq.c
@@ -1,5 +1,5 @@
 //
-// Copyright 2020 Staysail Systems, Inc. <info@staysail.tech>
+// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
 // Copyright 2018 Capitar IT Group BV <info@capitar.com>
 //
 // This software is supplied under the terms of the MIT License, a
@@ -42,7 +42,7 @@ static void xreq0_send_cb(void *);
 static void xreq0_recv_cb(void *);
 static void xreq0_putq_cb(void *);
 
-static int
+static void
 xreq0_sock_init(void *arg, nni_sock *sock)
 {
 	xreq0_sock *s = arg;
@@ -51,8 +51,6 @@ xreq0_sock_init(void *arg, nni_sock *sock)
 	nni_atomic_set(&s->ttl, 8);
 	s->uwq = nni_sock_sendq(sock);
 	s->urq = nni_sock_recvq(sock);
-
-	return (0);
 }
 
 static void
diff --git a/src/sp/protocol/survey0/respond.c b/src/sp/protocol/survey0/respond.c
index ad551c8..d29eab9 100644
--- a/src/sp/protocol/survey0/respond.c
+++ b/src/sp/protocol/survey0/respond.c
@@ -1,5 +1,5 @@
 //
-// Copyright 2020 Staysail Systems, Inc. <info@staysail.tech>
+// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
 // Copyright 2018 Capitar IT Group BV <info@capitar.com>
 //
 // This software is supplied under the terms of the MIT License, a
@@ -104,7 +104,7 @@ resp0_ctx_fini(void *arg)
 	resp0_ctx_close(ctx);
 }
 
-static int
+static void
 resp0_ctx_init(void *carg, void *sarg)
 {
 	resp0_sock *s   = sarg;
@@ -115,8 +115,6 @@ resp0_ctx_init(void *carg, void *sarg)
 	ctx->btrace_len = 0;
 	ctx->sock       = s;
 	ctx->pipe_id    = 0;
-
-	return (0);
 }
 
 static void
@@ -220,7 +218,7 @@ resp0_sock_fini(void *arg)
 	nni_mtx_fini(&s->mtx);
 }
 
-static int
+static void
 resp0_sock_init(void *arg, nni_sock *nsock)
 {
 	resp0_sock *s = arg;
@@ -236,13 +234,12 @@ resp0_sock_init(void *arg, nni_sock *nsock)
 	nni_atomic_init(&s->ttl);
 	nni_atomic_set(&s->ttl, 8); // Per RFC
 
-	(void) resp0_ctx_init(&s->ctx, s);
+	resp0_ctx_init(&s->ctx, s);
 
 	// We start off without being either readable or writable.
 	// Readability comes when there is something on the socket.
 	nni_pollable_init(&s->writable);
 	nni_pollable_init(&s->readable);
-	return (0);
 }
 
 static void
@@ -492,7 +489,7 @@ resp0_pipe_recv_cb(void *arg)
 	// Move backtrace from body to header
 	hops = 1;
 	for (;;) {
-		bool     end = 0;
+		bool     end;
 		uint8_t *body;
 
 		if (hops > ttl) {
diff --git a/src/sp/protocol/survey0/respond_test.c b/src/sp/protocol/survey0/respond_test.c
index 51844c7..15762f0 100644
--- a/src/sp/protocol/survey0/respond_test.c
+++ b/src/sp/protocol/survey0/respond_test.c
@@ -196,9 +196,9 @@ test_resp_close_pipe_before_send(void)
 
 	NUTS_PASS(nng_respondent0_open(&resp));
 	NUTS_PASS(nng_surveyor0_open(&surv));
-	NUTS_PASS(nng_setopt_ms(resp, NNG_OPT_RECVTIMEO, 1000));
-	NUTS_PASS(nng_setopt_ms(resp, NNG_OPT_SENDTIMEO, 1000));
-	NUTS_PASS(nng_setopt_ms(surv, NNG_OPT_SENDTIMEO, 1000));
+	NUTS_PASS(nng_socket_set_ms(resp, NNG_OPT_RECVTIMEO, 1000));
+	NUTS_PASS(nng_socket_set_ms(resp, NNG_OPT_SENDTIMEO, 1000));
+	NUTS_PASS(nng_socket_set_ms(surv, NNG_OPT_SENDTIMEO, 1000));
 	NUTS_PASS(nng_aio_alloc(&aio1, NULL, NULL));
 
 	NUTS_MARRY(surv, resp);
@@ -227,13 +227,13 @@ test_resp_close_pipe_during_send(void)
 
 	NUTS_PASS(nng_respondent0_open(&resp));
 	NUTS_PASS(nng_surveyor0_open_raw(&surv));
-	NUTS_PASS(nng_setopt_ms(resp, NNG_OPT_RECVTIMEO, 1000));
-	NUTS_PASS(nng_setopt_ms(resp, NNG_OPT_SENDTIMEO, 200));
-	NUTS_PASS(nng_setopt_ms(surv, NNG_OPT_SENDTIMEO, 1000));
-	NUTS_PASS(nng_setopt_int(resp, NNG_OPT_SENDBUF, 20));
-	NUTS_PASS(nng_setopt_int(resp, NNG_OPT_RECVBUF, 20));
-	NUTS_PASS(nng_setopt_int(surv, NNG_OPT_SENDBUF, 20));
-	NUTS_PASS(nng_setopt_int(surv, NNG_OPT_RECVBUF, 1));
+	NUTS_PASS(nng_socket_set_ms(resp, NNG_OPT_RECVTIMEO, 1000));
+	NUTS_PASS(nng_socket_set_ms(resp, NNG_OPT_SENDTIMEO, 200));
+	NUTS_PASS(nng_socket_set_ms(surv, NNG_OPT_SENDTIMEO, 1000));
+	NUTS_PASS(nng_socket_set_int(resp, NNG_OPT_SENDBUF, 20));
+	NUTS_PASS(nng_socket_set_int(resp, NNG_OPT_RECVBUF, 20));
+	NUTS_PASS(nng_socket_set_int(surv, NNG_OPT_SENDBUF, 20));
+	NUTS_PASS(nng_socket_set_int(surv, NNG_OPT_RECVBUF, 1));
 
 	NUTS_MARRY(surv, resp);
 
@@ -291,13 +291,13 @@ test_resp_close_pipe_context_send(void)
 
 	NUTS_PASS(nng_respondent0_open(&resp));
 	NUTS_PASS(nng_surveyor0_open_raw(&surv));
-	NUTS_PASS(nng_setopt_ms(resp, NNG_OPT_RECVTIMEO, 1000));
-	NUTS_PASS(nng_setopt_ms(resp, NNG_OPT_SENDTIMEO, 1000));
-	NUTS_PASS(nng_setopt_ms(surv, NNG_OPT_SENDTIMEO, 1000));
-	NUTS_PASS(nng_setopt_int(resp, NNG_OPT_SENDBUF, 1));
-	NUTS_PASS(nng_setopt_int(resp, NNG_OPT_RECVBUF, 1));
-	NUTS_PASS(nng_setopt_int(surv, NNG_OPT_SENDBUF, 1));
-	NUTS_PASS(nng_setopt_int(surv, NNG_OPT_RECVBUF, 1));
+	NUTS_PASS(nng_socket_set_ms(resp, NNG_OPT_RECVTIMEO, 1000));
+	NUTS_PASS(nng_socket_set_ms(resp, NNG_OPT_SENDTIMEO, 1000));
+	NUTS_PASS(nng_socket_set_ms(surv, NNG_OPT_SENDTIMEO, 1000));
+	NUTS_PASS(nng_socket_set_int(resp, NNG_OPT_SENDBUF, 1));
+	NUTS_PASS(nng_socket_set_int(resp, NNG_OPT_RECVBUF, 1));
+	NUTS_PASS(nng_socket_set_int(surv, NNG_OPT_SENDBUF, 1));
+	NUTS_PASS(nng_socket_set_int(surv, NNG_OPT_RECVBUF, 1));
 	for (i = 0; i < 10; i++) {
 		NUTS_PASS(nng_ctx_open(&ctx[i], resp));
 		NUTS_PASS(nng_aio_alloc(&aio[i], NULL, NULL));
@@ -350,13 +350,13 @@ test_resp_close_context_send(void)
 
 	NUTS_PASS(nng_respondent0_open(&resp));
 	NUTS_PASS(nng_surveyor0_open_raw(&surv));
-	NUTS_PASS(nng_setopt_ms(resp, NNG_OPT_RECVTIMEO, 1000));
-	NUTS_PASS(nng_setopt_ms(resp, NNG_OPT_SENDTIMEO, 1000));
-	NUTS_PASS(nng_setopt_ms(surv, NNG_OPT_SENDTIMEO, 1000));
-	NUTS_PASS(nng_setopt_int(resp, NNG_OPT_SENDBUF, 1));
-	NUTS_PASS(nng_setopt_int(resp, NNG_OPT_RECVBUF, 1));
-	NUTS_PASS(nng_setopt_int(surv, NNG_OPT_SENDBUF, 1));
-	NUTS_PASS(nng_setopt_int(surv, NNG_OPT_RECVBUF, 1));
+	NUTS_PASS(nng_socket_set_ms(resp, NNG_OPT_RECVTIMEO, 1000));
+	NUTS_PASS(nng_socket_set_ms(resp, NNG_OPT_SENDTIMEO, 1000));
+	NUTS_PASS(nng_socket_set_ms(surv, NNG_OPT_SENDTIMEO, 1000));
+	NUTS_PASS(nng_socket_set_int(resp, NNG_OPT_SENDBUF, 1));
+	NUTS_PASS(nng_socket_set_int(resp, NNG_OPT_RECVBUF, 1));
+	NUTS_PASS(nng_socket_set_int(surv, NNG_OPT_SENDBUF, 1));
+	NUTS_PASS(nng_socket_set_int(surv, NNG_OPT_RECVBUF, 1));
 	for (i = 0; i < 10; i++) {
 		NUTS_PASS(nng_ctx_open(&ctx[i], resp));
 		NUTS_PASS(nng_aio_alloc(&aio[i], NULL, NULL));
@@ -425,9 +425,9 @@ test_resp_ctx_send_nonblock(void)
 
 	NUTS_PASS(nng_surveyor0_open(&surv));
 	NUTS_PASS(nng_respondent0_open(&resp));
-	NUTS_PASS(nng_setopt_ms(surv, NNG_OPT_SENDTIMEO, 1000));
-	NUTS_PASS(nng_setopt_ms(resp, NNG_OPT_RECVTIMEO, 1000));
-	NUTS_PASS(nng_setopt_ms(resp, NNG_OPT_SENDTIMEO, 1000));
+	NUTS_PASS(nng_socket_set_ms(surv, NNG_OPT_SENDTIMEO, 1000));
+	NUTS_PASS(nng_socket_set_ms(resp, NNG_OPT_RECVTIMEO, 1000));
+	NUTS_PASS(nng_socket_set_ms(resp, NNG_OPT_SENDTIMEO, 1000));
 	NUTS_PASS(nng_ctx_open(&ctx, resp));
 	NUTS_PASS(nng_aio_alloc(&aio, NULL, NULL));
 	NUTS_MARRY(surv, resp);
@@ -459,9 +459,9 @@ test_resp_recv_garbage(void)
 
 	NUTS_PASS(nng_respondent0_open(&resp));
 	NUTS_PASS(nng_surveyor0_open_raw(&surv));
-	NUTS_PASS(nng_setopt_ms(resp, NNG_OPT_RECVTIMEO, 200));
-	NUTS_PASS(nng_setopt_ms(resp, NNG_OPT_SENDTIMEO, 200));
-	NUTS_PASS(nng_setopt_ms(surv, NNG_OPT_SENDTIMEO, 1000));
+	NUTS_PASS(nng_socket_set_ms(resp, NNG_OPT_RECVTIMEO, 200));
+	NUTS_PASS(nng_socket_set_ms(resp, NNG_OPT_SENDTIMEO, 200));
+	NUTS_PASS(nng_socket_set_ms(surv, NNG_OPT_SENDTIMEO, 1000));
 
 	NUTS_MARRY(surv, resp);
 
@@ -485,12 +485,12 @@ test_resp_ttl_option(void)
 
 	NUTS_PASS(nng_respondent0_open(&resp));
 
-	NUTS_PASS(nng_setopt_int(resp, opt, 1));
-	NUTS_FAIL(nng_setopt_int(resp, opt, 0), NNG_EINVAL);
-	NUTS_FAIL(nng_setopt_int(resp, opt, -1), NNG_EINVAL);
-	NUTS_FAIL(nng_setopt_int(resp, opt, 16), NNG_EINVAL);
-	NUTS_FAIL(nng_setopt_int(resp, opt, 256), NNG_EINVAL);
-	NUTS_PASS(nng_setopt_int(resp, opt, 3));
+	NUTS_PASS(nng_socket_set_int(resp, opt, 1));
+	NUTS_FAIL(nng_socket_set_int(resp, opt, 0), NNG_EINVAL);
+	NUTS_FAIL(nng_socket_set_int(resp, opt, -1), NNG_EINVAL);
+	NUTS_FAIL(nng_socket_set_int(resp, opt, 16), NNG_EINVAL);
+	NUTS_FAIL(nng_socket_set_int(resp, opt, 256), NNG_EINVAL);
+	NUTS_PASS(nng_socket_set_int(resp, opt, 3));
 	NUTS_PASS(nng_socket_get_int(resp, opt, &v));
 	NUTS_TRUE(v == 3);
 	v  = 0;
@@ -499,10 +499,10 @@ test_resp_ttl_option(void)
 	NUTS_TRUE(v == 3);
 	NUTS_TRUE(sz == sizeof(v));
 
-	NUTS_FAIL(nng_setopt(resp, opt, "", 1), NNG_EINVAL);
+	NUTS_FAIL(nng_socket_set(resp, opt, "", 1), NNG_EINVAL);
 	sz = 1;
 	NUTS_FAIL(nng_socket_get(resp, opt, &v, &sz), NNG_EINVAL);
-	NUTS_FAIL(nng_setopt_bool(resp, opt, true), NNG_EBADTYPE);
+	NUTS_FAIL(nng_socket_set_bool(resp, opt, true), NNG_EBADTYPE);
 	NUTS_FAIL(nng_socket_get_bool(resp, opt, &b), NNG_EBADTYPE);
 
 	NUTS_CLOSE(resp);
@@ -517,9 +517,9 @@ test_resp_ttl_drop(void)
 
 	NUTS_PASS(nng_respondent0_open(&resp));
 	NUTS_PASS(nng_surveyor0_open_raw(&surv));
-	NUTS_PASS(nng_setopt_int(resp, NNG_OPT_MAXTTL, 3));
-	NUTS_PASS(nng_setopt_ms(resp, NNG_OPT_RECVTIMEO, 200));
-	NUTS_PASS(nng_setopt_ms(surv, NNG_OPT_SENDTIMEO, 1000));
+	NUTS_PASS(nng_socket_set_int(resp, NNG_OPT_MAXTTL, 3));
+	NUTS_PASS(nng_socket_set_ms(resp, NNG_OPT_RECVTIMEO, 200));
+	NUTS_PASS(nng_socket_set_ms(surv, NNG_OPT_SENDTIMEO, 1000));
 
 	NUTS_MARRY(surv, resp);
 
diff --git a/src/sp/protocol/survey0/survey.c b/src/sp/protocol/survey0/survey.c
index ce1ed60..5c52d8f 100644
--- a/src/sp/protocol/survey0/survey.c
+++ b/src/sp/protocol/survey0/survey.c
@@ -1,5 +1,5 @@
 //
-// Copyright 2020 Staysail Systems, Inc. <info@staysail.tech>
+// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
 // Copyright 2018 Capitar IT Group BV <info@capitar.com>
 //
 // This software is supplied under the terms of the MIT License, a
@@ -103,12 +103,11 @@ surv0_ctx_fini(void *arg)
 	nni_lmq_fini(&ctx->recv_lmq);
 }
 
-static int
+static void
 surv0_ctx_init(void *c, void *s)
 {
 	surv0_ctx *  ctx  = c;
 	surv0_sock * sock = s;
-	int          rv;
 	int          len;
 	nng_duration tmo;
 
@@ -129,12 +128,8 @@ surv0_ctx_init(void *c, void *s)
 
 	ctx->sock = sock;
 
-	if ((rv = nni_lmq_init(&ctx->recv_lmq, len)) != 0) {
-		surv0_ctx_fini(ctx);
-		return (rv);
-	}
+	nni_lmq_init(&ctx->recv_lmq, len);
 	nni_timer_init(&ctx->timer, surv0_ctx_timeout, ctx);
-	return (0);
 }
 
 static void
@@ -172,7 +167,7 @@ surv0_ctx_recv(void *arg, nni_aio *aio)
 		return;
 	}
 again:
-	if (nni_lmq_getq(&ctx->recv_lmq, &msg) != 0) {
+	if (nni_lmq_get(&ctx->recv_lmq, &msg) != 0) {
 		int rv;
 		if ((rv = nni_aio_schedule(aio, &surv0_ctx_cancel, ctx)) !=
 		    0) {
@@ -259,7 +254,7 @@ surv0_ctx_send(void *arg, nni_aio *aio)
 			nni_pipe_send(pipe->pipe, &pipe->aio_send);
 		} else if (!nni_lmq_full(&pipe->send_queue)) {
 			nni_msg_clone(msg);
-			nni_lmq_putq(&pipe->send_queue, msg);
+			nni_lmq_put(&pipe->send_queue, msg);
 		}
 	}
 
@@ -284,11 +279,10 @@ surv0_sock_fini(void *arg)
 	nni_mtx_fini(&sock->mtx);
 }
 
-static int
+static void
 surv0_sock_init(void *arg, nni_sock *s)
 {
 	surv0_sock *sock = arg;
-	int         rv;
 
 	NNI_ARG_UNUSED(s);
 
@@ -299,7 +293,7 @@ surv0_sock_init(void *arg, nni_sock *s)
 	// We are always writable.
 	nni_pollable_raise(&sock->writable);
 
-	// We allow for some buffering on a per pipe basis, to allow for
+	// We allow for some buffering on a per-pipe basis, to allow for
 	// multiple contexts to have surveys outstanding.  It is recommended
 	// to increase this if many contexts will want to publish
 	// at nearly the same time.
@@ -311,14 +305,9 @@ surv0_sock_init(void *arg, nni_sock *s)
 	// accidental collision across restarts.
 	nni_id_map_init(&sock->surveys, 0x80000000u, 0xffffffffu, true);
 
-	if ((rv = surv0_ctx_init(&sock->ctx, sock)) != 0) {
-		surv0_sock_fini(sock);
-		return (rv);
-	}
+	surv0_ctx_init(&sock->ctx, sock);
 
 	sock->ttl = 8;
-
-	return (0);
 }
 
 static void
@@ -359,7 +348,6 @@ surv0_pipe_init(void *arg, nni_pipe *pipe, void *s)
 {
 	surv0_pipe *p    = arg;
 	surv0_sock *sock = s;
-	int         rv;
 	int         len;
 
 	len = nni_atomic_get(&sock->send_buf);
@@ -369,10 +357,7 @@ surv0_pipe_init(void *arg, nni_pipe *pipe, void *s)
 	// This depth could be tunable.  The deeper the queue, the more
 	// concurrent surveys that can be delivered (multiple contexts).
 	// Note that surveys can be *outstanding*, but not yet put on the wire.
-	if ((rv = nni_lmq_init(&p->send_queue, len)) != 0) {
-		surv0_pipe_fini(p);
-		return (rv);
-	}
+	nni_lmq_init(&p->send_queue, len);
 
 	p->pipe = pipe;
 	p->sock = sock;
@@ -434,7 +419,7 @@ surv0_pipe_send_cb(void *arg)
 		nni_mtx_unlock(&sock->mtx);
 		return;
 	}
-	if (nni_lmq_getq(&p->send_queue, &msg) == 0) {
+	if (nni_lmq_get(&p->send_queue, &msg) == 0) {
 		nni_aio_set_msg(&p->aio_send, msg);
 		nni_pipe_send(p->pipe, &p->aio_send);
 	} else {
@@ -482,7 +467,7 @@ surv0_pipe_recv_cb(void *arg)
 		nni_list_remove(&ctx->recv_queue, aio);
 		nni_aio_finish_msg(aio, msg);
 	} else {
-		nni_lmq_putq(&ctx->recv_lmq, msg);
+		nni_lmq_put(&ctx->recv_lmq, msg);
 		if (ctx == &sock->ctx) {
 			nni_pollable_raise(&sock->readable);
 		}
diff --git a/src/sp/protocol/survey0/survey_test.c b/src/sp/protocol/survey0/survey_test.c
index 95d27ad..1e1b863 100644
--- a/src/sp/protocol/survey0/survey_test.c
+++ b/src/sp/protocol/survey0/survey_test.c
@@ -1,5 +1,5 @@
 //
-// Copyright 2020 Staysail Systems, Inc. <info@staysail.tech>
+// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
 // Copyright 2018 Capitar IT Group BV <info@capitar.com>
 //
 // This software is supplied under the terms of the MIT License, a
@@ -15,7 +15,7 @@ test_surv_identity(void)
 {
 	nng_socket s;
 	int        p;
-	char *     n;
+	char      *n;
 
 	NUTS_PASS(nng_surveyor0_open(&s));
 	NUTS_PASS(nng_socket_get_int(s, NNG_OPT_PROTO, &p));
@@ -74,7 +74,7 @@ test_surv_survey_time_option(void)
 	nng_duration d;
 	bool         b;
 	size_t       sz  = sizeof(b);
-	const char * opt = NNG_OPT_SURVEYOR_SURVEYTIME;
+	const char  *opt = NNG_OPT_SURVEYOR_SURVEYTIME;
 
 	NUTS_PASS(nng_surveyor0_open(&surv));
 
@@ -93,7 +93,7 @@ void
 test_surv_recv_bad_state(void)
 {
 	nng_socket surv;
-	nng_msg *  msg = NULL;
+	nng_msg   *msg = NULL;
 
 	NUTS_PASS(nng_surveyor0_open(&surv));
 	NUTS_FAIL(nng_recvmsg(surv, &msg, 0), NNG_ESTATE);
@@ -106,7 +106,7 @@ test_surv_recv_garbage(void)
 {
 	nng_socket resp;
 	nng_socket surv;
-	nng_msg *  m;
+	nng_msg   *m;
 	uint32_t   surv_id;
 
 	NUTS_PASS(nng_respondent0_open_raw(&resp));
@@ -216,7 +216,7 @@ test_surv_cancel(void)
 void
 test_surv_cancel_abort_recv(void)
 {
-	nng_aio *    aio;
+	nng_aio     *aio;
 	nng_duration time = SECOND * 10; // 10s (kind of never)
 	nng_socket   surv;
 	nng_socket   resp;
@@ -334,7 +334,7 @@ test_surv_poll_readable(void)
 	int        fd;
 	nng_socket surv;
 	nng_socket resp;
-	nng_msg *  msg;
+	nng_msg   *msg;
 
 	NUTS_PASS(nng_surveyor0_open(&surv));
 	NUTS_PASS(nng_respondent0_open(&resp));
@@ -392,8 +392,8 @@ test_surv_ctx_recv_nonblock(void)
 	nng_socket surv;
 	nng_socket resp;
 	nng_ctx    ctx;
-	nng_aio *  aio;
-	nng_msg *  msg;
+	nng_aio   *aio;
+	nng_msg   *msg;
 
 	NUTS_PASS(nng_surveyor0_open(&surv));
 	NUTS_PASS(nng_respondent0_open(&resp));
@@ -417,13 +417,39 @@ test_surv_ctx_recv_nonblock(void)
 	nng_aio_free(aio);
 }
 
+static void
+test_surv_ctx_send_recv_msg(void)
+{
+	nng_socket surv;
+	nng_socket resp;
+	nng_ctx    ctx1;
+	nng_ctx    ctx2;
+	nng_msg   *msg;
+
+	NUTS_PASS(nng_surveyor0_open(&surv));
+	NUTS_PASS(nng_respondent0_open(&resp));
+	NUTS_PASS(nng_ctx_open(&ctx1, surv));
+	NUTS_PASS(nng_ctx_open(&ctx2, resp));
+	NUTS_PASS(nng_msg_alloc(&msg, 0));
+
+	NUTS_MARRY(surv, resp);
+
+	NUTS_PASS(nng_ctx_sendmsg(ctx1, msg, 0));
+	NUTS_PASS(nng_ctx_recvmsg(ctx2, &msg, 0));
+	nng_msg_free(msg);
+	NUTS_PASS(nng_ctx_close(ctx1));
+	NUTS_PASS(nng_ctx_close(ctx2));
+	NUTS_CLOSE(surv);
+	NUTS_CLOSE(resp);
+}
+
 static void
 test_surv_ctx_send_nonblock(void)
 {
 	nng_socket surv;
 	nng_ctx    ctx;
-	nng_aio *  aio;
-	nng_msg *  msg;
+	nng_aio   *aio;
+	nng_msg   *msg;
 
 	NUTS_PASS(nng_surveyor0_open(&surv));
 	NUTS_PASS(nng_ctx_open(&ctx, surv));
@@ -490,8 +516,8 @@ test_surv_ctx_recv_close_socket(void)
 	nng_socket surv;
 	nng_socket resp;
 	nng_ctx    ctx;
-	nng_aio *  aio;
-	nng_msg *  m;
+	nng_aio   *aio;
+	nng_msg   *m;
 
 	NUTS_PASS(nng_surveyor0_open(&surv));
 	NUTS_PASS(nng_respondent0_open(&resp));
@@ -518,8 +544,8 @@ test_surv_context_multi(void)
 	nng_socket surv;
 	nng_socket resp;
 	nng_ctx    c[5];
-	nng_aio *  aio;
-	nng_msg *  m;
+	nng_aio   *aio;
+	nng_msg   *m;
 	int        cnt = sizeof(c) / sizeof(c[0]);
 
 	NUTS_PASS(nng_surveyor0_open(&surv));
@@ -575,9 +601,9 @@ static void
 test_surv_validate_peer(void)
 {
 	nng_socket s1, s2;
-	nng_stat * stats;
-	nng_stat * reject;
-	char *     addr;
+	nng_stat  *stats;
+	nng_stat  *reject;
+	char      *addr;
 
 	NUTS_ADDR(addr, "inproc");
 	NUTS_PASS(nng_surveyor0_open(&s1));
@@ -618,6 +644,7 @@ TEST_LIST = {
 	    test_surv_ctx_recv_close_socket },
 	{ "survey context recv nonblock", test_surv_ctx_recv_nonblock },
 	{ "survey context send nonblock", test_surv_ctx_send_nonblock },
+	{ "survey context send recv msg", test_surv_ctx_send_recv_msg },
 	{ "survey timeout", test_surv_survey_timeout },
 	{ "survey send best effort", test_surv_send_best_effort },
 	{ "survey context multi", test_surv_context_multi },
diff --git a/src/sp/protocol/survey0/xrespond.c b/src/sp/protocol/survey0/xrespond.c
index b2f203c..81a4048 100644
--- a/src/sp/protocol/survey0/xrespond.c
+++ b/src/sp/protocol/survey0/xrespond.c
@@ -1,5 +1,5 @@
 //
-// Copyright 2020 Staysail Systems, Inc. <info@staysail.tech>
+// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
 // Copyright 2018 Capitar IT Group BV <info@capitar.com>
 //
 // This software is supplied under the terms of the MIT License, a
@@ -67,8 +67,8 @@ xresp0_sock_fini(void *arg)
 	nni_mtx_fini(&s->mtx);
 }
 
-static int
-xresp0_sock_init(void *arg, nni_sock *nsock)
+static void
+xresp0_sock_init(void *arg, nni_sock *ns)
 {
 	xresp0_sock *s = arg;
 
@@ -78,10 +78,8 @@ xresp0_sock_init(void *arg, nni_sock *nsock)
 	nni_id_map_init(&s->pipes, 0, 0, false);
 	nni_aio_init(&s->aio_getq, xresp0_sock_getq_cb, s);
 
-	s->urq = nni_sock_recvq(nsock);
-	s->uwq = nni_sock_sendq(nsock);
-
-	return (0);
+	s->urq = nni_sock_recvq(ns);
+	s->uwq = nni_sock_sendq(ns);
 }
 
 static void
diff --git a/src/sp/protocol/survey0/xsurvey.c b/src/sp/protocol/survey0/xsurvey.c
index 2a19866..3cb3b6b 100644
--- a/src/sp/protocol/survey0/xsurvey.c
+++ b/src/sp/protocol/survey0/xsurvey.c
@@ -1,5 +1,5 @@
 //
-// Copyright 2020 Staysail Systems, Inc. <info@staysail.tech>
+// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
 // Copyright 2018 Capitar IT Group BV <info@capitar.com>
 //
 // This software is supplied under the terms of the MIT License, a
@@ -54,7 +54,7 @@ xsurv0_sock_fini(void *arg)
 	nni_mtx_fini(&s->mtx);
 }
 
-static int
+static void
 xsurv0_sock_init(void *arg, nni_sock *nsock)
 {
 	xsurv0_sock *s = arg;
@@ -67,8 +67,6 @@ xsurv0_sock_init(void *arg, nni_sock *nsock)
 	s->urq = nni_sock_recvq(nsock);
 	nni_atomic_init(&s->ttl);
 	nni_atomic_set(&s->ttl, 8);
-
-	return (0);
 }
 
 static void
diff --git a/src/sp/transport.c b/src/sp/transport.c
index 13961ea..9f4c652 100644
--- a/src/sp/transport.c
+++ b/src/sp/transport.c
@@ -14,8 +14,9 @@
 #include <stdio.h>
 #include <string.h>
 
-static nni_list   sp_tran_list;
-static nni_rwlock sp_tran_lk;
+static nni_list sp_tran_list =
+    NNI_LIST_INITIALIZER(sp_tran_list, nni_sp_tran, tran_link);
+static nni_rwlock sp_tran_lk = NNI_RWLOCK_INITIALIZER;
 
 void
 nni_sp_tran_register(nni_sp_tran *tran)
@@ -70,12 +71,9 @@ extern void nni_sp_wss_register(void);
 extern void nni_sp_zt_register(void);
 #endif
 
-int
+void
 nni_sp_tran_sys_init(void)
 {
-	NNI_LIST_INIT(&sp_tran_list, nni_sp_tran, tran_link);
-	nni_rwlock_init(&sp_tran_lk);
-
 #ifdef NNG_TRANSPORT_INPROC
 	nni_sp_inproc_register();
 #endif
@@ -97,7 +95,6 @@ nni_sp_tran_sys_init(void)
 #ifdef NNG_TRANSPORT_ZEROTIER
 	nni_sp_zt_register();
 #endif
-	return (0);
 }
 
 // nni_sp_tran_sys_fini finalizes the entire transport system, including all
@@ -111,5 +108,4 @@ nni_sp_tran_sys_fini(void)
 		nni_list_remove(&sp_tran_list, t);
 		t->tran_fini();
 	}
-	nni_rwlock_fini(&sp_tran_lk);
 }
diff --git a/src/sp/transport.h b/src/sp/transport.h
index 08f169b..76d8d36 100644
--- a/src/sp/transport.h
+++ b/src/sp/transport.h
@@ -169,7 +169,7 @@ struct nni_sp_tran {
 // These APIs are used by the framework internally, and not for use by
 // transport implementations.
 extern nni_sp_tran *nni_sp_tran_find(nni_url *);
-extern int          nni_sp_tran_sys_init(void);
+extern void         nni_sp_tran_sys_init(void);
 extern void         nni_sp_tran_sys_fini(void);
 extern void         nni_sp_tran_register(nni_sp_tran *);
 
diff --git a/src/sp/transport/inproc/inproc.c b/src/sp/transport/inproc/inproc.c
index 971b887..2ab8b0b 100644
--- a/src/sp/transport/inproc/inproc.c
+++ b/src/sp/transport/inproc/inproc.c
@@ -29,8 +29,8 @@ typedef struct {
 
 // inproc_pipe represents one half of a connection.
 struct inproc_pipe {
-	const char *  addr;
-	inproc_pair * pair;
+	const char   *addr;
+	inproc_pair  *pair;
 	inproc_queue *recv_queue;
 	inproc_queue *send_queue;
 	uint16_t      peer;
@@ -52,7 +52,7 @@ struct inproc_pair {
 };
 
 struct inproc_ep {
-	const char *  addr;
+	const char   *addr;
 	bool          listener;
 	nni_list_node node;
 	uint16_t      proto;
@@ -65,20 +65,19 @@ struct inproc_ep {
 
 // nni_inproc is our global state - this contains the list of active endpoints
 // which we use for coordinating rendezvous.
-static inproc_global nni_inproc;
+static inproc_global nni_inproc = {
+	.servers = NNI_LIST_INITIALIZER(nni_inproc.servers, inproc_ep, node),
+	.mx      = NNI_MTX_INITIALIZER,
+};
 
 static void
 inproc_init(void)
 {
-	NNI_LIST_INIT(&nni_inproc.servers, inproc_ep, node);
-
-	nni_mtx_init(&nni_inproc.mx);
 }
 
 static void
 inproc_fini(void)
 {
-	nni_mtx_fini(&nni_inproc.mx);
 }
 
 // inproc_pair destroy is called when both pipe-ends of the pipe
@@ -203,7 +202,7 @@ inproc_queue_cancel(nni_aio *aio, void *arg, int rv)
 static void
 inproc_pipe_send(void *arg, nni_aio *aio)
 {
-	inproc_pipe * pipe  = arg;
+	inproc_pipe  *pipe  = arg;
 	inproc_queue *queue = pipe->send_queue;
 	int           rv;
 
@@ -225,7 +224,7 @@ inproc_pipe_send(void *arg, nni_aio *aio)
 static void
 inproc_pipe_recv(void *arg, nni_aio *aio)
 {
-	inproc_pipe * pipe  = arg;
+	inproc_pipe  *pipe  = arg;
 	inproc_queue *queue = pipe->recv_queue;
 	int           rv;
 
@@ -283,7 +282,7 @@ static int
 inproc_dialer_init(void **epp, nni_url *url, nni_dialer *ndialer)
 {
 	inproc_ep *ep;
-	nni_sock * sock = nni_dialer_sock(ndialer);
+	nni_sock  *sock = nni_dialer_sock(ndialer);
 
 	if ((ep = NNI_ALLOC_STRUCT(ep)) == NULL) {
 		return (NNG_ENOMEM);
@@ -306,7 +305,7 @@ static int
 inproc_listener_init(void **epp, nni_url *url, nni_listener *nlistener)
 {
 	inproc_ep *ep;
-	nni_sock * sock = nni_listener_sock(nlistener);
+	nni_sock  *sock = nni_listener_sock(nlistener);
 
 	if ((ep = NNI_ALLOC_STRUCT(ep)) == NULL) {
 		return (NNG_ENOMEM);
@@ -356,7 +355,7 @@ inproc_ep_close(void *arg)
 {
 	inproc_ep *ep = arg;
 	inproc_ep *client;
-	nni_aio *  aio;
+	nni_aio   *aio;
 
 	nni_mtx_lock(&nni_inproc.mx);
 	if (nni_list_active(&nni_inproc.servers, ep)) {
@@ -389,7 +388,7 @@ inproc_accept_clients(inproc_ep *srv)
 			inproc_pipe *cpipe;
 			inproc_pipe *spipe;
 			inproc_pair *pair;
-			nni_aio *    saio;
+			nni_aio     *saio;
 			int          rv;
 
 			if ((saio = nni_list_first(&srv->aios)) == NULL) {
@@ -511,7 +510,7 @@ inproc_ep_bind(void *arg)
 {
 	inproc_ep *ep = arg;
 	inproc_ep *srch;
-	nni_list * list = &nni_inproc.servers;
+	nni_list  *list = &nni_inproc.servers;
 
 	nni_mtx_lock(&nni_inproc.mx);
 	NNI_LIST_FOREACH (list, srch) {
@@ -580,7 +579,7 @@ inproc_ep_set_recvmaxsz(void *arg, const void *v, size_t sz, nni_opt_type t)
 static int
 inproc_ep_get_addr(void *arg, void *v, size_t *szp, nni_opt_type t)
 {
-	inproc_ep *  ep = arg;
+	inproc_ep   *ep = arg;
 	nng_sockaddr sa;
 	sa.s_inproc.sa_family = NNG_AF_INPROC;
 	nni_strlcpy(
diff --git a/src/sp/transport/ipc/ipc.c b/src/sp/transport/ipc/ipc.c
index 8ed4ac9..df27ad2 100644
--- a/src/sp/transport/ipc/ipc.c
+++ b/src/sp/transport/ipc/ipc.c
@@ -1,5 +1,5 @@
 //
-// Copyright 2020 Staysail Systems, Inc. <info@staysail.tech>
+// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
 // Copyright 2018 Capitar IT Group BV <info@capitar.com>
 // Copyright 2019 Devolutions <info@devolutions.net>
 //
@@ -10,7 +10,6 @@
 //
 
 #include <stdio.h>
-#include <stdlib.h>
 
 #include "core/nng_impl.h"
 
@@ -251,8 +250,8 @@ ipc_pipe_neg_cb(void *arg)
 		nni_mtx_unlock(&p->ep->mtx);
 		return;
 	}
-	// We have both sent and received the headers.  Lets check the
-	// receive side header.
+	// We have both sent and received the headers.  Let's check the
+	// receiver.
 	if ((p->rx_head[0] != 0) || (p->rx_head[1] != 'S') ||
 	    (p->rx_head[2] != 'P') || (p->rx_head[3] != 0) ||
 	    (p->rx_head[6] != 0) || (p->rx_head[7] != 0)) {
@@ -262,7 +261,7 @@ ipc_pipe_neg_cb(void *arg)
 
 	NNI_GET16(&p->rx_head[4], p->peer);
 
-	// We are all ready now.  We put this in the wait list, and
+	// We are ready now.  We put this in the wait list, and
 	// then try to run the matcher.
 	nni_list_remove(&ep->neg_pipes, p);
 	nni_list_append(&ep->wait_pipes, p);
@@ -272,7 +271,13 @@ ipc_pipe_neg_cb(void *arg)
 	return;
 
 error:
-
+	// If the connection is closed, we need to pass back a different
+	// error code.  This is necessary to avoid a problem where the
+	// closed status is confused with the accept file descriptor
+	// being closed.
+	if (rv == NNG_ECLOSED) {
+		rv = NNG_ECONNSHUT;
+	}
 	nng_stream_close(p->conn);
 	// If we are waiting to negotiate on a client side, then a failure
 	// here has to be passed to the user app.
@@ -347,7 +352,7 @@ ipc_pipe_recv_cb(void *arg)
 
 	if ((rv = nni_aio_result(rx_aio)) != 0) {
 		// Error on receive.  This has to cause an error back
-		// to the user.  Also, if we had allocated an rx_msg, lets
+		// to the user.  Also, if we had an allocated rx_msg, lets
 		// toss it.
 		goto error;
 	}
@@ -406,7 +411,7 @@ ipc_pipe_recv_cb(void *arg)
 		}
 	}
 
-	// Otherwise we got a message read completely.  Let the user know the
+	// Otherwise, we got a message read completely.  Let the user know the
 	// good news.
 
 	aio = nni_list_first(&p->recv_q);
diff --git a/src/sp/transport/tcp/tcp.c b/src/sp/transport/tcp/tcp.c
index e2e7fbc..624403a 100644
--- a/src/sp/transport/tcp/tcp.c
+++ b/src/sp/transport/tcp/tcp.c
@@ -9,7 +9,6 @@
 // found online at https://opensource.org/licenses/MIT.
 //
 
-#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
@@ -259,8 +258,8 @@ tcptran_pipe_nego_cb(void *arg)
 		nni_mtx_unlock(&ep->mtx);
 		return;
 	}
-	// We have both sent and received the headers.  Lets check the
-	// receive side header.
+	// We have both sent and received the headers.  Let's check the
+	// receiver.
 	if ((p->rxlen[0] != 0) || (p->rxlen[1] != 'S') ||
 	    (p->rxlen[2] != 'P') || (p->rxlen[3] != 0) || (p->rxlen[6] != 0) ||
 	    (p->rxlen[7] != 0)) {
@@ -270,7 +269,7 @@ tcptran_pipe_nego_cb(void *arg)
 
 	NNI_GET16(&p->rxlen[4], p->peer);
 
-	// We are all ready now.  We put this in the wait list, and
+	// We are ready now.  We put this in the wait list, and
 	// then try to run the matcher.
 	nni_list_remove(&ep->negopipes, p);
 	nni_list_append(&ep->waitpipes, p);
@@ -281,6 +280,13 @@ tcptran_pipe_nego_cb(void *arg)
 	return;
 
 error:
+	// If the connection is closed, we need to pass back a different
+	// error code.  This is necessary to avoid a problem where the
+	// closed status is confused with the accept file descriptor
+	// being closed.
+	if (rv == NNG_ECLOSED) {
+		rv = NNG_ECONNSHUT;
+	}
 	nng_stream_close(p->conn);
 
 	if ((uaio = ep->useraio) != NULL) {
diff --git a/src/sp/transport/tls/tls.c b/src/sp/transport/tls/tls.c
index 7585883..4db9170 100644
--- a/src/sp/transport/tls/tls.c
+++ b/src/sp/transport/tls/tls.c
@@ -258,8 +258,8 @@ tlstran_pipe_nego_cb(void *arg)
 		nni_mtx_unlock(&ep->mtx);
 		return;
 	}
-	// We have both sent and received the headers.  Lets check the
-	// receive side header.
+	// We have both sent and received the headers.  Let's check the
+	// receiver.
 	if ((p->rxlen[0] != 0) || (p->rxlen[1] != 'S') ||
 	    (p->rxlen[2] != 'P') || (p->rxlen[3] != 0) || (p->rxlen[6] != 0) ||
 	    (p->rxlen[7] != 0)) {
@@ -269,7 +269,7 @@ tlstran_pipe_nego_cb(void *arg)
 
 	NNI_GET16(&p->rxlen[4], p->peer);
 
-	// We are all ready now.  We put this in the wait list, and
+	// We are ready now.  We put this in the wait list, and
 	// then try to run the matcher.
 	nni_list_remove(&ep->negopipes, p);
 	nni_list_append(&ep->waitpipes, p);
@@ -280,6 +280,13 @@ tlstran_pipe_nego_cb(void *arg)
 	return;
 
 error:
+	// If the connection is closed, we need to pass back a different
+	// error code.  This is necessary to avoid a problem where the
+	// closed status is confused with the accept file descriptor
+	// being closed.
+	if (rv == NNG_ECLOSED) {
+		rv = NNG_ECONNSHUT;
+	}
 	nng_stream_close(p->tls);
 
 	if ((uaio = ep->useraio) != NULL) {
diff --git a/src/supplemental/http/http_client.c b/src/supplemental/http/http_client.c
index 3737cb7..b156794 100644
--- a/src/supplemental/http/http_client.c
+++ b/src/supplemental/http/http_client.c
@@ -1,5 +1,5 @@
 //
-// Copyright 2020 Staysail Systems, Inc. <info@staysail.tech>
+// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
 // Copyright 2018 Capitar IT Group BV <info@capitar.com>
 // Copyright 2019 Devolutions <info@devolutions.net>
 //
@@ -19,7 +19,7 @@
 
 #include "http_api.h"
 
-static nni_mtx http_txn_lk;
+static nni_mtx http_txn_lk = NNI_MTX_INITIALIZER;
 
 struct nng_http_client {
 	nni_list           aios;
@@ -198,15 +198,6 @@ nni_http_client_connect(nni_http_client *c, nni_aio *aio)
 	nni_mtx_unlock(&c->mtx);
 }
 
-static int  http_client_sys_init(void);
-static void http_client_sys_fini(void);
-
-static nni_initializer http_client_initializer = {
-	.i_init = http_client_sys_init,
-	.i_fini = http_client_sys_fini,
-	.i_once = 0,
-};
-
 typedef enum http_txn_state {
 	HTTP_CONNECTING,
 	HTTP_SENDING,
@@ -385,8 +376,6 @@ nni_http_transact_conn(
 	http_txn *txn;
 	int       rv;
 
-	nni_initialize(&http_client_initializer);
-
 	if (nni_aio_begin(aio) != 0) {
 		return;
 	}
@@ -430,8 +419,6 @@ nni_http_transact(nni_http_client *client, nni_http_req *req,
 	http_txn *txn;
 	int       rv;
 
-	nni_initialize(&http_client_initializer);
-
 	if (nni_aio_begin(aio) != 0) {
 		return;
 	}
@@ -470,16 +457,3 @@ nni_http_transact(nni_http_client *client, nni_http_req *req,
 	nni_http_client_connect(client, txn->aio);
 	nni_mtx_unlock(&http_txn_lk);
 }
-
-static int
-http_client_sys_init(void)
-{
-	nni_mtx_init(&http_txn_lk);
-	return (0);
-}
-
-static void
-http_client_sys_fini(void)
-{
-	nni_mtx_fini(&http_txn_lk);
-}
diff --git a/src/supplemental/http/http_conn.c b/src/supplemental/http/http_conn.c
index 646a306..03d1a1f 100644
--- a/src/supplemental/http/http_conn.c
+++ b/src/supplemental/http/http_conn.c
@@ -1,5 +1,5 @@
 //
-// Copyright 2020 Staysail Systems, Inc. <info@staysail.tech>
+// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
 // Copyright 2018 Capitar IT Group BV <info@capitar.com>
 // Copyright 2019 Devolutions <info@devolutions.net>
 //
@@ -40,16 +40,9 @@ enum write_flavor {
 	HTTP_WR_RES,
 };
 
-#define SET_RD_FLAVOR(aio, f) \
-	nni_aio_set_prov_extra(aio, 0, ((void *) (intptr_t)(f)))
-#define GET_RD_FLAVOR(aio) (int) ((intptr_t) nni_aio_get_prov_extra(aio, 0))
-#define SET_WR_FLAVOR(aio, f) \
-	nni_aio_set_prov_extra(aio, 0, ((void *) (intptr_t)(f)))
-#define GET_WR_FLAVOR(aio) (int) ((intptr_t) nni_aio_get_prov_extra(aio, 0))
-
 struct nng_http_conn {
 	nng_stream *sock;
-	void *      ctx;
+	void       *ctx;
 	bool        closed;
 	nni_list    rdq; // high level http read requests
 	nni_list    wrq; // high level http write requests
@@ -61,11 +54,14 @@ struct nng_http_conn {
 
 	nni_mtx mtx;
 
-	uint8_t *rd_buf;
-	size_t   rd_get;
-	size_t   rd_put;
-	size_t   rd_bufsz;
-	bool     rd_buffered;
+	enum read_flavor rd_flavor;
+	uint8_t         *rd_buf;
+	size_t           rd_get;
+	size_t           rd_put;
+	size_t           rd_bufsz;
+	bool             rd_buffered;
+
+	enum write_flavor wr_flavor;
 };
 
 void
@@ -140,7 +136,7 @@ http_rd_buf(nni_http_conn *conn, nni_aio *aio)
 
 	rbuf += conn->rd_get;
 
-	switch (GET_RD_FLAVOR(aio)) {
+	switch (conn->rd_flavor) {
 	case HTTP_RD_RAW:
 		raw = true; // FALLTHROUGH
 	case HTTP_RD_FULL:
@@ -185,7 +181,7 @@ http_rd_buf(nni_http_conn *conn, nni_aio *aio)
 
 	case HTTP_RD_REQ:
 		rv = nni_http_req_parse(
-		    nni_aio_get_prov_extra(aio, 1), rbuf, cnt, &n);
+		    nni_aio_get_prov_data(aio), rbuf, cnt, &n);
 		conn->rd_get += n;
 		if (conn->rd_get == conn->rd_put) {
 			conn->rd_get = conn->rd_put = 0;
@@ -202,7 +198,7 @@ http_rd_buf(nni_http_conn *conn, nni_aio *aio)
 
 	case HTTP_RD_RES:
 		rv = nni_http_res_parse(
-		    nni_aio_get_prov_extra(aio, 1), rbuf, cnt, &n);
+		    nni_aio_get_prov_data(aio), rbuf, cnt, &n);
 		conn->rd_get += n;
 		if (conn->rd_get == conn->rd_put) {
 			conn->rd_get = conn->rd_put = 0;
@@ -219,7 +215,7 @@ http_rd_buf(nni_http_conn *conn, nni_aio *aio)
 
 	case HTTP_RD_CHUNK:
 		rv = nni_http_chunks_parse(
-		    nni_aio_get_prov_extra(aio, 1), rbuf, cnt, &n);
+		    nni_aio_get_prov_data(aio), rbuf, cnt, &n);
 		conn->rd_get += n;
 		if (conn->rd_get == conn->rd_put) {
 			conn->rd_get = conn->rd_put = 0;
@@ -278,12 +274,12 @@ static void
 http_rd_cb(void *arg)
 {
 	nni_http_conn *conn = arg;
-	nni_aio *      aio  = conn->rd_aio;
-	nni_aio *      uaio;
+	nni_aio       *aio  = conn->rd_aio;
+	nni_aio       *uaio;
 	size_t         cnt;
 	int            rv;
 	unsigned       niov;
-	nni_iov *      iov;
+	nni_iov       *iov;
 
 	nni_mtx_lock(&conn->mtx);
 
@@ -365,7 +361,7 @@ http_rd_cancel(nni_aio *aio, void *arg, int rv)
 }
 
 static void
-http_rd_submit(nni_http_conn *conn, nni_aio *aio)
+http_rd_submit(nni_http_conn *conn, nni_aio *aio, enum read_flavor flavor)
 {
 	int rv;
 
@@ -380,6 +376,7 @@ http_rd_submit(nni_http_conn *conn, nni_aio *aio)
 		nni_aio_finish_error(aio, rv);
 		return;
 	}
+	conn->rd_flavor = flavor;
 	nni_list_append(&conn->rdq, aio);
 	if (conn->rd_uaio == NULL) {
 		http_rd_start(conn);
@@ -411,8 +408,8 @@ static void
 http_wr_cb(void *arg)
 {
 	nni_http_conn *conn = arg;
-	nni_aio *      aio  = conn->wr_aio;
-	nni_aio *      uaio;
+	nni_aio       *aio  = conn->wr_aio;
+	nni_aio       *uaio;
 	int            rv;
 	size_t         n;
 
@@ -442,7 +439,7 @@ http_wr_cb(void *arg)
 	n = nni_aio_count(aio);
 	nni_aio_bump_count(uaio, n);
 
-	if (GET_WR_FLAVOR(uaio) == HTTP_WR_RAW) {
+	if (conn->wr_flavor == HTTP_WR_RAW) {
 		// For raw data, we just send partial completion
 		// notices to the consumer.
 		goto done;
@@ -484,7 +481,7 @@ http_wr_cancel(nni_aio *aio, void *arg, int rv)
 }
 
 static void
-http_wr_submit(nni_http_conn *conn, nni_aio *aio)
+http_wr_submit(nni_http_conn *conn, nni_aio *aio, enum write_flavor flavor)
 {
 	int rv;
 
@@ -499,6 +496,7 @@ http_wr_submit(nni_http_conn *conn, nni_aio *aio)
 		nni_aio_finish_error(aio, rv);
 		return;
 	}
+	conn->wr_flavor = flavor;
 	nni_list_append(&conn->wrq, aio);
 
 	if (conn->wr_uaio == NULL) {
@@ -509,55 +507,50 @@ http_wr_submit(nni_http_conn *conn, nni_aio *aio)
 void
 nni_http_read_req(nni_http_conn *conn, nni_http_req *req, nni_aio *aio)
 {
-	SET_RD_FLAVOR(aio, HTTP_RD_REQ);
-	nni_aio_set_prov_extra(aio, 1, req);
+	nni_aio_set_prov_data(aio, req);
 
 	nni_mtx_lock(&conn->mtx);
-	http_rd_submit(conn, aio);
+	http_rd_submit(conn, aio, HTTP_RD_REQ);
 	nni_mtx_unlock(&conn->mtx);
 }
 
 void
 nni_http_read_res(nni_http_conn *conn, nni_http_res *res, nni_aio *aio)
 {
-	SET_RD_FLAVOR(aio, HTTP_RD_RES);
-	nni_aio_set_prov_extra(aio, 1, res);
+	nni_aio_set_prov_data(aio, res);
 
 	nni_mtx_lock(&conn->mtx);
-	http_rd_submit(conn, aio);
+	http_rd_submit(conn, aio, HTTP_RD_RES);
 	nni_mtx_unlock(&conn->mtx);
 }
 
 void
 nni_http_read_chunks(nni_http_conn *conn, nni_http_chunks *cl, nni_aio *aio)
 {
-	SET_RD_FLAVOR(aio, HTTP_RD_CHUNK);
-	nni_aio_set_prov_extra(aio, 1, cl);
+	nni_aio_set_prov_data(aio, cl);
 
 	nni_mtx_lock(&conn->mtx);
-	http_rd_submit(conn, aio);
+	http_rd_submit(conn, aio, HTTP_RD_CHUNK);
 	nni_mtx_unlock(&conn->mtx);
 }
 
 void
 nni_http_read_full(nni_http_conn *conn, nni_aio *aio)
 {
-	SET_RD_FLAVOR(aio, HTTP_RD_FULL);
-	nni_aio_set_prov_extra(aio, 1, NULL);
+	nni_aio_set_prov_data(aio, NULL);
 
 	nni_mtx_lock(&conn->mtx);
-	http_rd_submit(conn, aio);
+	http_rd_submit(conn, aio, HTTP_RD_FULL);
 	nni_mtx_unlock(&conn->mtx);
 }
 
 void
 nni_http_read(nni_http_conn *conn, nni_aio *aio)
 {
-	SET_RD_FLAVOR(aio, HTTP_RD_RAW);
-	nni_aio_set_prov_extra(aio, 1, NULL);
+	nni_aio_set_prov_data(aio, NULL);
 
 	nni_mtx_lock(&conn->mtx);
-	http_rd_submit(conn, aio);
+	http_rd_submit(conn, aio, HTTP_RD_RAW);
 	nni_mtx_unlock(&conn->mtx);
 }
 
@@ -565,9 +558,9 @@ void
 nni_http_write_req(nni_http_conn *conn, nni_http_req *req, nni_aio *aio)
 {
 	int     rv;
-	void *  buf;
+	void   *buf;
 	size_t  bufsz;
-	void *  data;
+	void   *data;
 	size_t  size;
 	nni_iov iov[2];
 	int     niov;
@@ -587,10 +580,8 @@ nni_http_write_req(nni_http_conn *conn, nni_http_req *req, nni_aio *aio)
 	}
 	nni_aio_set_iov(aio, niov, iov);
 
-	SET_WR_FLAVOR(aio, HTTP_WR_REQ);
-
 	nni_mtx_lock(&conn->mtx);
-	http_wr_submit(conn, aio);
+	http_wr_submit(conn, aio, HTTP_WR_REQ);
 	nni_mtx_unlock(&conn->mtx);
 }
 
@@ -598,9 +589,9 @@ void
 nni_http_write_res(nni_http_conn *conn, nni_http_res *res, nni_aio *aio)
 {
 	int     rv;
-	void *  buf;
+	void   *buf;
 	size_t  bufsz;
-	void *  data;
+	void   *data;
 	size_t  size;
 	nni_iov iov[2];
 	int     nio;
@@ -620,30 +611,24 @@ nni_http_write_res(nni_http_conn *conn, nni_http_res *res, nni_aio *aio)
 	}
 	nni_aio_set_iov(aio, nio, iov);
 
-	SET_WR_FLAVOR(aio, HTTP_WR_RES);
-
 	nni_mtx_lock(&conn->mtx);
-	http_wr_submit(conn, aio);
+	http_wr_submit(conn, aio, HTTP_WR_RES);
 	nni_mtx_unlock(&conn->mtx);
 }
 
 void
 nni_http_write(nni_http_conn *conn, nni_aio *aio)
 {
-	SET_WR_FLAVOR(aio, HTTP_WR_RAW);
-
 	nni_mtx_lock(&conn->mtx);
-	http_wr_submit(conn, aio);
+	http_wr_submit(conn, aio, HTTP_WR_RAW);
 	nni_mtx_unlock(&conn->mtx);
 }
 
 void
 nni_http_write_full(nni_http_conn *conn, nni_aio *aio)
 {
-	SET_WR_FLAVOR(aio, HTTP_WR_FULL);
-
 	nni_mtx_lock(&conn->mtx);
-	http_wr_submit(conn, aio);
+	http_wr_submit(conn, aio, HTTP_WR_FULL);
 	nni_mtx_unlock(&conn->mtx);
 }
 
diff --git a/src/supplemental/http/http_server.c b/src/supplemental/http/http_server.c
index 7f6f9ab..59863d2 100644
--- a/src/supplemental/http/http_server.c
+++ b/src/supplemental/http/http_server.c
@@ -22,15 +22,6 @@
 
 #include "http_api.h"
 
-static int  http_server_sys_init(void);
-static void http_server_sys_fini(void);
-
-static nni_initializer http_server_initializer = {
-	.i_init = http_server_sys_init,
-	.i_fini = http_server_sys_fini,
-	.i_once = 0,
-};
-
 struct nng_http_handler {
 	nni_list_node   node;
 	char *          uri;
@@ -279,8 +270,9 @@ nni_http_handler_set_method(nni_http_handler *h, const char *method)
 	return (0);
 }
 
-static nni_list http_servers;
-static nni_mtx  http_servers_lk;
+static nni_list http_servers =
+    NNI_LIST_INITIALIZER(http_servers, nni_http_server, node);
+static nni_mtx  http_servers_lk = NNI_MTX_INITIALIZER;
 
 static void
 http_sc_reap(void *arg)
@@ -463,10 +455,11 @@ http_uri_canonify(char *path)
 			c += http_hexval(tmp[2]);
 			*dst++ = c;
 			tmp += 3;
+		} else {
+			// garbage in, garbage out
+			*dst++ = c;
+			tmp++;
 		}
-		// garbage in, garbage out
-		*dst++ = c;
-		tmp++;
 	}
 	*dst = '\0';
 
@@ -1001,8 +994,6 @@ nni_http_server_init(nni_http_server **serverp, const nni_url *url)
 	int              rv;
 	nni_http_server *s;
 
-	nni_initialize(&http_server_initializer);
-
 	nni_mtx_lock(&http_servers_lk);
 	NNI_LIST_FOREACH (&http_servers, s) {
 		if ((!s->closed) && (atoi(url->u_port) == s->port) &&
@@ -1924,18 +1915,3 @@ nni_http_server_fini(nni_http_server *s)
 	}
 	nni_mtx_unlock(&http_servers_lk);
 }
-
-static int
-http_server_sys_init(void)
-{
-	NNI_LIST_INIT(&http_servers, nni_http_server, node);
-	nni_mtx_init(&http_servers_lk);
-	return (0);
-}
-
-static void
-http_server_sys_fini(void)
-{
-	nni_reap_drain();
-	nni_mtx_fini(&http_servers_lk);
-}
diff --git a/src/supplemental/tls/tls_common.c b/src/supplemental/tls/tls_common.c
index 404a8cf..357c841 100644
--- a/src/supplemental/tls/tls_common.c
+++ b/src/supplemental/tls/tls_common.c
@@ -1,5 +1,5 @@
 //
-// Copyright 2020 Staysail Systems, Inc. <info@staysail.tech>
+// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
 // Copyright 2018 Capitar IT Group BV <info@capitar.com>
 // Copyright 2019 Devolutions <info@devolutions.net>
 //
@@ -39,8 +39,7 @@
 
 #ifdef NNG_SUPP_TLS
 
-static const nng_tls_engine *tls_engine;
-static nni_mtx               tls_engine_lock;
+static nni_atomic_ptr tls_engine;
 
 struct nng_tls_config {
 	nng_tls_engine_config_ops ops;
@@ -1366,9 +1365,7 @@ nng_tls_config_alloc(nng_tls_config **cfg_p, nng_tls_mode mode)
 		return (rv);
 	}
 
-	nni_mtx_lock(&tls_engine_lock);
-	eng = tls_engine;
-	nni_mtx_unlock(&tls_engine_lock);
+	eng = nni_atomic_get_ptr(&tls_engine);
 
 	if (eng == NULL) {
 		return (NNG_ENOTSUP);
@@ -1424,9 +1421,8 @@ nng_tls_engine_name(void)
 	const nng_tls_engine *eng;
 
 	nni_init();
-	nni_mtx_lock(&tls_engine_lock);
-	eng = tls_engine;
-	nni_mtx_unlock(&tls_engine_lock);
+
+	eng = nni_atomic_get_ptr(&tls_engine);
 
 	return (eng == NULL ? "none" : eng->name);
 }
@@ -1437,9 +1433,8 @@ nng_tls_engine_description(void)
 	const nng_tls_engine *eng;
 
 	nni_init();
-	nni_mtx_lock(&tls_engine_lock);
-	eng = tls_engine;
-	nni_mtx_unlock(&tls_engine_lock);
+
+	eng = nni_atomic_get_ptr(&tls_engine);
 
 	return (eng == NULL ? "" : eng->description);
 }
@@ -1450,9 +1445,8 @@ nng_tls_engine_fips_mode(void)
 	const nng_tls_engine *eng;
 
 	nni_init();
-	nni_mtx_lock(&tls_engine_lock);
-	eng = tls_engine;
-	nni_mtx_unlock(&tls_engine_lock);
+
+	eng = nni_atomic_get_ptr(&tls_engine);
 
 	return (eng == NULL ? false : eng->fips_mode);
 }
@@ -1463,9 +1457,7 @@ nng_tls_engine_register(const nng_tls_engine *engine)
 	if (engine->version != NNG_TLS_ENGINE_VERSION) {
 		return (NNG_ENOTSUP);
 	}
-	nni_mtx_lock(&tls_engine_lock);
-	tls_engine = engine;
-	nni_mtx_unlock(&tls_engine_lock);
+	nni_atomic_set_ptr(&tls_engine, (void *)engine);
 	return (0);
 }
 
@@ -1492,12 +1484,9 @@ int
 nni_tls_sys_init(void)
 {
 	int rv;
-	nni_mtx_init(&tls_engine_lock);
-	tls_engine = NULL;
 
 	rv = NNG_TLS_ENGINE_INIT();
 	if (rv != 0) {
-		nni_mtx_fini(&tls_engine_lock);
 		return (rv);
 	}
 	return (0);
@@ -1506,7 +1495,6 @@ nni_tls_sys_init(void)
 void
 nni_tls_sys_fini(void)
 {
-	nni_reap_drain();
 	NNG_TLS_ENGINE_FINI();
 }
 
diff --git a/src/supplemental/websocket/websocket.c b/src/supplemental/websocket/websocket.c
index 416d968..d1c9c8d 100644
--- a/src/supplemental/websocket/websocket.c
+++ b/src/supplemental/websocket/websocket.c
@@ -714,7 +714,7 @@ ws_write_cancel(nni_aio *aio, void *arg, int rv)
 		nni_mtx_unlock(&ws->mtx);
 		return;
 	}
-	frame = nni_aio_get_prov_extra(aio, 0);
+	frame = nni_aio_get_prov_data(aio);
 	if (frame == ws->txframe) {
 		nni_aio_abort(ws->txaio, rv);
 		// We will wait for callback on the txaio to finish aio.
@@ -2739,7 +2739,7 @@ ws_str_send(void *arg, nni_aio *aio)
 		ws_frame_fini(frame);
 		return;
 	}
-	nni_aio_set_prov_extra(aio, 0, frame);
+	nni_aio_set_prov_data(aio, frame);
 	nni_list_append(&ws->sendq, aio);
 	nni_list_append(&ws->txq, frame);
 	ws_start_write(ws);
diff --git a/src/supplemental/websocket/websocket_test.c b/src/supplemental/websocket/websocket_test.c
index 9ea6801..be4e1b3 100644
--- a/src/supplemental/websocket/websocket_test.c
+++ b/src/supplemental/websocket/websocket_test.c
@@ -17,17 +17,17 @@
 void
 test_websocket_wildcard(void)
 {
-	nng_stream_dialer *  d = NULL;
+	nng_stream_dialer   *d = NULL;
 	nng_stream_listener *l = NULL;
 	nng_sockaddr         sa1;
 	nng_sockaddr         sa2;
 	size_t               sz;
-	nng_aio *            daio = NULL;
-	nng_aio *            laio = NULL;
-	nng_aio *            aio1 = NULL;
-	nng_aio *            aio2 = NULL;
-	nng_stream *         c1   = NULL;
-	nng_stream *         c2   = NULL;
+	nng_aio             *daio = NULL;
+	nng_aio             *laio = NULL;
+	nng_aio             *aio1 = NULL;
+	nng_aio             *aio2 = NULL;
+	nng_stream          *c1   = NULL;
+	nng_stream          *c2   = NULL;
 	nng_iov              iov;
 	char                 buf1[8];
 	char                 buf2[8];
@@ -125,18 +125,18 @@ test_websocket_wildcard(void)
 void
 test_websocket_conn_props(void)
 {
-	nng_stream_dialer *  d = NULL;
+	nng_stream_dialer   *d = NULL;
 	nng_stream_listener *l = NULL;
 	nng_sockaddr         sa1;
 	nng_sockaddr         sa2;
 	size_t               sz;
-	nng_aio *            daio = NULL;
-	nng_aio *            laio = NULL;
-	nng_stream *         c1   = NULL;
-	nng_stream *         c2   = NULL;
+	nng_aio             *daio = NULL;
+	nng_aio             *laio = NULL;
+	nng_stream          *c1   = NULL;
+	nng_stream          *c2   = NULL;
 	char                 uri[64];
 	bool                 on;
-	char *               str;
+	char                *str;
 	uint16_t             port = nuts_next_port();
 
 	(void) snprintf(uri, sizeof(uri), "ws://127.0.0.1:%d/test", port);
@@ -219,14 +219,14 @@ test_websocket_conn_props(void)
 void
 test_websocket_text_mode(void)
 {
-	nng_stream_dialer *  d    = NULL;
+	nng_stream_dialer   *d    = NULL;
 	nng_stream_listener *l    = NULL;
-	nng_aio *            daio = NULL;
-	nng_aio *            laio = NULL;
-	nng_aio *            aio1 = NULL;
-	nng_aio *            aio2 = NULL;
-	nng_stream *         c1   = NULL;
-	nng_stream *         c2   = NULL;
+	nng_aio             *daio = NULL;
+	nng_aio             *laio = NULL;
+	nng_aio             *aio1 = NULL;
+	nng_aio             *aio2 = NULL;
+	nng_stream          *c1   = NULL;
+	nng_stream          *c2   = NULL;
 	char                 uri[64];
 	char                 txb[5];
 	char                 rxb[5];
@@ -342,16 +342,16 @@ test_websocket_text_mode(void)
 }
 
 typedef struct recv_state {
-	nng_stream * c;
+	nng_stream  *c;
 	int          total;
 	int          xfr;
-	nng_mtx *    lock;
-	nng_cv *     cv;
-	nng_aio *    aio;
+	nng_mtx     *lock;
+	nng_cv      *cv;
+	nng_aio     *aio;
 	int          err;
 	bool         done;
-	uint8_t *    send_buf;
-	uint8_t *    buf;
+	uint8_t     *send_buf;
+	uint8_t     *buf;
 	nni_sha1_ctx sum;
 } recv_state;
 
@@ -393,20 +393,20 @@ void
 test_websocket_fragmentation(void)
 {
 	nng_stream_listener *l = NULL;
-	nng_stream_dialer *  d = NULL;
-	nng_stream *         c = NULL;
+	nng_stream_dialer   *d = NULL;
+	nng_stream          *c = NULL;
 	uint16_t             port;
 	char                 url[64];
-	nng_aio *            daio = NULL;
-	nng_aio *            laio = NULL;
-	nng_aio *            caio = NULL;
+	nng_aio             *daio = NULL;
+	nng_aio             *laio = NULL;
+	nng_aio             *caio = NULL;
 	int                  resid;
 	recv_state           state;
 	uint8_t              sum1[20];
 	uint8_t              sum2[20];
-	uint8_t *            recv_buf;
-	uint8_t *            send_buf;
-	uint8_t *            buf;
+	uint8_t             *recv_buf;
+	uint8_t             *send_buf;
+	uint8_t             *buf;
 	nng_iov              iov;
 
 	memset(&state, 0, sizeof(state));
@@ -475,7 +475,7 @@ test_websocket_fragmentation(void)
 		nng_aio_wait(caio);
 		NUTS_PASS(nng_aio_result(caio));
 		NUTS_TRUE(nng_aio_count(caio) > 0);
-		len = nng_aio_count(caio);
+		len = (int) nng_aio_count(caio);
 
 		resid -= len;
 		buf += len;
diff --git a/src/testing/marry.c b/src/testing/marry.c
index be109b7..cfaec6c 100644
--- a/src/testing/marry.c
+++ b/src/testing/marry.c
@@ -281,6 +281,10 @@ nuts_marry_ex(
 		replace_port_zero(url, addr, port);
 		url = addr;
 	}
+	if (((rv = nng_socket_set_ms(s2, NNG_OPT_RECONNMINT, 10)) != 0) ||
+	    ((rv = nng_socket_set_ms(s2, NNG_OPT_RECONNMAXT, 10)) != 0)) {
+		goto done;
+	}
 	if ((rv = nng_dial(s2, url, NULL, 0)) != 0) {
 		goto done;
 	}
diff --git a/src/tools/nngcat/nngcat_ambiguous_test.sh b/src/tools/nngcat/nngcat_ambiguous_test.sh
index 414b6d1..944d5ae 100755
--- a/src/tools/nngcat/nngcat_ambiguous_test.sh
+++ b/src/tools/nngcat/nngcat_ambiguous_test.sh
@@ -1,4 +1,4 @@
-#!/bin/bash
+#!/usr/bin/env bash
 
 #
 # Copyright 2018 Staysail Systems, Inc. <info@staysail.tech>
diff --git a/src/tools/nngcat/nngcat_async_test.sh b/src/tools/nngcat/nngcat_async_test.sh
index 2b03e52..aeec3de 100755
--- a/src/tools/nngcat/nngcat_async_test.sh
+++ b/src/tools/nngcat/nngcat_async_test.sh
@@ -1,4 +1,4 @@
-#!/bin/bash
+#!/usr/bin/env bash
 
 #
 # Copyright 2018 Staysail Systems, Inc. <info@staysail.tech>
diff --git a/src/tools/nngcat/nngcat_dup_proto_test.sh b/src/tools/nngcat/nngcat_dup_proto_test.sh
index 1513d01..a55b7f3 100755
--- a/src/tools/nngcat/nngcat_dup_proto_test.sh
+++ b/src/tools/nngcat/nngcat_dup_proto_test.sh
@@ -1,4 +1,4 @@
-#!/bin/bash
+#!/usr/bin/env bash
 
 #
 # Copyright 2018 Staysail Systems, Inc. <info@staysail.tech>
diff --git a/src/tools/nngcat/nngcat_help_test.sh b/src/tools/nngcat/nngcat_help_test.sh
index 95ed9e3..77b7503 100755
--- a/src/tools/nngcat/nngcat_help_test.sh
+++ b/src/tools/nngcat/nngcat_help_test.sh
@@ -1,4 +1,4 @@
-#!/bin/bash
+#!/usr/bin/env bash
 
 #
 # Copyright 2018 Staysail Systems, Inc. <info@staysail.tech>
diff --git a/src/tools/nngcat/nngcat_incompat_test.sh b/src/tools/nngcat/nngcat_incompat_test.sh
index 128b57b..93b7548 100755
--- a/src/tools/nngcat/nngcat_incompat_test.sh
+++ b/src/tools/nngcat/nngcat_incompat_test.sh
@@ -1,4 +1,4 @@
-#!/bin/sh
+#!/usr/bin/env bash
 
 #
 # Copyright 2018 Staysail Systems, Inc. <info@staysail.tech>
diff --git a/src/tools/nngcat/nngcat_pubsub_test.sh b/src/tools/nngcat/nngcat_pubsub_test.sh
index b9ba90e..52d35a9 100755
--- a/src/tools/nngcat/nngcat_pubsub_test.sh
+++ b/src/tools/nngcat/nngcat_pubsub_test.sh
@@ -1,4 +1,4 @@
-#!/bin/bash
+#!/usr/bin/env bash
 
 #
 # Copyright 2018 Staysail Systems, Inc. <info@staysail.tech>
diff --git a/src/tools/nngcat/nngcat_recvmaxsz_test.sh b/src/tools/nngcat/nngcat_recvmaxsz_test.sh
index b5d4ff4..a41a02c 100755
--- a/src/tools/nngcat/nngcat_recvmaxsz_test.sh
+++ b/src/tools/nngcat/nngcat_recvmaxsz_test.sh
@@ -1,4 +1,4 @@
-#!/bin/bash
+#!/usr/bin/env bash
 
 #
 # Copyright 2018 Staysail Systems, Inc. <info@staysail.tech>
diff --git a/src/tools/nngcat/nngcat_stdin_pipe_test.sh b/src/tools/nngcat/nngcat_stdin_pipe_test.sh
index 5fec0ab..824107e 100755
--- a/src/tools/nngcat/nngcat_stdin_pipe_test.sh
+++ b/src/tools/nngcat/nngcat_stdin_pipe_test.sh
@@ -1,4 +1,4 @@
-#!/bin/bash
+#!/usr/bin/env bash
 
 #
 # Copyright 2018 Staysail Systems, Inc. <info@staysail.tech>
diff --git a/src/tools/nngcat/nngcat_unlimited_test.sh b/src/tools/nngcat/nngcat_unlimited_test.sh
index 0486b9b..88a1e30 100755
--- a/src/tools/nngcat/nngcat_unlimited_test.sh
+++ b/src/tools/nngcat/nngcat_unlimited_test.sh
@@ -1,4 +1,4 @@
-#!/bin/bash
+#!/usr/bin/env bash
 
 #
 # Copyright 2018 Staysail Systems, Inc. <info@staysail.tech>
diff --git a/src/tools/perf/perf.c b/src/tools/perf/perf.c
index accac62..46d91cd 100644
--- a/src/tools/perf/perf.c
+++ b/src/tools/perf/perf.c
@@ -45,6 +45,10 @@ static open_func open_client = no_open;
 #define nng_pair0_open no_open
 #endif
 
+#if !defined(NNG_HAVE_PAIR0) && !defined(NNG_HAVE_PAIR1)
+#define nng_pair_open no_open
+#endif
+
 #if defined(NNG_HAVE_REQ0)
 #include <nng/protocol/reqrep0/req.h>
 #else
diff --git a/src/tools/perf/pubdrop.c b/src/tools/perf/pubdrop.c
index 41ac5ba..f7e1dbf 100644
--- a/src/tools/perf/pubdrop.c
+++ b/src/tools/perf/pubdrop.c
@@ -27,6 +27,8 @@
 
 #else
 
+#define NNG_OPT_SUB_SUBSCRIBE "sub:subscribe"
+
 static void die(const char *, ...);
 
 static int
diff --git a/tests/CMakeLists.txt b/tests/CMakeLists.txt
index c0c2e19..5adb0c8 100644
--- a/tests/CMakeLists.txt
+++ b/tests/CMakeLists.txt
@@ -131,14 +131,12 @@ add_nng_test1(httpserver 30 NNG_SUPP_HTTP)
 add_nng_test(inproc 5)
 add_nng_test(ipc 5)
 add_nng_test(ipcsupp 10)
-add_nng_test(ipcwinsec 5)
 add_nng_test(multistress 60)
 add_nng_test(nonblock 60)
 add_nng_test(options 5)
 add_nng_test(pipe 5)
 add_nng_test(pollfd 5)
 add_nng_test(scalability 20 ON)
-add_nng_test1(stats 5 NNG_ENABLE_STATS)
 add_nng_test(synch 5)
 add_nng_test(tls 60)
 add_nng_test(tcpsupp 10)
@@ -149,7 +147,6 @@ add_nng_test(ws 30)
 add_nng_test(wss 30)
 add_nng_test1(zt 60 NNG_TRANSPORT_ZEROTIER)
 
-add_nng_test(bus 5)
 add_nng_test(reqctx 5)
 add_nng_test(reqstress 60)
 
diff --git a/tests/bus.c b/tests/bus.c
deleted file mode 100644
index ccd4816..0000000
--- a/tests/bus.c
+++ /dev/null
@@ -1,90 +0,0 @@
-//
-// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
-// Copyright 2018 Capitar IT Group BV <info@capitar.com>
-//
-// This software is supplied under the terms of the MIT License, a
-// copy of which should be located in the distribution where this
-// file was obtained (LICENSE.txt).  A copy of the license may also be
-// found online at https://opensource.org/licenses/MIT.
-//
-
-#include <string.h>
-
-#include <nng/nng.h>
-#include <nng/protocol/bus0/bus.h>
-
-#include "convey.h"
-#include "stubs.h"
-
-#define APPENDSTR(m, s) nng_msg_append(m, s, strlen(s))
-#define CHECKSTR(m, s)                   \
-	So(nng_msg_len(m) == strlen(s)); \
-	So(memcmp(nng_msg_body(m), s, strlen(s)) == 0)
-
-TestMain("BUS pattern", {
-	const char *addr = "inproc://test";
-
-	Convey("We can create a BUS socket", {
-		nng_socket bus;
-
-		So(nng_bus_open(&bus) == 0);
-
-		Reset({ nng_close(bus); });
-	});
-
-	Convey("We can create a linked BUS topology", {
-		nng_socket   bus1;
-		nng_socket   bus2;
-		nng_socket   bus3;
-		nng_duration rtimeo;
-
-		So(nng_bus_open(&bus1) == 0);
-		So(nng_bus_open(&bus2) == 0);
-		So(nng_bus_open(&bus3) == 0);
-
-		Reset({
-			nng_close(bus1);
-			nng_close(bus2);
-			nng_close(bus3);
-		});
-
-		So(nng_listen(bus1, addr, NULL, 0) == 0);
-		So(nng_dial(bus2, addr, NULL, 0) == 0);
-		So(nng_dial(bus3, addr, NULL, 0) == 0);
-
-		rtimeo = 50;
-		So(nng_setopt_ms(bus1, NNG_OPT_RECVTIMEO, rtimeo) == 0);
-		So(nng_setopt_ms(bus2, NNG_OPT_RECVTIMEO, rtimeo) == 0);
-		So(nng_setopt_ms(bus3, NNG_OPT_RECVTIMEO, rtimeo) == 0);
-
-		Convey("Messages delivered", {
-			nng_msg *msg;
-
-			// This is just a poor man's sleep.
-			So(nng_recvmsg(bus1, &msg, 0) == NNG_ETIMEDOUT);
-			So(nng_recvmsg(bus2, &msg, 0) == NNG_ETIMEDOUT);
-			So(nng_recvmsg(bus3, &msg, 0) == NNG_ETIMEDOUT);
-
-			So(nng_msg_alloc(&msg, 0) == 0);
-			APPENDSTR(msg, "99bits");
-			So(nng_sendmsg(bus2, msg, 0) == 0);
-
-			So(nng_recvmsg(bus1, &msg, 0) == 0);
-			CHECKSTR(msg, "99bits");
-			nng_msg_free(msg);
-			So(nng_recvmsg(bus3, &msg, 0) == NNG_ETIMEDOUT);
-
-			So(nng_msg_alloc(&msg, 0) == 0);
-			APPENDSTR(msg, "onthe");
-			So(nng_sendmsg(bus1, msg, 0) == 0);
-
-			So(nng_recvmsg(bus2, &msg, 0) == 0);
-			CHECKSTR(msg, "onthe");
-			nng_msg_free(msg);
-
-			So(nng_recvmsg(bus3, &msg, 0) == 0);
-			CHECKSTR(msg, "onthe");
-			nng_msg_free(msg);
-		});
-	});
-})
diff --git a/tests/device.c b/tests/device.c
index 7d10cbf..77da41b 100644
--- a/tests/device.c
+++ b/tests/device.c
@@ -82,8 +82,8 @@ Main({
 			So(nng_dial(end2, addr2, NULL, 0) == 0);
 
 			tmo = SECOND(1);
-			So(nng_setopt_ms(end1, NNG_OPT_RECVTIMEO, tmo) == 0);
-			So(nng_setopt_ms(end2, NNG_OPT_RECVTIMEO, tmo) == 0);
+			So(nng_socket_set_ms(end1, NNG_OPT_RECVTIMEO, tmo) == 0);
+			So(nng_socket_set_ms(end2, NNG_OPT_RECVTIMEO, tmo) == 0);
 
 			nng_msleep(100);
 			Convey("Device can send and receive", {
diff --git a/tests/httpserver.c b/tests/httpserver.c
index 445aad0..f7a28b5 100644
--- a/tests/httpserver.c
+++ b/tests/httpserver.c
@@ -25,7 +25,7 @@
 #include "convey.h"
 #include "core/nng_impl.h"
 
-const char *doc1 = "<html><body>Someone <b>is</b> home!</body</html>";
+const char *doc1 = "<html><body>Someone <b>is</b> home!</body></html>";
 const char *doc2 = "This is a text file.";
 const char *doc3 = "<html><body>This is doc number 3.</body></html>";
 const char *doc4 = "<html><body>Whoops, Errored!</body></html>";
diff --git a/tests/ipc.c b/tests/ipc.c
index d910e0a..4f5de38 100644
--- a/tests/ipc.c
+++ b/tests/ipc.c
@@ -36,47 +36,47 @@ check_props(nng_msg *msg)
 
 	p = nng_msg_get_pipe(msg);
 	So(nng_pipe_id(p) > 0);
-	So(nng_pipe_getopt_sockaddr(p, NNG_OPT_LOCADDR, &la) == 0);
+	So(nng_pipe_get_addr(p, NNG_OPT_LOCADDR, &la) == 0);
 	So(la.s_family == NNG_AF_IPC);
 	// untyped
 	z = sizeof(nng_sockaddr);
-	So(nng_pipe_getopt(p, NNG_OPT_REMADDR, &ra, &z) == 0);
+	So(nng_pipe_get(p, NNG_OPT_REMADDR, &ra, &z) == 0);
 	So(z == sizeof(ra));
 	So(ra.s_family == NNG_AF_IPC);
 
-	So(nng_pipe_getopt_size(p, NNG_OPT_REMADDR, &z) == NNG_EBADTYPE);
+	So(nng_pipe_get_size(p, NNG_OPT_REMADDR, &z) == NNG_EBADTYPE);
 	z = 1;
-	So(nng_pipe_getopt(p, NNG_OPT_REMADDR, &ra, &z) == NNG_EINVAL);
+	So(nng_pipe_get(p, NNG_OPT_REMADDR, &ra, &z) == NNG_EINVAL);
 
 #ifdef _WIN32
-	So(nng_pipe_getopt_uint64(p, NNG_OPT_IPC_PEER_UID, &id) ==
+	So(nng_pipe_get_uint64(p, NNG_OPT_IPC_PEER_UID, &id) ==
 	    NNG_ENOTSUP);
-	So(nng_pipe_getopt_uint64(p, NNG_OPT_IPC_PEER_GID, &id) ==
+	So(nng_pipe_get_uint64(p, NNG_OPT_IPC_PEER_GID, &id) ==
 	    NNG_ENOTSUP);
-	So(nng_pipe_getopt_uint64(p, NNG_OPT_IPC_PEER_ZONEID, &id) ==
+	So(nng_pipe_get_uint64(p, NNG_OPT_IPC_PEER_ZONEID, &id) ==
 	    NNG_ENOTSUP);
-	So(nng_pipe_getopt_uint64(p, NNG_OPT_IPC_PEER_PID, &id) == 0);
+	So(nng_pipe_get_uint64(p, NNG_OPT_IPC_PEER_PID, &id) == 0);
 	So(id == GetCurrentProcessId());
 #else
-	So(nng_pipe_getopt_uint64(p, NNG_OPT_IPC_PEER_UID, &id) == 0);
+	So(nng_pipe_get_uint64(p, NNG_OPT_IPC_PEER_UID, &id) == 0);
 	So(id == (uint64_t) getuid());
-	So(nng_pipe_getopt_uint64(p, NNG_OPT_IPC_PEER_GID, &id) == 0);
+	So(nng_pipe_get_uint64(p, NNG_OPT_IPC_PEER_GID, &id) == 0);
 	So(id == (uint64_t) getgid());
 
 #if defined(NNG_HAVE_SOPEERCRED) || defined(NNG_HAVE_GETPEERUCRED) || \
     (defined(NNG_HAVE_LOCALPEERCRED) && defined(NNG_HAVE_LOCALPEERPID))
-	So(nng_pipe_getopt_uint64(p, NNG_OPT_IPC_PEER_PID, &id) == 0);
+	So(nng_pipe_get_uint64(p, NNG_OPT_IPC_PEER_PID, &id) == 0);
 	So(id == (uint64_t) getpid());
 #else
-	So(nng_pipe_getopt_uint64(p, NNG_OPT_IPC_PEER_PID, &id) ==
+	So(nng_pipe_get_uint64(p, NNG_OPT_IPC_PEER_PID, &id) ==
 	    NNG_ENOTSUP);
 #endif
 
 #ifdef NNG_HAVE_GETPEERUCRED
-	So(nng_pipe_getopt_uint64(p, NNG_OPT_IPC_PEER_ZONEID, &id) == 0);
+	So(nng_pipe_get_uint64(p, NNG_OPT_IPC_PEER_ZONEID, &id) == 0);
 	So(id == (uint64_t) getzoneid());
 #else
-	So(nng_pipe_getopt_uint64(p, NNG_OPT_IPC_PEER_ZONEID, &id) ==
+	So(nng_pipe_get_uint64(p, NNG_OPT_IPC_PEER_ZONEID, &id) ==
 	    NNG_ENOTSUP);
 #endif
 #endif
diff --git a/tests/ipcwinsec.c b/tests/ipcwinsec.c
deleted file mode 100644
index 533dfe3..0000000
--- a/tests/ipcwinsec.c
+++ /dev/null
@@ -1,192 +0,0 @@
-//
-// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
-// Copyright 2018 Capitar IT Group BV <info@capitar.com>
-//
-// This software is supplied under the terms of the MIT License, a
-// copy of which should be located in the distribution where this
-// file was obtained (LICENSE.txt).  A copy of the license may also be
-// found online at https://opensource.org/licenses/MIT.
-//
-
-#include <nng/nng.h>
-#include <nng/protocol/reqrep0/rep.h>
-#include <nng/protocol/reqrep0/req.h>
-#include <nng/transport/ipc/ipc.h>
-
-#include "convey.h"
-#include "stubs.h"
-#include "trantest.h"
-
-#define ADDR "/tmp/ipc_winsec_test"
-
-// Inproc tests.
-
-#ifndef _WIN32
-TestMain("IPC Security Descriptor", {
-	Convey("Given a socket and an IPC listener", {
-		nng_socket   s;
-		nng_listener l;
-		int          x;
-
-		So(nng_rep0_open(&s) == 0);
-		Reset({ nng_close(s); });
-		So(nng_listener_create(&l, s, "ipc://" ADDR) == 0);
-		Convey("We cannot set Windows SECURITY_DESCRIPTOR on POSIX", {
-			So(nng_listener_setopt_ptr(l,
-			       NNG_OPT_IPC_SECURITY_DESCRIPTOR,
-			       &x) == NNG_ENOTSUP);
-		});
-	});
-})
-#else
-
-#include <assert.h>
-
-// Microsoft prefers CamelCase header names, but relies on case insensitive
-// file systems to make that work.  The rest of the world (min-gw64 included)
-// uses case sensitive names and lowercase.
-
-#include <accctrl.h>
-
-#include <sddl.h>
-
-#include <aclapi.h>
-
-SECURITY_DESCRIPTOR *
-sdescAuthUsers(PSID sid, PACL *aclp)
-{
-	SECURITY_DESCRIPTOR *sdesc;
-	EXPLICIT_ACCESS      xa;
-	ACL *                acl;
-
-	sdesc = calloc(SECURITY_DESCRIPTOR_MIN_LENGTH, 1);
-	assert(sdesc != NULL);
-
-	InitializeSecurityDescriptor(sdesc, SECURITY_DESCRIPTOR_REVISION);
-
-	xa.grfAccessPermissions = GENERIC_READ | GENERIC_WRITE;
-	xa.grfAccessMode        = SET_ACCESS;
-	xa.grfInheritance       = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
-	xa.Trustee.TrusteeForm  = TRUSTEE_IS_SID;
-	xa.Trustee.TrusteeType  = TRUSTEE_IS_WELL_KNOWN_GROUP;
-	xa.Trustee.ptstrName    = (LPSTR) sid;
-
-	SetEntriesInAcl(1, &xa, NULL, &acl);
-	*aclp = acl;
-
-	SetSecurityDescriptorDacl(sdesc, TRUE, acl, FALSE);
-	return (sdesc);
-}
-
-TestMain("IPC Security Descriptor", {
-	Convey("Given a socket and an IPC listener", {
-		nng_socket   s;
-		nng_listener l;
-
-		So(nng_rep0_open(&s) == 0);
-		Reset({ nng_close(s); });
-
-		So(nng_listener_create(&l, s, "ipc://" ADDR) == 0);
-		Convey("We can set security descriptor on Windows", {
-			SECURITY_DESCRIPTOR *sdesc;
-			SID                  users;
-			DWORD                size;
-			PACL                 acl = NULL;
-
-			size = sizeof(users);
-			CreateWellKnownSid(
-			    WinAuthenticatedUserSid, NULL, &users, &size);
-
-			sdesc = sdescAuthUsers(&users, &acl);
-			assert(sdesc != NULL);
-			assert(acl != NULL);
-			Reset({
-				free(sdesc);
-				LocalFree(acl);
-			});
-
-			So(nng_listener_setopt_ptr(l,
-			       NNG_OPT_IPC_SECURITY_DESCRIPTOR, sdesc) == 0);
-			So(nng_listener_start(l, 0) == 0);
-
-			Convey("And they are effective", {
-				PACL                 dacl;
-				PSECURITY_DESCRIPTOR sd;
-				PACE_HEADER          ace;
-				PSID                 asid;
-				PACCESS_ALLOWED_ACE  allowed;
-
-				HANDLE ph = CreateFileA("\\\\.\\\\pipe\\" ADDR,
-				    READ_CONTROL, 0, NULL, OPEN_EXISTING,
-				    FILE_FLAG_OVERLAPPED, NULL);
-
-				So(ph != INVALID_HANDLE_VALUE);
-				Reset({ CloseHandle(ph); });
-
-				So(GetSecurityInfo(ph, SE_KERNEL_OBJECT,
-				       DACL_SECURITY_INFORMATION, NULL, NULL,
-				       &dacl, NULL, &sd) == ERROR_SUCCESS);
-				Reset({ LocalFree(sd); });
-
-				So(dacl->AceCount == 1);
-				So(GetAce(dacl, 0, (void **) &ace) == TRUE);
-				allowed = (PACCESS_ALLOWED_ACE) ace;
-				asid    = (PSID) &allowed->SidStart;
-				So(IsValidSid(asid));
-				So(EqualSid(asid, &users) == TRUE);
-			});
-		});
-
-		Convey("We cannot set security descriptor after started", {
-			SECURITY_DESCRIPTOR *sdesc;
-			SID                  users;
-			DWORD                size;
-			PACL                 acl = NULL;
-
-			size = sizeof(users);
-			CreateWellKnownSid(
-			    WinAuthenticatedUserSid, NULL, &users, &size);
-
-			sdesc = sdescAuthUsers(&users, &acl);
-			assert(sdesc != NULL);
-			assert(acl != NULL);
-			Reset({
-				free(sdesc);
-				LocalFree(acl);
-			});
-
-			So(nng_listener_start(l, 0) == 0);
-			So(nng_listener_setopt_ptr(l,
-			       NNG_OPT_IPC_SECURITY_DESCRIPTOR,
-			       sdesc) == NNG_EBUSY);
-		});
-
-		Convey("We cannot set bogus security", {
-			So(nng_listener_setopt_ptr(l,
-			       NNG_OPT_IPC_SECURITY_DESCRIPTOR,
-			       NULL) == NNG_EINVAL);
-		});
-	});
-
-	Convey("We cannot set security descriptor on an IPC dialer", {
-		nng_socket           s;
-		nng_dialer           d;
-		SECURITY_DESCRIPTOR *sdesc;
-
-		sdesc = calloc(SECURITY_DESCRIPTOR_MIN_LENGTH, 1);
-		assert(sdesc != NULL);
-		InitializeSecurityDescriptor(
-		    sdesc, SECURITY_DESCRIPTOR_REVISION);
-
-		So(nng_rep0_open(&s) == 0);
-		Reset({
-			nng_close(s);
-			free(sdesc);
-		});
-
-		So(nng_dialer_create(&d, s, "ipc://" ADDR) == 0);
-		So(nng_dialer_setopt_ptr(d, NNG_OPT_IPC_SECURITY_DESCRIPTOR,
-		       sdesc) == NNG_ENOTSUP);
-	});
-})
-#endif
diff --git a/tests/multistress.c b/tests/multistress.c
index fee4050..63feb66 100644
--- a/tests/multistress.c
+++ b/tests/multistress.c
@@ -585,7 +585,7 @@ pubsub0_test(int ntests)
 		if ((rv = nng_aio_alloc(&cli->recd, sub0_recd, cli)) != 0) {
 			fatal("nng_aio_alloc", rv);
 		}
-		rv = nng_setopt(cli->sock, NNG_OPT_SUB_SUBSCRIBE, "", 0);
+		rv = nng_socket_set(cli->sock, NNG_OPT_SUB_SUBSCRIBE, "", 0);
 		if (rv != 0) {
 			fatal("subscribe", rv);
 		}
diff --git a/tests/nonblock.c b/tests/nonblock.c
index 3ad2288..4fde2c8 100644
--- a/tests/nonblock.c
+++ b/tests/nonblock.c
@@ -36,7 +36,7 @@ repthr(void *arg)
 
 	nng_listen(rep, addr, &l, NNG_FLAG_NONBLOCK);
 
-	nng_getopt_int(rep, NNG_OPT_RECVFD, &ifd);
+	nng_socket_get_int(rep, NNG_OPT_RECVFD, &ifd);
 	fd = ifd;
 
 	for (;;) {
diff --git a/tests/pipe.c b/tests/pipe.c
index 617337b..c2d1f06 100644
--- a/tests/pipe.c
+++ b/tests/pipe.c
@@ -138,10 +138,10 @@ TestMain("Pipe notify works", {
 			nng_mtx_free(pull.lk);
 		});
 
-		So(nng_setopt_ms(push.s, NNG_OPT_RECONNMINT, 10) == 0);
-		So(nng_setopt_ms(push.s, NNG_OPT_RECONNMAXT, 10) == 0);
-		So(nng_setopt_ms(pull.s, NNG_OPT_RECONNMINT, 10) == 0);
-		So(nng_setopt_ms(pull.s, NNG_OPT_RECONNMAXT, 10) == 0);
+		So(nng_socket_set_ms(push.s, NNG_OPT_RECONNMINT, 10) == 0);
+		So(nng_socket_set_ms(push.s, NNG_OPT_RECONNMAXT, 10) == 0);
+		So(nng_socket_set_ms(pull.s, NNG_OPT_RECONNMINT, 10) == 0);
+		So(nng_socket_set_ms(pull.s, NNG_OPT_RECONNMAXT, 10) == 0);
 
 		So(nng_pipe_notify(
 		       push.s, NNG_PIPE_EV_ADD_PRE, notify, &push) == 0);
@@ -161,9 +161,9 @@ TestMain("Pipe notify works", {
 			So(nng_dialer_create(&push.d, push.s, addr) == 0);
 			So(nng_listener_id(pull.l) > 0);
 			So(nng_dialer_id(push.d) > 0);
-			So(nng_dialer_setopt_ms(
+			So(nng_dialer_set_ms(
 			       push.d, NNG_OPT_RECONNMINT, 10) == 0);
-			So(nng_dialer_setopt_ms(
+			So(nng_dialer_set_ms(
 			       push.d, NNG_OPT_RECONNMAXT, 10) == 0);
 			So(nng_listener_start(pull.l, 0) == 0);
 			So(nng_dialer_start(push.d, 0) == 0);
diff --git a/tests/pollfd.c b/tests/pollfd.c
index 2eca724..0c93c36 100644
--- a/tests/pollfd.c
+++ b/tests/pollfd.c
@@ -58,13 +58,13 @@ TestMain("Poll FDs", {
 			size_t sz;
 
 			sz = sizeof(fd);
-			So(nng_getopt(s1, NNG_OPT_RECVFD, &fd, &sz) == 0);
+			So(nng_socket_get(s1, NNG_OPT_RECVFD, &fd, &sz) == 0);
 			So(fd != (int) INVALID_SOCKET);
 
 			Convey("And it is always the same fd", {
 				int fd2;
 				sz = sizeof(fd2);
-				So(nng_getopt(s1, NNG_OPT_RECVFD, &fd2, &sz) ==
+				So(nng_socket_get(s1, NNG_OPT_RECVFD, &fd2, &sz) ==
 				    0);
 				So(fd2 == fd);
 			});
@@ -96,7 +96,7 @@ TestMain("Poll FDs", {
 			size_t sz;
 
 			sz = sizeof(fd);
-			So(nng_getopt(s1, NNG_OPT_SENDFD, &fd, &sz) == 0);
+			So(nng_socket_get(s1, NNG_OPT_SENDFD, &fd, &sz) == 0);
 			So(fd != (int) INVALID_SOCKET);
 			So(nng_send(s1, "oops", 4, 0) == 0);
 		});
@@ -105,10 +105,10 @@ TestMain("Poll FDs", {
 			int    fd;
 			size_t sz;
 			sz = 1;
-			So(nng_getopt(s1, NNG_OPT_RECVFD, &fd, &sz) ==
+			So(nng_socket_get(s1, NNG_OPT_RECVFD, &fd, &sz) ==
 			    NNG_EINVAL);
 			sz = 128;
-			So(nng_getopt(s1, NNG_OPT_RECVFD, &fd, &sz) == 0);
+			So(nng_socket_get(s1, NNG_OPT_RECVFD, &fd, &sz) == 0);
 			So(sz == sizeof(fd));
 		});
 	});
@@ -118,7 +118,7 @@ TestMain("Poll FDs", {
 		int        fd;
 		So(nng_pull0_open(&s3) == 0);
 		Reset({ nng_close(s3); });
-		So(nng_getopt_int(s3, NNG_OPT_SENDFD, &fd) == NNG_ENOTSUP);
+		So(nng_socket_get_int(s3, NNG_OPT_SENDFD, &fd) == NNG_ENOTSUP);
 	});
 
 	Convey("We cannot get a recv FD for PUSH", {
@@ -126,6 +126,6 @@ TestMain("Poll FDs", {
 		int        fd;
 		So(nng_push0_open(&s3) == 0);
 		Reset({ nng_close(s3); });
-		So(nng_getopt_int(s3, NNG_OPT_RECVFD, &fd) == NNG_ENOTSUP);
+		So(nng_socket_get_int(s3, NNG_OPT_RECVFD, &fd) == NNG_ENOTSUP);
 	});
 })
diff --git a/tests/reqctx.c b/tests/reqctx.c
index c727b91..e878037 100644
--- a/tests/reqctx.c
+++ b/tests/reqctx.c
@@ -117,7 +117,7 @@ TestMain("REQ concurrent contexts", {
 			nng_aio_set_timeout(saios[i], 5000);
 		}
 
-		So(nng_setopt_int(rep_state.s, NNG_OPT_SENDBUF, NCTX) == 0);
+		So(nng_socket_set_int(rep_state.s, NNG_OPT_SENDBUF, NCTX) == 0);
 		So(i == NCTX);
 		for (i = 0; i < NCTX; i++) {
 			uint32_t tmp;
diff --git a/tests/scalability.c b/tests/scalability.c
index 0cff224..17d6ce7 100644
--- a/tests/scalability.c
+++ b/tests/scalability.c
@@ -53,8 +53,8 @@ openclients(nng_socket *clients, int num)
 		t = 100; // 100ms
 		nng_socket c;
 		if (((rv = nng_req_open(&c)) != 0) ||
-		    ((rv = nng_setopt_ms(c, NNG_OPT_RECVTIMEO, t)) != 0) ||
-		    ((rv = nng_setopt_ms(c, NNG_OPT_SENDTIMEO, t)) != 0) ||
+		    ((rv = nng_socket_set_ms(c, NNG_OPT_RECVTIMEO, t)) != 0) ||
+		    ((rv = nng_socket_set_ms(c, NNG_OPT_SENDTIMEO, t)) != 0) ||
 		    ((rv = nng_dial(c, addr, NULL, 0)) != 0)) {
 			return (rv);
 		}
@@ -93,8 +93,8 @@ Main({
 	results = calloc(nclients, sizeof(int));
 
 	if ((nng_rep_open(&rep) != 0) ||
-	    (nng_setopt_int(rep, NNG_OPT_RECVBUF, 256) != 0) ||
-	    (nng_setopt_int(rep, NNG_OPT_SENDBUF, 256) != 0) ||
+	    (nng_socket_set_int(rep, NNG_OPT_RECVBUF, 256) != 0) ||
+	    (nng_socket_set_int(rep, NNG_OPT_SENDBUF, 256) != 0) ||
 	    (nng_listen(rep, addr, NULL, 0) != 0) ||
 	    (nng_thread_create(&server, serve, NULL) != 0)) {
 		fprintf(stderr, "Unable to set up server!\n");
diff --git a/tests/stats.c b/tests/stats.c
deleted file mode 100644
index fb73127..0000000
--- a/tests/stats.c
+++ /dev/null
@@ -1,74 +0,0 @@
-//
-// Copyright 2021 Staysail Systems, Inc. <info@staysail.tech>
-// Copyright 2018 Capitar IT Group BV <info@capitar.com>
-//
-// This software is supplied under the terms of the MIT License, a
-// copy of which should be located in the distribution where this
-// file was obtained (LICENSE.txt).  A copy of the license may also be
-// found online at https://opensource.org/licenses/MIT.
-//
-
-#include <string.h>
-
-#include <nng/nng.h>
-#include <nng/protocol/pair1/pair.h>
-#include <nng/protocol/pubsub0/sub.h>
-#include <nng/supplemental/util/platform.h>
-
-#include "convey.h"
-#include "stubs.h"
-#include "trantest.h"
-
-#define SECONDS(x) ((x) *1000)
-
-TestMain("Stats Test", {
-
-	Convey("We are able to open a PAIR socket", {
-		nng_socket s1;
-
-		So(nng_pair_open(&s1) == 0);
-
-		Reset({ nng_close(s1); });
-
-		Convey("We can send and receive messages", {
-			nng_socket   s2;
-			int          len;
-			size_t       sz;
-			nng_duration to = SECONDS(3);
-			char *       buf;
-			char *       a = "inproc://stats";
-			nng_stat *   stats;
-
-			So(nng_pair_open(&s2) == 0);
-			Reset({ nng_close(s2); });
-
-			So(nng_setopt_int(s1, NNG_OPT_RECVBUF, 1) == 0);
-			So(nng_getopt_int(s1, NNG_OPT_RECVBUF, &len) == 0);
-			So(len == 1);
-
-			So(nng_setopt_int(s1, NNG_OPT_SENDBUF, 1) == 0);
-			So(nng_setopt_int(s2, NNG_OPT_SENDBUF, 1) == 0);
-
-			So(nng_setopt_ms(s1, NNG_OPT_SENDTIMEO, to) == 0);
-			So(nng_setopt_ms(s1, NNG_OPT_RECVTIMEO, to) == 0);
-			So(nng_setopt_ms(s2, NNG_OPT_SENDTIMEO, to) == 0);
-			So(nng_setopt_ms(s2, NNG_OPT_RECVTIMEO, to) == 0);
-
-			So(nng_listen(s1, a, NULL, 0) == 0);
-			So(nng_dial(s2, a, NULL, 0) == 0);
-
-			So(nng_send(s1, "abc", 4, 0) == 0);
-			So(nng_recv(s2, &buf, &sz, NNG_FLAG_ALLOC) == 0);
-			So(buf != NULL);
-			So(sz == 4);
-			So(memcmp(buf, "abc", 4) == 0);
-			nng_free(buf, sz);
-
-			Convey("We can collect stats", {
-				So(nng_stats_get(&stats) == 0);
-				nng_stats_dump(stats);
-				nng_stats_free(stats);
-			});
-		});
-	});
-})
diff --git a/tests/tcp.c b/tests/tcp.c
index afc92f1..91b8586 100644
--- a/tests/tcp.c
+++ b/tests/tcp.c
@@ -33,7 +33,7 @@ check_props_v4(nng_msg *msg)
 
 	p = nng_msg_get_pipe(msg);
 	So(nng_pipe_id(p) > 0);
-	So(nng_pipe_getopt_sockaddr(p, NNG_OPT_LOCADDR, &la) == 0);
+	So(nng_pipe_get_addr(p, NNG_OPT_LOCADDR, &la) == 0);
 	So(la.s_family == NNG_AF_INET);
 	So(la.s_in.sa_port == htons(trantest_port - 1));
 	So(la.s_in.sa_port != 0);
@@ -41,20 +41,20 @@ check_props_v4(nng_msg *msg)
 
 	// untyped
 	z = sizeof(nng_sockaddr);
-	So(nng_pipe_getopt(p, NNG_OPT_REMADDR, &ra, &z) == 0);
+	So(nng_pipe_get(p, NNG_OPT_REMADDR, &ra, &z) == 0);
 	So(z == sizeof(ra));
 	So(ra.s_family == NNG_AF_INET);
 	So(ra.s_in.sa_port != 0);
 	So(ra.s_in.sa_addr == htonl(0x7f000001));
 
-	So(nng_pipe_getopt_size(p, NNG_OPT_REMADDR, &z) == NNG_EBADTYPE);
+	So(nng_pipe_get_size(p, NNG_OPT_REMADDR, &z) == NNG_EBADTYPE);
 	z = 1;
-	So(nng_pipe_getopt(p, NNG_OPT_REMADDR, &ra, &z) == NNG_EINVAL);
+	So(nng_pipe_get(p, NNG_OPT_REMADDR, &ra, &z) == NNG_EINVAL);
 
-	So(nng_pipe_getopt_bool(p, NNG_OPT_TCP_KEEPALIVE, &b) == 0);
+	So(nng_pipe_get_bool(p, NNG_OPT_TCP_KEEPALIVE, &b) == 0);
 	So(b == false); // default
 
-	So(nng_pipe_getopt_bool(p, NNG_OPT_TCP_NODELAY, &b) == 0);
+	So(nng_pipe_get_bool(p, NNG_OPT_TCP_NODELAY, &b) == 0);
 	So(b == true); // default
 
 	return (0);
diff --git a/tests/tcp6.c b/tests/tcp6.c
index ecc55a4..846b2c8 100644
--- a/tests/tcp6.c
+++ b/tests/tcp6.c
@@ -53,7 +53,7 @@ check_props_v6(nng_msg *msg)
 	z = sizeof(nng_sockaddr);
 	p = nng_msg_get_pipe(msg);
 	So(nng_pipe_id(p) > 0);
-	So(nng_pipe_getopt(p, NNG_OPT_LOCADDR, &la, &z) == 0);
+	So(nng_pipe_get(p, NNG_OPT_LOCADDR, &la, &z) == 0);
 	So(z == sizeof(la));
 	So(la.s_family == NNG_AF_INET6);
 	// So(la.s_in.sa_port == (trantest_port - 1));
@@ -65,7 +65,7 @@ check_props_v6(nng_msg *msg)
 	z = sizeof(nng_sockaddr);
 	p = nng_msg_get_pipe(msg);
 	So(nng_pipe_id(p) > 0);
-	So(nng_pipe_getopt(p, NNG_OPT_REMADDR, &ra, &z) == 0);
+	So(nng_pipe_get(p, NNG_OPT_REMADDR, &ra, &z) == 0);
 	So(z == sizeof(ra));
 	So(ra.s_family == NNG_AF_INET6);
 	So(ra.s_in6.sa_port != 0);
diff --git a/tests/tls.c b/tests/tls.c
index cdb3647..44927fe 100644
--- a/tests/tls.c
+++ b/tests/tls.c
@@ -92,7 +92,7 @@ check_props_v4(nng_msg *msg)
 	So(nng_pipe_id(p) > 0);
 
 	// Typed access
-	So(nng_pipe_getopt_sockaddr(p, NNG_OPT_LOCADDR, &la) == 0);
+	So(nng_pipe_get_addr(p, NNG_OPT_LOCADDR, &la) == 0);
 	So(la.s_family == NNG_AF_INET);
 	So(la.s_in.sa_port == htons(trantest_port - 1));
 	So(la.s_in.sa_port != 0);
@@ -100,24 +100,24 @@ check_props_v4(nng_msg *msg)
 
 	// Untyped access
 	z = sizeof(nng_sockaddr);
-	So(nng_pipe_getopt(p, NNG_OPT_REMADDR, &ra, &z) == 0);
+	So(nng_pipe_get(p, NNG_OPT_REMADDR, &ra, &z) == 0);
 	So(z == sizeof(ra));
 	So(ra.s_family == NNG_AF_INET);
 	So(ra.s_in.sa_port != 0);
 	So(ra.s_in.sa_addr == htonl(0x7f000001));
 
-	So(nng_pipe_getopt_bool(p, NNG_OPT_TCP_KEEPALIVE, &b) == 0);
+	So(nng_pipe_get_bool(p, NNG_OPT_TCP_KEEPALIVE, &b) == 0);
 	So(b == false); // default
 
-	So(nng_pipe_getopt_bool(p, NNG_OPT_TCP_NODELAY, &b) == 0);
+	So(nng_pipe_get_bool(p, NNG_OPT_TCP_NODELAY, &b) == 0);
 	So(b == true); // default
 
 	// Check for type enforcement
 	int i;
-	So(nng_pipe_getopt_int(p, NNG_OPT_REMADDR, &i) == NNG_EBADTYPE);
+	So(nng_pipe_get_int(p, NNG_OPT_REMADDR, &i) == NNG_EBADTYPE);
 
 	z = 1;
-	So(nng_pipe_getopt(p, NNG_OPT_REMADDR, &ra, &z) == NNG_EINVAL);
+	So(nng_pipe_get(p, NNG_OPT_REMADDR, &ra, &z) == NNG_EINVAL);
 
 	return (0);
 }
@@ -148,7 +148,7 @@ init_dialer_tls_ex(nng_dialer d, bool own_cert)
 		}
 	}
 
-	rv = nng_dialer_setopt_ptr(d, NNG_OPT_TLS_CONFIG, cfg);
+	rv = nng_dialer_set_ptr(d, NNG_OPT_TLS_CONFIG, cfg);
 
 out:
 	nng_tls_config_free(cfg);
@@ -173,7 +173,7 @@ init_listener_tls_ex(nng_listener l, int auth_mode)
 	if ((rv = nng_tls_config_own_cert(cfg, cert, key, NULL)) != 0) {
 		goto out;
 	}
-	if ((rv = nng_listener_setopt_ptr(l, NNG_OPT_TLS_CONFIG, cfg)) != 0) {
+	if ((rv = nng_listener_set_ptr(l, NNG_OPT_TLS_CONFIG, cfg)) != 0) {
 		goto out;
 	}
 	switch (auth_mode) {
@@ -221,7 +221,7 @@ init_dialer_tls_file(nng_dialer d)
 		return (rv);
 	}
 
-	rv = nng_dialer_setopt_string(d, NNG_OPT_TLS_CA_FILE, pth);
+	rv = nng_dialer_set_string(d, NNG_OPT_TLS_CA_FILE, pth);
 	nni_file_delete(pth);
 	nni_strfree(pth);
 
@@ -258,7 +258,7 @@ init_listener_tls_file(nng_listener l)
 		return (rv);
 	}
 
-	rv = nng_listener_setopt_string(l, NNG_OPT_TLS_CERT_KEY_FILE, pth);
+	rv = nng_listener_set_string(l, NNG_OPT_TLS_CERT_KEY_FILE, pth);
 	if (rv != 0) {
 		// We can wind up with EBUSY from the server already
 		// running.
@@ -321,7 +321,7 @@ TestMain("TLS Transport", {
 		trantest_prev_address(addr, "tls+tcp://127.0.0.1:%u");
 		So(nng_dialer_create(&d, s2, addr) == 0);
 		So(init_dialer_tls(d) == 0);
-		So(nng_dialer_setopt_int(
+		So(nng_dialer_set_int(
 		       d, NNG_OPT_TLS_AUTH_MODE, NNG_TLS_AUTH_MODE_NONE) == 0);
 		So(nng_listener_start(l, 0) == 0);
 		So(nng_dialer_start(d, 0) == 0);
@@ -344,10 +344,10 @@ TestMain("TLS Transport", {
 		So(nng_listener_create(&l, s1, "tls+tcp://127.0.0.1:0") == 0);
 		So(init_listener_tls(l) == 0);
 		So(nng_listener_start(l, 0) == 0);
-		So(nng_listener_getopt_string(l, NNG_OPT_URL, &addr) == 0);
+		So(nng_listener_get_string(l, NNG_OPT_URL, &addr) == 0);
 		So(nng_dialer_create(&d, s2, addr) == 0);
 		So(init_dialer_tls(d) == 0);
-		So(nng_dialer_setopt_int(
+		So(nng_dialer_set_int(
 		       d, NNG_OPT_TLS_AUTH_MODE, NNG_TLS_AUTH_MODE_NONE) == 0);
 		So(nng_dialer_start(d, 0) == 0);
 		nng_strfree(addr);
@@ -444,7 +444,7 @@ TestMain("TLS Transport", {
 
 		// reset port back one
 		trantest_prev_address(addr, "tls+tcp://127.0.0.1:%u");
-		So(nng_setopt_int(s2, NNG_OPT_TLS_AUTH_MODE,
+		So(nng_socket_set_int(s2, NNG_OPT_TLS_AUTH_MODE,
 		       NNG_TLS_AUTH_MODE_REQUIRED) == 0);
 
 		So(nng_dial(s2, addr, NULL, 0) == NNG_EPEERAUTH);
@@ -469,17 +469,17 @@ TestMain("TLS Transport", {
 		trantest_next_address(addr, "tls+tcp://*:%u");
 		So(nng_listener_create(&l, s1, addr) == 0);
 		So(init_listener_tls_file(l) == 0);
-		So(nng_listener_setopt_int(l, NNG_OPT_TLS_AUTH_MODE,
+		So(nng_listener_set_int(l, NNG_OPT_TLS_AUTH_MODE,
 		       NNG_TLS_AUTH_MODE_OPTIONAL) == 0);
 		So(nng_listener_start(l, 0) == 0);
 		nng_msleep(100);
 
 		// reset port back one
 		trantest_prev_address(addr, "tls+tcp://127.0.0.1:%u");
-		So(nng_setopt_ms(s2, NNG_OPT_RECVTIMEO, 200) == 0);
+		So(nng_socket_set_ms(s2, NNG_OPT_RECVTIMEO, 200) == 0);
 		So(nng_dialer_create(&d, s2, addr) == 0);
 		So(init_dialer_tls_file(d) == 0);
-		So(nng_dialer_setopt_string(
+		So(nng_dialer_set_string(
 		       d, NNG_OPT_TLS_SERVER_NAME, "localhost") == 0);
 		So(nng_dialer_start(d, 0) == 0);
 
@@ -490,7 +490,7 @@ TestMain("TLS Transport", {
 		So(strcmp(nng_msg_body(msg), "hello") == 0);
 		p = nng_msg_get_pipe(msg);
 		So(nng_pipe_id(p) > 0);
-		So(nng_pipe_getopt_bool(p, NNG_OPT_TLS_VERIFIED, &b) == 0);
+		So(nng_pipe_get_bool(p, NNG_OPT_TLS_VERIFIED, &b) == 0);
 		So(b == false);
 		nng_msg_free(msg);
 	});
@@ -523,7 +523,7 @@ TestMain("TLS Transport", {
 		So(nng_dialer_create(&d, s2, addr) == 0);
 		So(init_dialer_tls_ex(d, true) == 0);
 
-		So(nng_setopt_ms(s2, NNG_OPT_RECVTIMEO, 200) == 0);
+		So(nng_socket_set_ms(s2, NNG_OPT_RECVTIMEO, 200) == 0);
 		So(nng_dialer_start(d, 0) == 0);
 		nng_msleep(100);
 
@@ -536,10 +536,10 @@ TestMain("TLS Transport", {
 		So(strcmp(nng_msg_body(msg), "hello") == 0);
 		p = nng_msg_get_pipe(msg);
 		So(nng_pipe_id(p) > 0);
-		So(nng_pipe_getopt_bool(p, NNG_OPT_TLS_VERIFIED, &b) == 0);
+		So(nng_pipe_get_bool(p, NNG_OPT_TLS_VERIFIED, &b) == 0);
 		So(b == true);
 		int i;
-		So(nng_pipe_getopt_int(p, NNG_OPT_TLS_VERIFIED, &i) ==
+		So(nng_pipe_get_int(p, NNG_OPT_TLS_VERIFIED, &i) ==
 		    NNG_EBADTYPE);
 		nng_msg_free(msg);
 	});
@@ -553,44 +553,44 @@ TestMain("TLS Transport", {
 
 		So(nng_pair_open(&s) == 0);
 		Reset({ nng_close(s); });
-		So(nng_getopt_bool(s, NNG_OPT_TCP_NODELAY, &v) == 0);
+		So(nng_socket_get_bool(s, NNG_OPT_TCP_NODELAY, &v) == 0);
 		So(v == true);
 		So(nng_dialer_create(&d, s, "tcp://127.0.0.1:4999") == 0);
-		So(nng_dialer_getopt_bool(d, NNG_OPT_TCP_NODELAY, &v) == 0);
+		So(nng_dialer_get_bool(d, NNG_OPT_TCP_NODELAY, &v) == 0);
 		So(v == true);
-		So(nng_dialer_setopt_bool(d, NNG_OPT_TCP_NODELAY, false) == 0);
-		So(nng_dialer_getopt_bool(d, NNG_OPT_TCP_NODELAY, &v) == 0);
+		So(nng_dialer_set_bool(d, NNG_OPT_TCP_NODELAY, false) == 0);
+		So(nng_dialer_get_bool(d, NNG_OPT_TCP_NODELAY, &v) == 0);
 		So(v == false);
-		So(nng_dialer_getopt_int(d, NNG_OPT_TCP_NODELAY, &x) ==
+		So(nng_dialer_get_int(d, NNG_OPT_TCP_NODELAY, &x) ==
 		    NNG_EBADTYPE);
 		x = 0;
-		So(nng_dialer_setopt_int(d, NNG_OPT_TCP_NODELAY, x) ==
+		So(nng_dialer_set_int(d, NNG_OPT_TCP_NODELAY, x) ==
 		    NNG_EBADTYPE);
 		// This assumes sizeof (bool) != sizeof (int)
-		So(nng_dialer_setopt(d, NNG_OPT_TCP_NODELAY, &x, sizeof(x)) ==
+		So(nng_dialer_set(d, NNG_OPT_TCP_NODELAY, &x, sizeof(x)) ==
 		    NNG_EINVAL);
 
 		So(nng_listener_create(&l, s, "tcp://127.0.0.1:4999") == 0);
-		So(nng_listener_getopt_bool(l, NNG_OPT_TCP_NODELAY, &v) == 0);
+		So(nng_listener_get_bool(l, NNG_OPT_TCP_NODELAY, &v) == 0);
 		So(v == true);
 		x = 0;
-		So(nng_listener_setopt_int(l, NNG_OPT_TCP_NODELAY, x) ==
+		So(nng_listener_set_int(l, NNG_OPT_TCP_NODELAY, x) ==
 		    NNG_EBADTYPE);
 		// This assumes sizeof (bool) != sizeof (int)
-		So(nng_listener_setopt(
+		So(nng_listener_set(
 		       l, NNG_OPT_TCP_NODELAY, &x, sizeof(x)) == NNG_EINVAL);
 
 		nng_dialer_close(d);
 		nng_listener_close(l);
 
 		// Make sure socket wide defaults apply.
-		So(nng_setopt_bool(s, NNG_OPT_TCP_NODELAY, true) == 0);
+		So(nng_socket_set_bool(s, NNG_OPT_TCP_NODELAY, true) == 0);
 		v = false;
-		So(nng_getopt_bool(s, NNG_OPT_TCP_NODELAY, &v) == 0);
+		So(nng_socket_get_bool(s, NNG_OPT_TCP_NODELAY, &v) == 0);
 		So(v == true);
-		So(nng_setopt_bool(s, NNG_OPT_TCP_NODELAY, false) == 0);
+		So(nng_socket_set_bool(s, NNG_OPT_TCP_NODELAY, false) == 0);
 		So(nng_dialer_create(&d, s, "tcp://127.0.0.1:4999") == 0);
-		So(nng_dialer_getopt_bool(d, NNG_OPT_TCP_NODELAY, &v) == 0);
+		So(nng_dialer_get_bool(d, NNG_OPT_TCP_NODELAY, &v) == 0);
 		So(v == false);
 	});
 
@@ -603,40 +603,40 @@ TestMain("TLS Transport", {
 
 		So(nng_pair_open(&s) == 0);
 		Reset({ nng_close(s); });
-		So(nng_getopt_bool(s, NNG_OPT_TCP_KEEPALIVE, &v) == 0);
+		So(nng_socket_get_bool(s, NNG_OPT_TCP_KEEPALIVE, &v) == 0);
 		So(v == false);
 		So(nng_dialer_create(&d, s, "tcp://127.0.0.1:4999") == 0);
-		So(nng_dialer_getopt_bool(d, NNG_OPT_TCP_KEEPALIVE, &v) == 0);
+		So(nng_dialer_get_bool(d, NNG_OPT_TCP_KEEPALIVE, &v) == 0);
 		So(v == false);
-		So(nng_dialer_setopt_bool(d, NNG_OPT_TCP_KEEPALIVE, true) ==
+		So(nng_dialer_set_bool(d, NNG_OPT_TCP_KEEPALIVE, true) ==
 		    0);
-		So(nng_dialer_getopt_bool(d, NNG_OPT_TCP_KEEPALIVE, &v) == 0);
+		So(nng_dialer_get_bool(d, NNG_OPT_TCP_KEEPALIVE, &v) == 0);
 		So(v == true);
-		So(nng_dialer_getopt_int(d, NNG_OPT_TCP_KEEPALIVE, &x) ==
+		So(nng_dialer_get_int(d, NNG_OPT_TCP_KEEPALIVE, &x) ==
 		    NNG_EBADTYPE);
 		x = 1;
-		So(nng_dialer_setopt_int(d, NNG_OPT_TCP_KEEPALIVE, x) ==
+		So(nng_dialer_set_int(d, NNG_OPT_TCP_KEEPALIVE, x) ==
 		    NNG_EBADTYPE);
 
 		So(nng_listener_create(&l, s, "tcp://127.0.0.1:4999") == 0);
-		So(nng_listener_getopt_bool(l, NNG_OPT_TCP_KEEPALIVE, &v) ==
+		So(nng_listener_get_bool(l, NNG_OPT_TCP_KEEPALIVE, &v) ==
 		    0);
 		So(v == false);
 		x = 1;
-		So(nng_listener_setopt_int(l, NNG_OPT_TCP_KEEPALIVE, x) ==
+		So(nng_listener_set_int(l, NNG_OPT_TCP_KEEPALIVE, x) ==
 		    NNG_EBADTYPE);
 
 		nng_dialer_close(d);
 		nng_listener_close(l);
 
 		// Make sure socket wide defaults apply.
-		So(nng_setopt_bool(s, NNG_OPT_TCP_KEEPALIVE, false) == 0);
+		So(nng_socket_set_bool(s, NNG_OPT_TCP_KEEPALIVE, false) == 0);
 		v = true;
-		So(nng_getopt_bool(s, NNG_OPT_TCP_KEEPALIVE, &v) == 0);
+		So(nng_socket_get_bool(s, NNG_OPT_TCP_KEEPALIVE, &v) == 0);
 		So(v == false);
-		So(nng_setopt_bool(s, NNG_OPT_TCP_KEEPALIVE, true) == 0);
+		So(nng_socket_set_bool(s, NNG_OPT_TCP_KEEPALIVE, true) == 0);
 		So(nng_dialer_create(&d, s, "tcp://127.0.0.1:4999") == 0);
-		So(nng_dialer_getopt_bool(d, NNG_OPT_TCP_KEEPALIVE, &v) == 0);
+		So(nng_dialer_get_bool(d, NNG_OPT_TCP_KEEPALIVE, &v) == 0);
 		So(v == true);
 	});
 })
diff --git a/tests/trantest.h b/tests/trantest.h
index e56d755..be258e2 100644
--- a/tests/trantest.h
+++ b/tests/trantest.h
@@ -282,7 +282,7 @@ trantest_send_recv(trantest *tt)
 		So(strcmp(nng_msg_body(recv), "acknowledge") == 0);
 		p = nng_msg_get_pipe(recv);
 		So(nng_pipe_id(p) > 0);
-		So(nng_pipe_getopt_string(p, NNG_OPT_URL, &url) == 0);
+		So(nng_pipe_get_string(p, NNG_OPT_URL, &url) == 0);
 		So(strcmp(url, tt->addr) == 0);
 		nng_strfree(url);
 		nng_msg_free(recv);
@@ -336,7 +336,7 @@ trantest_send_recv_multi(trantest *tt)
 			So(strcmp(nng_msg_body(recv), msgbuf) == 0);
 			p = nng_msg_get_pipe(recv);
 			So(nng_pipe_id(p) > 0);
-			So(nng_pipe_getopt_string(p, NNG_OPT_URL, &url) == 0);
+			So(nng_pipe_get_string(p, NNG_OPT_URL, &url) == 0);
 			So(strcmp(url, tt->addr) == 0);
 			nng_strfree(url);
 			nng_msg_free(recv);
diff --git a/tests/ws.c b/tests/ws.c
index 548521b..c7f057f 100644
--- a/tests/ws.c
+++ b/tests/ws.c
@@ -33,14 +33,14 @@ check_props_v4(nng_msg *msg)
 	p = nng_msg_get_pipe(msg);
 	So(nng_pipe_id(p) > 0);
 
-	So(nng_pipe_getopt_sockaddr(p, NNG_OPT_LOCADDR, &la) == 0);
+	So(nng_pipe_get_addr(p, NNG_OPT_LOCADDR, &la) == 0);
 	So(la.s_family == NNG_AF_INET);
 	So(la.s_in.sa_port == htons(trantest_port - 1));
 	So(la.s_in.sa_port != 0);
 	So(la.s_in.sa_addr == htonl(0x7f000001));
 
 	z = sizeof(nng_sockaddr);
-	So(nng_pipe_getopt(p, NNG_OPT_REMADDR, &ra, &z) == 0);
+	So(nng_pipe_get(p, NNG_OPT_REMADDR, &ra, &z) == 0);
 	So(z == sizeof(ra));
 	So(ra.s_family == NNG_AF_INET);
 	So(ra.s_in.sa_port != 0);
@@ -49,32 +49,32 @@ check_props_v4(nng_msg *msg)
 	// Request Header
 	z   = 0;
 	buf = NULL;
-	So(nng_pipe_getopt(p, NNG_OPT_WS_REQUEST_HEADERS, buf, &z) ==
+	So(nng_pipe_get(p, NNG_OPT_WS_REQUEST_HEADERS, buf, &z) ==
 	    NNG_EINVAL);
 	So(z > 0);
 	len = z;
 	So((buf = nng_alloc(len)) != NULL);
-	So(nng_pipe_getopt(p, NNG_OPT_WS_REQUEST_HEADERS, buf, &z) == 0);
+	So(nng_pipe_get(p, NNG_OPT_WS_REQUEST_HEADERS, buf, &z) == 0);
 	So(strstr(buf, "Sec-WebSocket-Key") != NULL);
 	So(z == len);
 	nng_free(buf, len);
-	So(nng_pipe_getopt_string(p, NNG_OPT_WS_REQUEST_HEADERS, &buf) == 0);
+	So(nng_pipe_get_string(p, NNG_OPT_WS_REQUEST_HEADERS, &buf) == 0);
 	So(strlen(buf) == len - 1);
 	nng_strfree(buf);
 
 	// Response Header
 	z   = 0;
 	buf = NULL;
-	So(nng_pipe_getopt(p, NNG_OPT_WS_RESPONSE_HEADERS, buf, &z) ==
+	So(nng_pipe_get(p, NNG_OPT_WS_RESPONSE_HEADERS, buf, &z) ==
 	    NNG_EINVAL);
 	So(z > 0);
 	len = z;
 	So((buf = nng_alloc(len)) != NULL);
-	So(nng_pipe_getopt(p, NNG_OPT_WS_RESPONSE_HEADERS, buf, &z) == 0);
+	So(nng_pipe_get(p, NNG_OPT_WS_RESPONSE_HEADERS, buf, &z) == 0);
 	So(strstr(buf, "Sec-WebSocket-Accept") != NULL);
 	So(z == len);
 	nng_free(buf, len);
-	So(nng_pipe_getopt_string(p, NNG_OPT_WS_RESPONSE_HEADERS, &buf) == 0);
+	So(nng_pipe_get_string(p, NNG_OPT_WS_RESPONSE_HEADERS, &buf) == 0);
 	So(strlen(buf) == len - 1);
 	nng_strfree(buf);
 
diff --git a/tests/wss.c b/tests/wss.c
index 0f570b8..455d9d8 100644
--- a/tests/wss.c
+++ b/tests/wss.c
@@ -143,24 +143,24 @@ check_props(nng_msg *msg)
 	So(nng_pipe_id(p) > 0);
 
 	z = sizeof(nng_sockaddr);
-	So(nng_pipe_getopt(p, NNG_OPT_LOCADDR, &la, &z) == 0);
+	So(nng_pipe_get(p, NNG_OPT_LOCADDR, &la, &z) == 0);
 	So(z == sizeof(la));
 	So(validloopback(&la));
 
 	z = sizeof(nng_sockaddr);
-	So(nng_pipe_getopt(p, NNG_OPT_REMADDR, &ra, &z) == 0);
+	So(nng_pipe_get(p, NNG_OPT_REMADDR, &ra, &z) == 0);
 	So(z == sizeof(ra));
 	So(validloopback(&ra));
 
 	// Request header
 	z   = 0;
 	buf = NULL;
-	So(nng_pipe_getopt(p, NNG_OPT_WS_REQUEST_HEADERS, buf, &z) ==
+	So(nng_pipe_get(p, NNG_OPT_WS_REQUEST_HEADERS, buf, &z) ==
 	    NNG_EINVAL);
 	So(z > 0);
 	len = z;
 	So((buf = nng_alloc(len)) != NULL);
-	So(nng_pipe_getopt(p, NNG_OPT_WS_REQUEST_HEADERS, buf, &z) == 0);
+	So(nng_pipe_get(p, NNG_OPT_WS_REQUEST_HEADERS, buf, &z) == 0);
 	So(strstr(buf, "Sec-WebSocket-Key") != NULL);
 	So(z == len);
 	nng_free(buf, len);
@@ -168,12 +168,12 @@ check_props(nng_msg *msg)
 	// Response header
 	z   = 0;
 	buf = NULL;
-	So(nng_pipe_getopt(p, NNG_OPT_WS_RESPONSE_HEADERS, buf, &z) ==
+	So(nng_pipe_get(p, NNG_OPT_WS_RESPONSE_HEADERS, buf, &z) ==
 	    NNG_EINVAL);
 	So(z > 0);
 	len = z;
 	So((buf = nng_alloc(len)) != NULL);
-	So(nng_pipe_getopt(p, NNG_OPT_WS_RESPONSE_HEADERS, buf, &z) == 0);
+	So(nng_pipe_get(p, NNG_OPT_WS_RESPONSE_HEADERS, buf, &z) == 0);
 	So(strstr(buf, "Sec-WebSocket-Accept") != NULL);
 	So(z == len);
 	nng_free(buf, len);
@@ -200,7 +200,7 @@ init_dialer_wss(nng_dialer d)
 	    0) {
 		goto out;
 	}
-	rv = nng_dialer_setopt_ptr(d, NNG_OPT_TLS_CONFIG, cfg);
+	rv = nng_dialer_set_ptr(d, NNG_OPT_TLS_CONFIG, cfg);
 
 out:
 	nng_tls_config_free(cfg);
@@ -220,7 +220,7 @@ init_listener_wss(nng_listener l)
 		goto out;
 	}
 
-	if ((rv = nng_listener_setopt_ptr(l, NNG_OPT_TLS_CONFIG, cfg)) != 0) {
+	if ((rv = nng_listener_set_ptr(l, NNG_OPT_TLS_CONFIG, cfg)) != 0) {
 		// We can wind up with EBUSY from the server already running.
 		if (rv == NNG_EBUSY) {
 			rv = 0;
diff --git a/tests/zt.c b/tests/zt.c
index 091fa84..b2aca7e 100644
--- a/tests/zt.c
+++ b/tests/zt.c
@@ -50,7 +50,7 @@ check_props(nng_msg *msg)
 	// Check local address.
 	Convey("Local address property works", {
 		nng_sockaddr la;
-		So(nng_pipe_getopt_sockaddr(p, NNG_OPT_LOCADDR, &la) == 0);
+		So(nng_pipe_get_addr(p, NNG_OPT_LOCADDR, &la) == 0);
 
 		So(la.s_family == NNG_AF_ZT);
 		So(la.s_zt.sa_port == (trantest_port - 1));
@@ -63,12 +63,12 @@ check_props(nng_msg *msg)
 		uint64_t     mynode;
 		nng_sockaddr ra;
 
-		So(nng_pipe_getopt_sockaddr(p, NNG_OPT_REMADDR, &ra) == 0);
+		So(nng_pipe_get_addr(p, NNG_OPT_REMADDR, &ra) == 0);
 		So(ra.s_family == NNG_AF_ZT);
 		So(ra.s_zt.sa_port != 0);
 		So(ra.s_zt.sa_nwid == NWID_NUM);
 
-		So(nng_pipe_getopt_uint64(p, NNG_OPT_ZT_NODE, &mynode) == 0);
+		So(nng_pipe_get_uint64(p, NNG_OPT_ZT_NODE, &mynode) == 0);
 		So(mynode != 0);
 		So(ra.s_zt.sa_nodeid == mynode);
 	});
@@ -76,14 +76,14 @@ check_props(nng_msg *msg)
 	Convey("NWID property works", {
 		uint64_t nwid = 0;
 
-		So(nng_pipe_getopt_uint64(p, NNG_OPT_ZT_NWID, &nwid) == 0);
+		So(nng_pipe_get_uint64(p, NNG_OPT_ZT_NWID, &nwid) == 0);
 		So(nwid = 0xa09acf02337b057bull);
 	});
 
 	Convey("Network status property works", {
 		int s = 0;
 
-		So(nng_pipe_getopt_int(p, NNG_OPT_ZT_NETWORK_STATUS, &s) == 0);
+		So(nng_pipe_get_int(p, NNG_OPT_ZT_NETWORK_STATUS, &s) == 0);
 		So(s == NNG_ZT_STATUS_UP);
 	});
 
@@ -91,16 +91,16 @@ check_props(nng_msg *msg)
 		int          c = 0;
 		nng_duration t = 0;
 
-		So(nng_pipe_getopt_int(p, NNG_OPT_ZT_PING_TRIES, &c) == 0);
+		So(nng_pipe_get_int(p, NNG_OPT_ZT_PING_TRIES, &c) == 0);
 		So(c > 0 && c <= 10);
 
-		So(nng_pipe_getopt_ms(p, NNG_OPT_ZT_PING_TIME, &t) == 0);
+		So(nng_pipe_get_ms(p, NNG_OPT_ZT_PING_TIME, &t) == 0);
 		So(t > 1000 && t < 3600000); // 1 sec - 1 hour
 	});
 
 	Convey("Home property works", {
 		char *v;
-		So(nng_pipe_getopt_string(p, NNG_OPT_ZT_HOME, &v) == 0);
+		So(nng_pipe_get_string(p, NNG_OPT_ZT_HOME, &v) == 0);
 		nng_strfree(v);
 	});
 
@@ -108,14 +108,14 @@ check_props(nng_msg *msg)
 		size_t mtu;
 
 		// Check MTU
-		So(nng_pipe_getopt_size(p, NNG_OPT_ZT_MTU, &mtu) == 0);
+		So(nng_pipe_get_size(p, NNG_OPT_ZT_MTU, &mtu) == 0);
 		So(mtu >= 1000 && mtu <= 10000);
 	});
 
 	Convey("Network name property works", {
 		char *name;
 
-		So(nng_pipe_getopt_string(p, NNG_OPT_ZT_NETWORK_NAME, &name) ==
+		So(nng_pipe_get_string(p, NNG_OPT_ZT_NETWORK_NAME, &name) ==
 		    0);
 		So(strcmp(name, "nng_test_open") == 0);
 		nng_strfree(name);
@@ -158,7 +158,7 @@ TestMain("ZeroTier Transport", {
 
 			Convey("It has the right local address", {
 				nng_sockaddr sa;
-				So(nng_listener_getopt_sockaddr(
+				So(nng_listener_get_addr(
 				       l, NNG_OPT_LOCADDR, &sa) == 0);
 				So(sa.s_zt.sa_family == NNG_AF_ZT);
 				So(sa.s_zt.sa_nwid == NWID_NUM);
@@ -218,7 +218,7 @@ TestMain("ZeroTier Transport", {
 
 		So(nng_listener_create(&l, s, addr) == 0);
 
-		So(nng_listener_getopt_uint64(l, NNG_OPT_ZT_NODE, &node1) ==
+		So(nng_listener_get_uint64(l, NNG_OPT_ZT_NODE, &node1) ==
 		    0);
 		So(node1 != 0);
 
@@ -226,7 +226,7 @@ TestMain("ZeroTier Transport", {
 			snprintf(addr, sizeof(addr), "zt://%llx." NWID ":%u",
 			    (unsigned long long) node1, 42u);
 			So(nng_dialer_create(&d, s, addr) == 0);
-			So(nng_dialer_getopt_uint64(
+			So(nng_dialer_get_uint64(
 			       d, NNG_OPT_ZT_NODE, &node2) == 0);
 			So(node2 == node1);
 			So(nng_dialer_start(d, 0) == NNG_ECONNREFUSED);
@@ -262,7 +262,7 @@ TestMain("ZeroTier Transport", {
 
 		So(nng_listener_start(l, 0) == 0);
 		node = 0;
-		So(nng_listener_getopt_uint64(l, NNG_OPT_ZT_NODE, &node) == 0);
+		So(nng_listener_get_uint64(l, NNG_OPT_ZT_NODE, &node) == 0);
 		So(node != 0);
 		nng_msleep(40);
 		snprintf(addr2, sizeof(addr2), "zt://%llx." NWID ":%u",
@@ -285,7 +285,7 @@ TestMain("ZeroTier Transport", {
 	So(nng_pair_open(&s_test) == 0);
 	So(nng_listener_create(&l_test, s_test, "zt://*." NWID ":0") == 0);
 	So(nng_listener_start(l_test, 0) == 0);
-	So(nng_listener_getopt_uint64(l_test, NNG_OPT_ZT_NODE, &node) == 0);
+	So(nng_listener_get_uint64(l_test, NNG_OPT_ZT_NODE, &node) == 0);
 	snprintf(fmt, sizeof(fmt), "zt://%llx." NWID ":%%u",
 	    (unsigned long long) node);
 	nng_listener_close(l_test);
